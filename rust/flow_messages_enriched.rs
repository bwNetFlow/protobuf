// This file is generated by rust-protobuf 2.24.1. Do not edit
// @generated

// https://github.com/rust-lang/rust-clippy/issues/702
#![allow(unknown_lints)]
#![allow(clippy::all)]

#![allow(unused_attributes)]
#![cfg_attr(rustfmt, rustfmt::skip)]

#![allow(box_pointers)]
#![allow(dead_code)]
#![allow(missing_docs)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(non_upper_case_globals)]
#![allow(trivial_casts)]
#![allow(unused_imports)]
#![allow(unused_results)]
//! Generated file from `flow-messages-enriched.proto`

/// Generated files are compatible only with the same version
/// of protobuf runtime.
// const _PROTOBUF_VERSION_CHECK: () = ::protobuf::VERSION_2_24_1;

#[derive(PartialEq,Clone,Default)]
pub struct FlowMessage {
    // message fields
    pub Type: FlowMessage_FlowType,
    pub TimeReceived: u64,
    pub SequenceNum: u32,
    pub SamplingRate: u64,
    pub FlowDirection: u32,
    pub SamplerAddress: ::std::vec::Vec<u8>,
    pub TimeFlowStart: u64,
    pub TimeFlowEnd: u64,
    pub Bytes: u64,
    pub Packets: u64,
    pub SrcAddr: ::std::vec::Vec<u8>,
    pub DstAddr: ::std::vec::Vec<u8>,
    pub Etype: u32,
    pub Proto: u32,
    pub SrcPort: u32,
    pub DstPort: u32,
    pub InIf: u32,
    pub OutIf: u32,
    pub SrcMac: u64,
    pub DstMac: u64,
    pub SrcVlan: u32,
    pub DstVlan: u32,
    pub VlanId: u32,
    pub IngressVrfID: u32,
    pub EgressVrfID: u32,
    pub IPTos: u32,
    pub ForwardingStatus: u32,
    pub IPTTL: u32,
    pub TCPFlags: u32,
    pub IcmpType: u32,
    pub IcmpCode: u32,
    pub IPv6FlowLabel: u32,
    pub FragmentId: u32,
    pub FragmentOffset: u32,
    pub BiFlowDirection: u32,
    pub SrcAS: u32,
    pub DstAS: u32,
    pub NextHop: ::std::vec::Vec<u8>,
    pub NextHopAS: u32,
    pub SrcNet: u32,
    pub DstNet: u32,
    pub HasMPLS: bool,
    pub MPLSCount: u32,
    pub MPLS1TTL: u32,
    pub MPLS1Label: u32,
    pub MPLS2TTL: u32,
    pub MPLS2Label: u32,
    pub MPLS3TTL: u32,
    pub MPLS3Label: u32,
    pub MPLSLastTTL: u32,
    pub MPLSLastLabel: u32,
    pub Cid: u32,
    pub CidString: ::std::string::String,
    pub Normalized: FlowMessage_NormalizedType,
    pub SrcIfName: ::std::string::String,
    pub SrcIfDesc: ::std::string::String,
    pub SrcIfSpeed: u32,
    pub DstIfName: ::std::string::String,
    pub DstIfDesc: ::std::string::String,
    pub DstIfSpeed: u32,
    pub ProtoName: ::std::string::String,
    pub RemoteCountry: ::std::string::String,
    pub RemoteAddr: FlowMessage_RemoteAddrType,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a FlowMessage {
    fn default() -> &'a FlowMessage {
        <FlowMessage as ::protobuf::Message>::default_instance()
    }
}

impl FlowMessage {
    pub fn new() -> FlowMessage {
        ::std::default::Default::default()
    }

    // .flowmessageenriched.FlowMessage.FlowType Type = 1;


    pub fn get_Type(&self) -> FlowMessage_FlowType {
        self.Type
    }
    pub fn clear_Type(&mut self) {
        self.Type = FlowMessage_FlowType::FLOWUNKNOWN;
    }

    // Param is passed by value, moved
    pub fn set_Type(&mut self, v: FlowMessage_FlowType) {
        self.Type = v;
    }

    // uint64 TimeReceived = 2;


    pub fn get_TimeReceived(&self) -> u64 {
        self.TimeReceived
    }
    pub fn clear_TimeReceived(&mut self) {
        self.TimeReceived = 0;
    }

    // Param is passed by value, moved
    pub fn set_TimeReceived(&mut self, v: u64) {
        self.TimeReceived = v;
    }

    // uint32 SequenceNum = 4;


    pub fn get_SequenceNum(&self) -> u32 {
        self.SequenceNum
    }
    pub fn clear_SequenceNum(&mut self) {
        self.SequenceNum = 0;
    }

    // Param is passed by value, moved
    pub fn set_SequenceNum(&mut self, v: u32) {
        self.SequenceNum = v;
    }

    // uint64 SamplingRate = 3;


    pub fn get_SamplingRate(&self) -> u64 {
        self.SamplingRate
    }
    pub fn clear_SamplingRate(&mut self) {
        self.SamplingRate = 0;
    }

    // Param is passed by value, moved
    pub fn set_SamplingRate(&mut self, v: u64) {
        self.SamplingRate = v;
    }

    // uint32 FlowDirection = 42;


    pub fn get_FlowDirection(&self) -> u32 {
        self.FlowDirection
    }
    pub fn clear_FlowDirection(&mut self) {
        self.FlowDirection = 0;
    }

    // Param is passed by value, moved
    pub fn set_FlowDirection(&mut self, v: u32) {
        self.FlowDirection = v;
    }

    // bytes SamplerAddress = 11;


    pub fn get_SamplerAddress(&self) -> &[u8] {
        &self.SamplerAddress
    }
    pub fn clear_SamplerAddress(&mut self) {
        self.SamplerAddress.clear();
    }

    // Param is passed by value, moved
    pub fn set_SamplerAddress(&mut self, v: ::std::vec::Vec<u8>) {
        self.SamplerAddress = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_SamplerAddress(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.SamplerAddress
    }

    // Take field
    pub fn take_SamplerAddress(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.SamplerAddress, ::std::vec::Vec::new())
    }

    // uint64 TimeFlowStart = 38;


    pub fn get_TimeFlowStart(&self) -> u64 {
        self.TimeFlowStart
    }
    pub fn clear_TimeFlowStart(&mut self) {
        self.TimeFlowStart = 0;
    }

    // Param is passed by value, moved
    pub fn set_TimeFlowStart(&mut self, v: u64) {
        self.TimeFlowStart = v;
    }

    // uint64 TimeFlowEnd = 5;


    pub fn get_TimeFlowEnd(&self) -> u64 {
        self.TimeFlowEnd
    }
    pub fn clear_TimeFlowEnd(&mut self) {
        self.TimeFlowEnd = 0;
    }

    // Param is passed by value, moved
    pub fn set_TimeFlowEnd(&mut self, v: u64) {
        self.TimeFlowEnd = v;
    }

    // uint64 Bytes = 9;


    pub fn get_Bytes(&self) -> u64 {
        self.Bytes
    }
    pub fn clear_Bytes(&mut self) {
        self.Bytes = 0;
    }

    // Param is passed by value, moved
    pub fn set_Bytes(&mut self, v: u64) {
        self.Bytes = v;
    }

    // uint64 Packets = 10;


    pub fn get_Packets(&self) -> u64 {
        self.Packets
    }
    pub fn clear_Packets(&mut self) {
        self.Packets = 0;
    }

    // Param is passed by value, moved
    pub fn set_Packets(&mut self, v: u64) {
        self.Packets = v;
    }

    // bytes SrcAddr = 6;


    pub fn get_SrcAddr(&self) -> &[u8] {
        &self.SrcAddr
    }
    pub fn clear_SrcAddr(&mut self) {
        self.SrcAddr.clear();
    }

    // Param is passed by value, moved
    pub fn set_SrcAddr(&mut self, v: ::std::vec::Vec<u8>) {
        self.SrcAddr = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_SrcAddr(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.SrcAddr
    }

    // Take field
    pub fn take_SrcAddr(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.SrcAddr, ::std::vec::Vec::new())
    }

    // bytes DstAddr = 7;


    pub fn get_DstAddr(&self) -> &[u8] {
        &self.DstAddr
    }
    pub fn clear_DstAddr(&mut self) {
        self.DstAddr.clear();
    }

    // Param is passed by value, moved
    pub fn set_DstAddr(&mut self, v: ::std::vec::Vec<u8>) {
        self.DstAddr = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_DstAddr(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.DstAddr
    }

    // Take field
    pub fn take_DstAddr(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.DstAddr, ::std::vec::Vec::new())
    }

    // uint32 Etype = 30;


    pub fn get_Etype(&self) -> u32 {
        self.Etype
    }
    pub fn clear_Etype(&mut self) {
        self.Etype = 0;
    }

    // Param is passed by value, moved
    pub fn set_Etype(&mut self, v: u32) {
        self.Etype = v;
    }

    // uint32 Proto = 20;


    pub fn get_Proto(&self) -> u32 {
        self.Proto
    }
    pub fn clear_Proto(&mut self) {
        self.Proto = 0;
    }

    // Param is passed by value, moved
    pub fn set_Proto(&mut self, v: u32) {
        self.Proto = v;
    }

    // uint32 SrcPort = 21;


    pub fn get_SrcPort(&self) -> u32 {
        self.SrcPort
    }
    pub fn clear_SrcPort(&mut self) {
        self.SrcPort = 0;
    }

    // Param is passed by value, moved
    pub fn set_SrcPort(&mut self, v: u32) {
        self.SrcPort = v;
    }

    // uint32 DstPort = 22;


    pub fn get_DstPort(&self) -> u32 {
        self.DstPort
    }
    pub fn clear_DstPort(&mut self) {
        self.DstPort = 0;
    }

    // Param is passed by value, moved
    pub fn set_DstPort(&mut self, v: u32) {
        self.DstPort = v;
    }

    // uint32 InIf = 18;


    pub fn get_InIf(&self) -> u32 {
        self.InIf
    }
    pub fn clear_InIf(&mut self) {
        self.InIf = 0;
    }

    // Param is passed by value, moved
    pub fn set_InIf(&mut self, v: u32) {
        self.InIf = v;
    }

    // uint32 OutIf = 19;


    pub fn get_OutIf(&self) -> u32 {
        self.OutIf
    }
    pub fn clear_OutIf(&mut self) {
        self.OutIf = 0;
    }

    // Param is passed by value, moved
    pub fn set_OutIf(&mut self, v: u32) {
        self.OutIf = v;
    }

    // uint64 SrcMac = 27;


    pub fn get_SrcMac(&self) -> u64 {
        self.SrcMac
    }
    pub fn clear_SrcMac(&mut self) {
        self.SrcMac = 0;
    }

    // Param is passed by value, moved
    pub fn set_SrcMac(&mut self, v: u64) {
        self.SrcMac = v;
    }

    // uint64 DstMac = 28;


    pub fn get_DstMac(&self) -> u64 {
        self.DstMac
    }
    pub fn clear_DstMac(&mut self) {
        self.DstMac = 0;
    }

    // Param is passed by value, moved
    pub fn set_DstMac(&mut self, v: u64) {
        self.DstMac = v;
    }

    // uint32 SrcVlan = 33;


    pub fn get_SrcVlan(&self) -> u32 {
        self.SrcVlan
    }
    pub fn clear_SrcVlan(&mut self) {
        self.SrcVlan = 0;
    }

    // Param is passed by value, moved
    pub fn set_SrcVlan(&mut self, v: u32) {
        self.SrcVlan = v;
    }

    // uint32 DstVlan = 34;


    pub fn get_DstVlan(&self) -> u32 {
        self.DstVlan
    }
    pub fn clear_DstVlan(&mut self) {
        self.DstVlan = 0;
    }

    // Param is passed by value, moved
    pub fn set_DstVlan(&mut self, v: u32) {
        self.DstVlan = v;
    }

    // uint32 VlanId = 29;


    pub fn get_VlanId(&self) -> u32 {
        self.VlanId
    }
    pub fn clear_VlanId(&mut self) {
        self.VlanId = 0;
    }

    // Param is passed by value, moved
    pub fn set_VlanId(&mut self, v: u32) {
        self.VlanId = v;
    }

    // uint32 IngressVrfID = 39;


    pub fn get_IngressVrfID(&self) -> u32 {
        self.IngressVrfID
    }
    pub fn clear_IngressVrfID(&mut self) {
        self.IngressVrfID = 0;
    }

    // Param is passed by value, moved
    pub fn set_IngressVrfID(&mut self, v: u32) {
        self.IngressVrfID = v;
    }

    // uint32 EgressVrfID = 40;


    pub fn get_EgressVrfID(&self) -> u32 {
        self.EgressVrfID
    }
    pub fn clear_EgressVrfID(&mut self) {
        self.EgressVrfID = 0;
    }

    // Param is passed by value, moved
    pub fn set_EgressVrfID(&mut self, v: u32) {
        self.EgressVrfID = v;
    }

    // uint32 IPTos = 23;


    pub fn get_IPTos(&self) -> u32 {
        self.IPTos
    }
    pub fn clear_IPTos(&mut self) {
        self.IPTos = 0;
    }

    // Param is passed by value, moved
    pub fn set_IPTos(&mut self, v: u32) {
        self.IPTos = v;
    }

    // uint32 ForwardingStatus = 24;


    pub fn get_ForwardingStatus(&self) -> u32 {
        self.ForwardingStatus
    }
    pub fn clear_ForwardingStatus(&mut self) {
        self.ForwardingStatus = 0;
    }

    // Param is passed by value, moved
    pub fn set_ForwardingStatus(&mut self, v: u32) {
        self.ForwardingStatus = v;
    }

    // uint32 IPTTL = 25;


    pub fn get_IPTTL(&self) -> u32 {
        self.IPTTL
    }
    pub fn clear_IPTTL(&mut self) {
        self.IPTTL = 0;
    }

    // Param is passed by value, moved
    pub fn set_IPTTL(&mut self, v: u32) {
        self.IPTTL = v;
    }

    // uint32 TCPFlags = 26;


    pub fn get_TCPFlags(&self) -> u32 {
        self.TCPFlags
    }
    pub fn clear_TCPFlags(&mut self) {
        self.TCPFlags = 0;
    }

    // Param is passed by value, moved
    pub fn set_TCPFlags(&mut self, v: u32) {
        self.TCPFlags = v;
    }

    // uint32 IcmpType = 31;


    pub fn get_IcmpType(&self) -> u32 {
        self.IcmpType
    }
    pub fn clear_IcmpType(&mut self) {
        self.IcmpType = 0;
    }

    // Param is passed by value, moved
    pub fn set_IcmpType(&mut self, v: u32) {
        self.IcmpType = v;
    }

    // uint32 IcmpCode = 32;


    pub fn get_IcmpCode(&self) -> u32 {
        self.IcmpCode
    }
    pub fn clear_IcmpCode(&mut self) {
        self.IcmpCode = 0;
    }

    // Param is passed by value, moved
    pub fn set_IcmpCode(&mut self, v: u32) {
        self.IcmpCode = v;
    }

    // uint32 IPv6FlowLabel = 37;


    pub fn get_IPv6FlowLabel(&self) -> u32 {
        self.IPv6FlowLabel
    }
    pub fn clear_IPv6FlowLabel(&mut self) {
        self.IPv6FlowLabel = 0;
    }

    // Param is passed by value, moved
    pub fn set_IPv6FlowLabel(&mut self, v: u32) {
        self.IPv6FlowLabel = v;
    }

    // uint32 FragmentId = 35;


    pub fn get_FragmentId(&self) -> u32 {
        self.FragmentId
    }
    pub fn clear_FragmentId(&mut self) {
        self.FragmentId = 0;
    }

    // Param is passed by value, moved
    pub fn set_FragmentId(&mut self, v: u32) {
        self.FragmentId = v;
    }

    // uint32 FragmentOffset = 36;


    pub fn get_FragmentOffset(&self) -> u32 {
        self.FragmentOffset
    }
    pub fn clear_FragmentOffset(&mut self) {
        self.FragmentOffset = 0;
    }

    // Param is passed by value, moved
    pub fn set_FragmentOffset(&mut self, v: u32) {
        self.FragmentOffset = v;
    }

    // uint32 BiFlowDirection = 41;


    pub fn get_BiFlowDirection(&self) -> u32 {
        self.BiFlowDirection
    }
    pub fn clear_BiFlowDirection(&mut self) {
        self.BiFlowDirection = 0;
    }

    // Param is passed by value, moved
    pub fn set_BiFlowDirection(&mut self, v: u32) {
        self.BiFlowDirection = v;
    }

    // uint32 SrcAS = 14;


    pub fn get_SrcAS(&self) -> u32 {
        self.SrcAS
    }
    pub fn clear_SrcAS(&mut self) {
        self.SrcAS = 0;
    }

    // Param is passed by value, moved
    pub fn set_SrcAS(&mut self, v: u32) {
        self.SrcAS = v;
    }

    // uint32 DstAS = 15;


    pub fn get_DstAS(&self) -> u32 {
        self.DstAS
    }
    pub fn clear_DstAS(&mut self) {
        self.DstAS = 0;
    }

    // Param is passed by value, moved
    pub fn set_DstAS(&mut self, v: u32) {
        self.DstAS = v;
    }

    // bytes NextHop = 12;


    pub fn get_NextHop(&self) -> &[u8] {
        &self.NextHop
    }
    pub fn clear_NextHop(&mut self) {
        self.NextHop.clear();
    }

    // Param is passed by value, moved
    pub fn set_NextHop(&mut self, v: ::std::vec::Vec<u8>) {
        self.NextHop = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_NextHop(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.NextHop
    }

    // Take field
    pub fn take_NextHop(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.NextHop, ::std::vec::Vec::new())
    }

    // uint32 NextHopAS = 13;


    pub fn get_NextHopAS(&self) -> u32 {
        self.NextHopAS
    }
    pub fn clear_NextHopAS(&mut self) {
        self.NextHopAS = 0;
    }

    // Param is passed by value, moved
    pub fn set_NextHopAS(&mut self, v: u32) {
        self.NextHopAS = v;
    }

    // uint32 SrcNet = 16;


    pub fn get_SrcNet(&self) -> u32 {
        self.SrcNet
    }
    pub fn clear_SrcNet(&mut self) {
        self.SrcNet = 0;
    }

    // Param is passed by value, moved
    pub fn set_SrcNet(&mut self, v: u32) {
        self.SrcNet = v;
    }

    // uint32 DstNet = 17;


    pub fn get_DstNet(&self) -> u32 {
        self.DstNet
    }
    pub fn clear_DstNet(&mut self) {
        self.DstNet = 0;
    }

    // Param is passed by value, moved
    pub fn set_DstNet(&mut self, v: u32) {
        self.DstNet = v;
    }

    // bool HasMPLS = 53;


    pub fn get_HasMPLS(&self) -> bool {
        self.HasMPLS
    }
    pub fn clear_HasMPLS(&mut self) {
        self.HasMPLS = false;
    }

    // Param is passed by value, moved
    pub fn set_HasMPLS(&mut self, v: bool) {
        self.HasMPLS = v;
    }

    // uint32 MPLSCount = 54;


    pub fn get_MPLSCount(&self) -> u32 {
        self.MPLSCount
    }
    pub fn clear_MPLSCount(&mut self) {
        self.MPLSCount = 0;
    }

    // Param is passed by value, moved
    pub fn set_MPLSCount(&mut self, v: u32) {
        self.MPLSCount = v;
    }

    // uint32 MPLS1TTL = 55;


    pub fn get_MPLS1TTL(&self) -> u32 {
        self.MPLS1TTL
    }
    pub fn clear_MPLS1TTL(&mut self) {
        self.MPLS1TTL = 0;
    }

    // Param is passed by value, moved
    pub fn set_MPLS1TTL(&mut self, v: u32) {
        self.MPLS1TTL = v;
    }

    // uint32 MPLS1Label = 56;


    pub fn get_MPLS1Label(&self) -> u32 {
        self.MPLS1Label
    }
    pub fn clear_MPLS1Label(&mut self) {
        self.MPLS1Label = 0;
    }

    // Param is passed by value, moved
    pub fn set_MPLS1Label(&mut self, v: u32) {
        self.MPLS1Label = v;
    }

    // uint32 MPLS2TTL = 57;


    pub fn get_MPLS2TTL(&self) -> u32 {
        self.MPLS2TTL
    }
    pub fn clear_MPLS2TTL(&mut self) {
        self.MPLS2TTL = 0;
    }

    // Param is passed by value, moved
    pub fn set_MPLS2TTL(&mut self, v: u32) {
        self.MPLS2TTL = v;
    }

    // uint32 MPLS2Label = 58;


    pub fn get_MPLS2Label(&self) -> u32 {
        self.MPLS2Label
    }
    pub fn clear_MPLS2Label(&mut self) {
        self.MPLS2Label = 0;
    }

    // Param is passed by value, moved
    pub fn set_MPLS2Label(&mut self, v: u32) {
        self.MPLS2Label = v;
    }

    // uint32 MPLS3TTL = 59;


    pub fn get_MPLS3TTL(&self) -> u32 {
        self.MPLS3TTL
    }
    pub fn clear_MPLS3TTL(&mut self) {
        self.MPLS3TTL = 0;
    }

    // Param is passed by value, moved
    pub fn set_MPLS3TTL(&mut self, v: u32) {
        self.MPLS3TTL = v;
    }

    // uint32 MPLS3Label = 60;


    pub fn get_MPLS3Label(&self) -> u32 {
        self.MPLS3Label
    }
    pub fn clear_MPLS3Label(&mut self) {
        self.MPLS3Label = 0;
    }

    // Param is passed by value, moved
    pub fn set_MPLS3Label(&mut self, v: u32) {
        self.MPLS3Label = v;
    }

    // uint32 MPLSLastTTL = 61;


    pub fn get_MPLSLastTTL(&self) -> u32 {
        self.MPLSLastTTL
    }
    pub fn clear_MPLSLastTTL(&mut self) {
        self.MPLSLastTTL = 0;
    }

    // Param is passed by value, moved
    pub fn set_MPLSLastTTL(&mut self, v: u32) {
        self.MPLSLastTTL = v;
    }

    // uint32 MPLSLastLabel = 62;


    pub fn get_MPLSLastLabel(&self) -> u32 {
        self.MPLSLastLabel
    }
    pub fn clear_MPLSLastLabel(&mut self) {
        self.MPLSLastLabel = 0;
    }

    // Param is passed by value, moved
    pub fn set_MPLSLastLabel(&mut self, v: u32) {
        self.MPLSLastLabel = v;
    }

    // uint32 Cid = 1000;


    pub fn get_Cid(&self) -> u32 {
        self.Cid
    }
    pub fn clear_Cid(&mut self) {
        self.Cid = 0;
    }

    // Param is passed by value, moved
    pub fn set_Cid(&mut self, v: u32) {
        self.Cid = v;
    }

    // string CidString = 1001;


    pub fn get_CidString(&self) -> &str {
        &self.CidString
    }
    pub fn clear_CidString(&mut self) {
        self.CidString.clear();
    }

    // Param is passed by value, moved
    pub fn set_CidString(&mut self, v: ::std::string::String) {
        self.CidString = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_CidString(&mut self) -> &mut ::std::string::String {
        &mut self.CidString
    }

    // Take field
    pub fn take_CidString(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.CidString, ::std::string::String::new())
    }

    // .flowmessageenriched.FlowMessage.NormalizedType Normalized = 1002;


    pub fn get_Normalized(&self) -> FlowMessage_NormalizedType {
        self.Normalized
    }
    pub fn clear_Normalized(&mut self) {
        self.Normalized = FlowMessage_NormalizedType::No;
    }

    // Param is passed by value, moved
    pub fn set_Normalized(&mut self, v: FlowMessage_NormalizedType) {
        self.Normalized = v;
    }

    // string SrcIfName = 1003;


    pub fn get_SrcIfName(&self) -> &str {
        &self.SrcIfName
    }
    pub fn clear_SrcIfName(&mut self) {
        self.SrcIfName.clear();
    }

    // Param is passed by value, moved
    pub fn set_SrcIfName(&mut self, v: ::std::string::String) {
        self.SrcIfName = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_SrcIfName(&mut self) -> &mut ::std::string::String {
        &mut self.SrcIfName
    }

    // Take field
    pub fn take_SrcIfName(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.SrcIfName, ::std::string::String::new())
    }

    // string SrcIfDesc = 1004;


    pub fn get_SrcIfDesc(&self) -> &str {
        &self.SrcIfDesc
    }
    pub fn clear_SrcIfDesc(&mut self) {
        self.SrcIfDesc.clear();
    }

    // Param is passed by value, moved
    pub fn set_SrcIfDesc(&mut self, v: ::std::string::String) {
        self.SrcIfDesc = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_SrcIfDesc(&mut self) -> &mut ::std::string::String {
        &mut self.SrcIfDesc
    }

    // Take field
    pub fn take_SrcIfDesc(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.SrcIfDesc, ::std::string::String::new())
    }

    // uint32 SrcIfSpeed = 1005;


    pub fn get_SrcIfSpeed(&self) -> u32 {
        self.SrcIfSpeed
    }
    pub fn clear_SrcIfSpeed(&mut self) {
        self.SrcIfSpeed = 0;
    }

    // Param is passed by value, moved
    pub fn set_SrcIfSpeed(&mut self, v: u32) {
        self.SrcIfSpeed = v;
    }

    // string DstIfName = 1006;


    pub fn get_DstIfName(&self) -> &str {
        &self.DstIfName
    }
    pub fn clear_DstIfName(&mut self) {
        self.DstIfName.clear();
    }

    // Param is passed by value, moved
    pub fn set_DstIfName(&mut self, v: ::std::string::String) {
        self.DstIfName = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_DstIfName(&mut self) -> &mut ::std::string::String {
        &mut self.DstIfName
    }

    // Take field
    pub fn take_DstIfName(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.DstIfName, ::std::string::String::new())
    }

    // string DstIfDesc = 1007;


    pub fn get_DstIfDesc(&self) -> &str {
        &self.DstIfDesc
    }
    pub fn clear_DstIfDesc(&mut self) {
        self.DstIfDesc.clear();
    }

    // Param is passed by value, moved
    pub fn set_DstIfDesc(&mut self, v: ::std::string::String) {
        self.DstIfDesc = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_DstIfDesc(&mut self) -> &mut ::std::string::String {
        &mut self.DstIfDesc
    }

    // Take field
    pub fn take_DstIfDesc(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.DstIfDesc, ::std::string::String::new())
    }

    // uint32 DstIfSpeed = 1008;


    pub fn get_DstIfSpeed(&self) -> u32 {
        self.DstIfSpeed
    }
    pub fn clear_DstIfSpeed(&mut self) {
        self.DstIfSpeed = 0;
    }

    // Param is passed by value, moved
    pub fn set_DstIfSpeed(&mut self, v: u32) {
        self.DstIfSpeed = v;
    }

    // string ProtoName = 1009;


    pub fn get_ProtoName(&self) -> &str {
        &self.ProtoName
    }
    pub fn clear_ProtoName(&mut self) {
        self.ProtoName.clear();
    }

    // Param is passed by value, moved
    pub fn set_ProtoName(&mut self, v: ::std::string::String) {
        self.ProtoName = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_ProtoName(&mut self) -> &mut ::std::string::String {
        &mut self.ProtoName
    }

    // Take field
    pub fn take_ProtoName(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.ProtoName, ::std::string::String::new())
    }

    // string RemoteCountry = 1010;


    pub fn get_RemoteCountry(&self) -> &str {
        &self.RemoteCountry
    }
    pub fn clear_RemoteCountry(&mut self) {
        self.RemoteCountry.clear();
    }

    // Param is passed by value, moved
    pub fn set_RemoteCountry(&mut self, v: ::std::string::String) {
        self.RemoteCountry = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_RemoteCountry(&mut self) -> &mut ::std::string::String {
        &mut self.RemoteCountry
    }

    // Take field
    pub fn take_RemoteCountry(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.RemoteCountry, ::std::string::String::new())
    }

    // .flowmessageenriched.FlowMessage.RemoteAddrType RemoteAddr = 1011;


    pub fn get_RemoteAddr(&self) -> FlowMessage_RemoteAddrType {
        self.RemoteAddr
    }
    pub fn clear_RemoteAddr(&mut self) {
        self.RemoteAddr = FlowMessage_RemoteAddrType::Neither;
    }

    // Param is passed by value, moved
    pub fn set_RemoteAddr(&mut self, v: FlowMessage_RemoteAddrType) {
        self.RemoteAddr = v;
    }
}

impl ::protobuf::Message for FlowMessage {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.Type, 1, &mut self.unknown_fields)?
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.TimeReceived = tmp;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.SequenceNum = tmp;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.SamplingRate = tmp;
                },
                42 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.FlowDirection = tmp;
                },
                11 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.SamplerAddress)?;
                },
                38 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.TimeFlowStart = tmp;
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.TimeFlowEnd = tmp;
                },
                9 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.Bytes = tmp;
                },
                10 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.Packets = tmp;
                },
                6 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.SrcAddr)?;
                },
                7 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.DstAddr)?;
                },
                30 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.Etype = tmp;
                },
                20 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.Proto = tmp;
                },
                21 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.SrcPort = tmp;
                },
                22 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.DstPort = tmp;
                },
                18 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.InIf = tmp;
                },
                19 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.OutIf = tmp;
                },
                27 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.SrcMac = tmp;
                },
                28 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.DstMac = tmp;
                },
                33 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.SrcVlan = tmp;
                },
                34 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.DstVlan = tmp;
                },
                29 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.VlanId = tmp;
                },
                39 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.IngressVrfID = tmp;
                },
                40 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.EgressVrfID = tmp;
                },
                23 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.IPTos = tmp;
                },
                24 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.ForwardingStatus = tmp;
                },
                25 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.IPTTL = tmp;
                },
                26 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.TCPFlags = tmp;
                },
                31 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.IcmpType = tmp;
                },
                32 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.IcmpCode = tmp;
                },
                37 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.IPv6FlowLabel = tmp;
                },
                35 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.FragmentId = tmp;
                },
                36 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.FragmentOffset = tmp;
                },
                41 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.BiFlowDirection = tmp;
                },
                14 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.SrcAS = tmp;
                },
                15 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.DstAS = tmp;
                },
                12 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.NextHop)?;
                },
                13 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.NextHopAS = tmp;
                },
                16 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.SrcNet = tmp;
                },
                17 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.DstNet = tmp;
                },
                53 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.HasMPLS = tmp;
                },
                54 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.MPLSCount = tmp;
                },
                55 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.MPLS1TTL = tmp;
                },
                56 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.MPLS1Label = tmp;
                },
                57 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.MPLS2TTL = tmp;
                },
                58 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.MPLS2Label = tmp;
                },
                59 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.MPLS3TTL = tmp;
                },
                60 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.MPLS3Label = tmp;
                },
                61 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.MPLSLastTTL = tmp;
                },
                62 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.MPLSLastLabel = tmp;
                },
                1000 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.Cid = tmp;
                },
                1001 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.CidString)?;
                },
                1002 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.Normalized, 1002, &mut self.unknown_fields)?
                },
                1003 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.SrcIfName)?;
                },
                1004 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.SrcIfDesc)?;
                },
                1005 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.SrcIfSpeed = tmp;
                },
                1006 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.DstIfName)?;
                },
                1007 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.DstIfDesc)?;
                },
                1008 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.DstIfSpeed = tmp;
                },
                1009 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.ProtoName)?;
                },
                1010 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.RemoteCountry)?;
                },
                1011 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.RemoteAddr, 1011, &mut self.unknown_fields)?
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.Type != FlowMessage_FlowType::FLOWUNKNOWN {
            my_size += ::protobuf::rt::enum_size(1, self.Type);
        }
        if self.TimeReceived != 0 {
            my_size += ::protobuf::rt::value_size(2, self.TimeReceived, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.SequenceNum != 0 {
            my_size += ::protobuf::rt::value_size(4, self.SequenceNum, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.SamplingRate != 0 {
            my_size += ::protobuf::rt::value_size(3, self.SamplingRate, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.FlowDirection != 0 {
            my_size += ::protobuf::rt::value_size(42, self.FlowDirection, ::protobuf::wire_format::WireTypeVarint);
        }
        if !self.SamplerAddress.is_empty() {
            my_size += ::protobuf::rt::bytes_size(11, &self.SamplerAddress);
        }
        if self.TimeFlowStart != 0 {
            my_size += ::protobuf::rt::value_size(38, self.TimeFlowStart, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.TimeFlowEnd != 0 {
            my_size += ::protobuf::rt::value_size(5, self.TimeFlowEnd, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.Bytes != 0 {
            my_size += ::protobuf::rt::value_size(9, self.Bytes, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.Packets != 0 {
            my_size += ::protobuf::rt::value_size(10, self.Packets, ::protobuf::wire_format::WireTypeVarint);
        }
        if !self.SrcAddr.is_empty() {
            my_size += ::protobuf::rt::bytes_size(6, &self.SrcAddr);
        }
        if !self.DstAddr.is_empty() {
            my_size += ::protobuf::rt::bytes_size(7, &self.DstAddr);
        }
        if self.Etype != 0 {
            my_size += ::protobuf::rt::value_size(30, self.Etype, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.Proto != 0 {
            my_size += ::protobuf::rt::value_size(20, self.Proto, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.SrcPort != 0 {
            my_size += ::protobuf::rt::value_size(21, self.SrcPort, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.DstPort != 0 {
            my_size += ::protobuf::rt::value_size(22, self.DstPort, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.InIf != 0 {
            my_size += ::protobuf::rt::value_size(18, self.InIf, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.OutIf != 0 {
            my_size += ::protobuf::rt::value_size(19, self.OutIf, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.SrcMac != 0 {
            my_size += ::protobuf::rt::value_size(27, self.SrcMac, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.DstMac != 0 {
            my_size += ::protobuf::rt::value_size(28, self.DstMac, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.SrcVlan != 0 {
            my_size += ::protobuf::rt::value_size(33, self.SrcVlan, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.DstVlan != 0 {
            my_size += ::protobuf::rt::value_size(34, self.DstVlan, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.VlanId != 0 {
            my_size += ::protobuf::rt::value_size(29, self.VlanId, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.IngressVrfID != 0 {
            my_size += ::protobuf::rt::value_size(39, self.IngressVrfID, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.EgressVrfID != 0 {
            my_size += ::protobuf::rt::value_size(40, self.EgressVrfID, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.IPTos != 0 {
            my_size += ::protobuf::rt::value_size(23, self.IPTos, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.ForwardingStatus != 0 {
            my_size += ::protobuf::rt::value_size(24, self.ForwardingStatus, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.IPTTL != 0 {
            my_size += ::protobuf::rt::value_size(25, self.IPTTL, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.TCPFlags != 0 {
            my_size += ::protobuf::rt::value_size(26, self.TCPFlags, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.IcmpType != 0 {
            my_size += ::protobuf::rt::value_size(31, self.IcmpType, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.IcmpCode != 0 {
            my_size += ::protobuf::rt::value_size(32, self.IcmpCode, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.IPv6FlowLabel != 0 {
            my_size += ::protobuf::rt::value_size(37, self.IPv6FlowLabel, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.FragmentId != 0 {
            my_size += ::protobuf::rt::value_size(35, self.FragmentId, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.FragmentOffset != 0 {
            my_size += ::protobuf::rt::value_size(36, self.FragmentOffset, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.BiFlowDirection != 0 {
            my_size += ::protobuf::rt::value_size(41, self.BiFlowDirection, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.SrcAS != 0 {
            my_size += ::protobuf::rt::value_size(14, self.SrcAS, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.DstAS != 0 {
            my_size += ::protobuf::rt::value_size(15, self.DstAS, ::protobuf::wire_format::WireTypeVarint);
        }
        if !self.NextHop.is_empty() {
            my_size += ::protobuf::rt::bytes_size(12, &self.NextHop);
        }
        if self.NextHopAS != 0 {
            my_size += ::protobuf::rt::value_size(13, self.NextHopAS, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.SrcNet != 0 {
            my_size += ::protobuf::rt::value_size(16, self.SrcNet, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.DstNet != 0 {
            my_size += ::protobuf::rt::value_size(17, self.DstNet, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.HasMPLS != false {
            my_size += 3;
        }
        if self.MPLSCount != 0 {
            my_size += ::protobuf::rt::value_size(54, self.MPLSCount, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.MPLS1TTL != 0 {
            my_size += ::protobuf::rt::value_size(55, self.MPLS1TTL, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.MPLS1Label != 0 {
            my_size += ::protobuf::rt::value_size(56, self.MPLS1Label, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.MPLS2TTL != 0 {
            my_size += ::protobuf::rt::value_size(57, self.MPLS2TTL, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.MPLS2Label != 0 {
            my_size += ::protobuf::rt::value_size(58, self.MPLS2Label, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.MPLS3TTL != 0 {
            my_size += ::protobuf::rt::value_size(59, self.MPLS3TTL, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.MPLS3Label != 0 {
            my_size += ::protobuf::rt::value_size(60, self.MPLS3Label, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.MPLSLastTTL != 0 {
            my_size += ::protobuf::rt::value_size(61, self.MPLSLastTTL, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.MPLSLastLabel != 0 {
            my_size += ::protobuf::rt::value_size(62, self.MPLSLastLabel, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.Cid != 0 {
            my_size += ::protobuf::rt::value_size(1000, self.Cid, ::protobuf::wire_format::WireTypeVarint);
        }
        if !self.CidString.is_empty() {
            my_size += ::protobuf::rt::string_size(1001, &self.CidString);
        }
        if self.Normalized != FlowMessage_NormalizedType::No {
            my_size += ::protobuf::rt::enum_size(1002, self.Normalized);
        }
        if !self.SrcIfName.is_empty() {
            my_size += ::protobuf::rt::string_size(1003, &self.SrcIfName);
        }
        if !self.SrcIfDesc.is_empty() {
            my_size += ::protobuf::rt::string_size(1004, &self.SrcIfDesc);
        }
        if self.SrcIfSpeed != 0 {
            my_size += ::protobuf::rt::value_size(1005, self.SrcIfSpeed, ::protobuf::wire_format::WireTypeVarint);
        }
        if !self.DstIfName.is_empty() {
            my_size += ::protobuf::rt::string_size(1006, &self.DstIfName);
        }
        if !self.DstIfDesc.is_empty() {
            my_size += ::protobuf::rt::string_size(1007, &self.DstIfDesc);
        }
        if self.DstIfSpeed != 0 {
            my_size += ::protobuf::rt::value_size(1008, self.DstIfSpeed, ::protobuf::wire_format::WireTypeVarint);
        }
        if !self.ProtoName.is_empty() {
            my_size += ::protobuf::rt::string_size(1009, &self.ProtoName);
        }
        if !self.RemoteCountry.is_empty() {
            my_size += ::protobuf::rt::string_size(1010, &self.RemoteCountry);
        }
        if self.RemoteAddr != FlowMessage_RemoteAddrType::Neither {
            my_size += ::protobuf::rt::enum_size(1011, self.RemoteAddr);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.Type != FlowMessage_FlowType::FLOWUNKNOWN {
            os.write_enum(1, ::protobuf::ProtobufEnum::value(&self.Type))?;
        }
        if self.TimeReceived != 0 {
            os.write_uint64(2, self.TimeReceived)?;
        }
        if self.SequenceNum != 0 {
            os.write_uint32(4, self.SequenceNum)?;
        }
        if self.SamplingRate != 0 {
            os.write_uint64(3, self.SamplingRate)?;
        }
        if self.FlowDirection != 0 {
            os.write_uint32(42, self.FlowDirection)?;
        }
        if !self.SamplerAddress.is_empty() {
            os.write_bytes(11, &self.SamplerAddress)?;
        }
        if self.TimeFlowStart != 0 {
            os.write_uint64(38, self.TimeFlowStart)?;
        }
        if self.TimeFlowEnd != 0 {
            os.write_uint64(5, self.TimeFlowEnd)?;
        }
        if self.Bytes != 0 {
            os.write_uint64(9, self.Bytes)?;
        }
        if self.Packets != 0 {
            os.write_uint64(10, self.Packets)?;
        }
        if !self.SrcAddr.is_empty() {
            os.write_bytes(6, &self.SrcAddr)?;
        }
        if !self.DstAddr.is_empty() {
            os.write_bytes(7, &self.DstAddr)?;
        }
        if self.Etype != 0 {
            os.write_uint32(30, self.Etype)?;
        }
        if self.Proto != 0 {
            os.write_uint32(20, self.Proto)?;
        }
        if self.SrcPort != 0 {
            os.write_uint32(21, self.SrcPort)?;
        }
        if self.DstPort != 0 {
            os.write_uint32(22, self.DstPort)?;
        }
        if self.InIf != 0 {
            os.write_uint32(18, self.InIf)?;
        }
        if self.OutIf != 0 {
            os.write_uint32(19, self.OutIf)?;
        }
        if self.SrcMac != 0 {
            os.write_uint64(27, self.SrcMac)?;
        }
        if self.DstMac != 0 {
            os.write_uint64(28, self.DstMac)?;
        }
        if self.SrcVlan != 0 {
            os.write_uint32(33, self.SrcVlan)?;
        }
        if self.DstVlan != 0 {
            os.write_uint32(34, self.DstVlan)?;
        }
        if self.VlanId != 0 {
            os.write_uint32(29, self.VlanId)?;
        }
        if self.IngressVrfID != 0 {
            os.write_uint32(39, self.IngressVrfID)?;
        }
        if self.EgressVrfID != 0 {
            os.write_uint32(40, self.EgressVrfID)?;
        }
        if self.IPTos != 0 {
            os.write_uint32(23, self.IPTos)?;
        }
        if self.ForwardingStatus != 0 {
            os.write_uint32(24, self.ForwardingStatus)?;
        }
        if self.IPTTL != 0 {
            os.write_uint32(25, self.IPTTL)?;
        }
        if self.TCPFlags != 0 {
            os.write_uint32(26, self.TCPFlags)?;
        }
        if self.IcmpType != 0 {
            os.write_uint32(31, self.IcmpType)?;
        }
        if self.IcmpCode != 0 {
            os.write_uint32(32, self.IcmpCode)?;
        }
        if self.IPv6FlowLabel != 0 {
            os.write_uint32(37, self.IPv6FlowLabel)?;
        }
        if self.FragmentId != 0 {
            os.write_uint32(35, self.FragmentId)?;
        }
        if self.FragmentOffset != 0 {
            os.write_uint32(36, self.FragmentOffset)?;
        }
        if self.BiFlowDirection != 0 {
            os.write_uint32(41, self.BiFlowDirection)?;
        }
        if self.SrcAS != 0 {
            os.write_uint32(14, self.SrcAS)?;
        }
        if self.DstAS != 0 {
            os.write_uint32(15, self.DstAS)?;
        }
        if !self.NextHop.is_empty() {
            os.write_bytes(12, &self.NextHop)?;
        }
        if self.NextHopAS != 0 {
            os.write_uint32(13, self.NextHopAS)?;
        }
        if self.SrcNet != 0 {
            os.write_uint32(16, self.SrcNet)?;
        }
        if self.DstNet != 0 {
            os.write_uint32(17, self.DstNet)?;
        }
        if self.HasMPLS != false {
            os.write_bool(53, self.HasMPLS)?;
        }
        if self.MPLSCount != 0 {
            os.write_uint32(54, self.MPLSCount)?;
        }
        if self.MPLS1TTL != 0 {
            os.write_uint32(55, self.MPLS1TTL)?;
        }
        if self.MPLS1Label != 0 {
            os.write_uint32(56, self.MPLS1Label)?;
        }
        if self.MPLS2TTL != 0 {
            os.write_uint32(57, self.MPLS2TTL)?;
        }
        if self.MPLS2Label != 0 {
            os.write_uint32(58, self.MPLS2Label)?;
        }
        if self.MPLS3TTL != 0 {
            os.write_uint32(59, self.MPLS3TTL)?;
        }
        if self.MPLS3Label != 0 {
            os.write_uint32(60, self.MPLS3Label)?;
        }
        if self.MPLSLastTTL != 0 {
            os.write_uint32(61, self.MPLSLastTTL)?;
        }
        if self.MPLSLastLabel != 0 {
            os.write_uint32(62, self.MPLSLastLabel)?;
        }
        if self.Cid != 0 {
            os.write_uint32(1000, self.Cid)?;
        }
        if !self.CidString.is_empty() {
            os.write_string(1001, &self.CidString)?;
        }
        if self.Normalized != FlowMessage_NormalizedType::No {
            os.write_enum(1002, ::protobuf::ProtobufEnum::value(&self.Normalized))?;
        }
        if !self.SrcIfName.is_empty() {
            os.write_string(1003, &self.SrcIfName)?;
        }
        if !self.SrcIfDesc.is_empty() {
            os.write_string(1004, &self.SrcIfDesc)?;
        }
        if self.SrcIfSpeed != 0 {
            os.write_uint32(1005, self.SrcIfSpeed)?;
        }
        if !self.DstIfName.is_empty() {
            os.write_string(1006, &self.DstIfName)?;
        }
        if !self.DstIfDesc.is_empty() {
            os.write_string(1007, &self.DstIfDesc)?;
        }
        if self.DstIfSpeed != 0 {
            os.write_uint32(1008, self.DstIfSpeed)?;
        }
        if !self.ProtoName.is_empty() {
            os.write_string(1009, &self.ProtoName)?;
        }
        if !self.RemoteCountry.is_empty() {
            os.write_string(1010, &self.RemoteCountry)?;
        }
        if self.RemoteAddr != FlowMessage_RemoteAddrType::Neither {
            os.write_enum(1011, ::protobuf::ProtobufEnum::value(&self.RemoteAddr))?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> FlowMessage {
        FlowMessage::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<FlowMessage_FlowType>>(
                "Type",
                |m: &FlowMessage| { &m.Type },
                |m: &mut FlowMessage| { &mut m.Type },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "TimeReceived",
                |m: &FlowMessage| { &m.TimeReceived },
                |m: &mut FlowMessage| { &mut m.TimeReceived },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "SequenceNum",
                |m: &FlowMessage| { &m.SequenceNum },
                |m: &mut FlowMessage| { &mut m.SequenceNum },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "SamplingRate",
                |m: &FlowMessage| { &m.SamplingRate },
                |m: &mut FlowMessage| { &mut m.SamplingRate },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "FlowDirection",
                |m: &FlowMessage| { &m.FlowDirection },
                |m: &mut FlowMessage| { &mut m.FlowDirection },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "SamplerAddress",
                |m: &FlowMessage| { &m.SamplerAddress },
                |m: &mut FlowMessage| { &mut m.SamplerAddress },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "TimeFlowStart",
                |m: &FlowMessage| { &m.TimeFlowStart },
                |m: &mut FlowMessage| { &mut m.TimeFlowStart },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "TimeFlowEnd",
                |m: &FlowMessage| { &m.TimeFlowEnd },
                |m: &mut FlowMessage| { &mut m.TimeFlowEnd },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "Bytes",
                |m: &FlowMessage| { &m.Bytes },
                |m: &mut FlowMessage| { &mut m.Bytes },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "Packets",
                |m: &FlowMessage| { &m.Packets },
                |m: &mut FlowMessage| { &mut m.Packets },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "SrcAddr",
                |m: &FlowMessage| { &m.SrcAddr },
                |m: &mut FlowMessage| { &mut m.SrcAddr },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "DstAddr",
                |m: &FlowMessage| { &m.DstAddr },
                |m: &mut FlowMessage| { &mut m.DstAddr },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "Etype",
                |m: &FlowMessage| { &m.Etype },
                |m: &mut FlowMessage| { &mut m.Etype },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "Proto",
                |m: &FlowMessage| { &m.Proto },
                |m: &mut FlowMessage| { &mut m.Proto },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "SrcPort",
                |m: &FlowMessage| { &m.SrcPort },
                |m: &mut FlowMessage| { &mut m.SrcPort },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "DstPort",
                |m: &FlowMessage| { &m.DstPort },
                |m: &mut FlowMessage| { &mut m.DstPort },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "InIf",
                |m: &FlowMessage| { &m.InIf },
                |m: &mut FlowMessage| { &mut m.InIf },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "OutIf",
                |m: &FlowMessage| { &m.OutIf },
                |m: &mut FlowMessage| { &mut m.OutIf },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "SrcMac",
                |m: &FlowMessage| { &m.SrcMac },
                |m: &mut FlowMessage| { &mut m.SrcMac },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "DstMac",
                |m: &FlowMessage| { &m.DstMac },
                |m: &mut FlowMessage| { &mut m.DstMac },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "SrcVlan",
                |m: &FlowMessage| { &m.SrcVlan },
                |m: &mut FlowMessage| { &mut m.SrcVlan },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "DstVlan",
                |m: &FlowMessage| { &m.DstVlan },
                |m: &mut FlowMessage| { &mut m.DstVlan },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "VlanId",
                |m: &FlowMessage| { &m.VlanId },
                |m: &mut FlowMessage| { &mut m.VlanId },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "IngressVrfID",
                |m: &FlowMessage| { &m.IngressVrfID },
                |m: &mut FlowMessage| { &mut m.IngressVrfID },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "EgressVrfID",
                |m: &FlowMessage| { &m.EgressVrfID },
                |m: &mut FlowMessage| { &mut m.EgressVrfID },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "IPTos",
                |m: &FlowMessage| { &m.IPTos },
                |m: &mut FlowMessage| { &mut m.IPTos },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "ForwardingStatus",
                |m: &FlowMessage| { &m.ForwardingStatus },
                |m: &mut FlowMessage| { &mut m.ForwardingStatus },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "IPTTL",
                |m: &FlowMessage| { &m.IPTTL },
                |m: &mut FlowMessage| { &mut m.IPTTL },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "TCPFlags",
                |m: &FlowMessage| { &m.TCPFlags },
                |m: &mut FlowMessage| { &mut m.TCPFlags },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "IcmpType",
                |m: &FlowMessage| { &m.IcmpType },
                |m: &mut FlowMessage| { &mut m.IcmpType },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "IcmpCode",
                |m: &FlowMessage| { &m.IcmpCode },
                |m: &mut FlowMessage| { &mut m.IcmpCode },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "IPv6FlowLabel",
                |m: &FlowMessage| { &m.IPv6FlowLabel },
                |m: &mut FlowMessage| { &mut m.IPv6FlowLabel },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "FragmentId",
                |m: &FlowMessage| { &m.FragmentId },
                |m: &mut FlowMessage| { &mut m.FragmentId },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "FragmentOffset",
                |m: &FlowMessage| { &m.FragmentOffset },
                |m: &mut FlowMessage| { &mut m.FragmentOffset },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "BiFlowDirection",
                |m: &FlowMessage| { &m.BiFlowDirection },
                |m: &mut FlowMessage| { &mut m.BiFlowDirection },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "SrcAS",
                |m: &FlowMessage| { &m.SrcAS },
                |m: &mut FlowMessage| { &mut m.SrcAS },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "DstAS",
                |m: &FlowMessage| { &m.DstAS },
                |m: &mut FlowMessage| { &mut m.DstAS },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "NextHop",
                |m: &FlowMessage| { &m.NextHop },
                |m: &mut FlowMessage| { &mut m.NextHop },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "NextHopAS",
                |m: &FlowMessage| { &m.NextHopAS },
                |m: &mut FlowMessage| { &mut m.NextHopAS },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "SrcNet",
                |m: &FlowMessage| { &m.SrcNet },
                |m: &mut FlowMessage| { &mut m.SrcNet },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "DstNet",
                |m: &FlowMessage| { &m.DstNet },
                |m: &mut FlowMessage| { &mut m.DstNet },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "HasMPLS",
                |m: &FlowMessage| { &m.HasMPLS },
                |m: &mut FlowMessage| { &mut m.HasMPLS },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "MPLSCount",
                |m: &FlowMessage| { &m.MPLSCount },
                |m: &mut FlowMessage| { &mut m.MPLSCount },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "MPLS1TTL",
                |m: &FlowMessage| { &m.MPLS1TTL },
                |m: &mut FlowMessage| { &mut m.MPLS1TTL },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "MPLS1Label",
                |m: &FlowMessage| { &m.MPLS1Label },
                |m: &mut FlowMessage| { &mut m.MPLS1Label },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "MPLS2TTL",
                |m: &FlowMessage| { &m.MPLS2TTL },
                |m: &mut FlowMessage| { &mut m.MPLS2TTL },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "MPLS2Label",
                |m: &FlowMessage| { &m.MPLS2Label },
                |m: &mut FlowMessage| { &mut m.MPLS2Label },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "MPLS3TTL",
                |m: &FlowMessage| { &m.MPLS3TTL },
                |m: &mut FlowMessage| { &mut m.MPLS3TTL },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "MPLS3Label",
                |m: &FlowMessage| { &m.MPLS3Label },
                |m: &mut FlowMessage| { &mut m.MPLS3Label },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "MPLSLastTTL",
                |m: &FlowMessage| { &m.MPLSLastTTL },
                |m: &mut FlowMessage| { &mut m.MPLSLastTTL },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "MPLSLastLabel",
                |m: &FlowMessage| { &m.MPLSLastLabel },
                |m: &mut FlowMessage| { &mut m.MPLSLastLabel },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "Cid",
                |m: &FlowMessage| { &m.Cid },
                |m: &mut FlowMessage| { &mut m.Cid },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "CidString",
                |m: &FlowMessage| { &m.CidString },
                |m: &mut FlowMessage| { &mut m.CidString },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<FlowMessage_NormalizedType>>(
                "Normalized",
                |m: &FlowMessage| { &m.Normalized },
                |m: &mut FlowMessage| { &mut m.Normalized },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "SrcIfName",
                |m: &FlowMessage| { &m.SrcIfName },
                |m: &mut FlowMessage| { &mut m.SrcIfName },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "SrcIfDesc",
                |m: &FlowMessage| { &m.SrcIfDesc },
                |m: &mut FlowMessage| { &mut m.SrcIfDesc },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "SrcIfSpeed",
                |m: &FlowMessage| { &m.SrcIfSpeed },
                |m: &mut FlowMessage| { &mut m.SrcIfSpeed },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "DstIfName",
                |m: &FlowMessage| { &m.DstIfName },
                |m: &mut FlowMessage| { &mut m.DstIfName },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "DstIfDesc",
                |m: &FlowMessage| { &m.DstIfDesc },
                |m: &mut FlowMessage| { &mut m.DstIfDesc },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "DstIfSpeed",
                |m: &FlowMessage| { &m.DstIfSpeed },
                |m: &mut FlowMessage| { &mut m.DstIfSpeed },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "ProtoName",
                |m: &FlowMessage| { &m.ProtoName },
                |m: &mut FlowMessage| { &mut m.ProtoName },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "RemoteCountry",
                |m: &FlowMessage| { &m.RemoteCountry },
                |m: &mut FlowMessage| { &mut m.RemoteCountry },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<FlowMessage_RemoteAddrType>>(
                "RemoteAddr",
                |m: &FlowMessage| { &m.RemoteAddr },
                |m: &mut FlowMessage| { &mut m.RemoteAddr },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<FlowMessage>(
                "FlowMessage",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static FlowMessage {
        static instance: ::protobuf::rt::LazyV2<FlowMessage> = ::protobuf::rt::LazyV2::INIT;
        instance.get(FlowMessage::new)
    }
}

impl ::protobuf::Clear for FlowMessage {
    fn clear(&mut self) {
        self.Type = FlowMessage_FlowType::FLOWUNKNOWN;
        self.TimeReceived = 0;
        self.SequenceNum = 0;
        self.SamplingRate = 0;
        self.FlowDirection = 0;
        self.SamplerAddress.clear();
        self.TimeFlowStart = 0;
        self.TimeFlowEnd = 0;
        self.Bytes = 0;
        self.Packets = 0;
        self.SrcAddr.clear();
        self.DstAddr.clear();
        self.Etype = 0;
        self.Proto = 0;
        self.SrcPort = 0;
        self.DstPort = 0;
        self.InIf = 0;
        self.OutIf = 0;
        self.SrcMac = 0;
        self.DstMac = 0;
        self.SrcVlan = 0;
        self.DstVlan = 0;
        self.VlanId = 0;
        self.IngressVrfID = 0;
        self.EgressVrfID = 0;
        self.IPTos = 0;
        self.ForwardingStatus = 0;
        self.IPTTL = 0;
        self.TCPFlags = 0;
        self.IcmpType = 0;
        self.IcmpCode = 0;
        self.IPv6FlowLabel = 0;
        self.FragmentId = 0;
        self.FragmentOffset = 0;
        self.BiFlowDirection = 0;
        self.SrcAS = 0;
        self.DstAS = 0;
        self.NextHop.clear();
        self.NextHopAS = 0;
        self.SrcNet = 0;
        self.DstNet = 0;
        self.HasMPLS = false;
        self.MPLSCount = 0;
        self.MPLS1TTL = 0;
        self.MPLS1Label = 0;
        self.MPLS2TTL = 0;
        self.MPLS2Label = 0;
        self.MPLS3TTL = 0;
        self.MPLS3Label = 0;
        self.MPLSLastTTL = 0;
        self.MPLSLastLabel = 0;
        self.Cid = 0;
        self.CidString.clear();
        self.Normalized = FlowMessage_NormalizedType::No;
        self.SrcIfName.clear();
        self.SrcIfDesc.clear();
        self.SrcIfSpeed = 0;
        self.DstIfName.clear();
        self.DstIfDesc.clear();
        self.DstIfSpeed = 0;
        self.ProtoName.clear();
        self.RemoteCountry.clear();
        self.RemoteAddr = FlowMessage_RemoteAddrType::Neither;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for FlowMessage {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for FlowMessage {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum FlowMessage_FlowType {
    FLOWUNKNOWN = 0,
    SFLOW_5 = 1,
    NETFLOW_V5 = 2,
    NETFLOW_V9 = 3,
    IPFIX = 4,
}

impl ::protobuf::ProtobufEnum for FlowMessage_FlowType {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<FlowMessage_FlowType> {
        match value {
            0 => ::std::option::Option::Some(FlowMessage_FlowType::FLOWUNKNOWN),
            1 => ::std::option::Option::Some(FlowMessage_FlowType::SFLOW_5),
            2 => ::std::option::Option::Some(FlowMessage_FlowType::NETFLOW_V5),
            3 => ::std::option::Option::Some(FlowMessage_FlowType::NETFLOW_V9),
            4 => ::std::option::Option::Some(FlowMessage_FlowType::IPFIX),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [FlowMessage_FlowType] = &[
            FlowMessage_FlowType::FLOWUNKNOWN,
            FlowMessage_FlowType::SFLOW_5,
            FlowMessage_FlowType::NETFLOW_V5,
            FlowMessage_FlowType::NETFLOW_V9,
            FlowMessage_FlowType::IPFIX,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            ::protobuf::reflect::EnumDescriptor::new_pb_name::<FlowMessage_FlowType>("FlowMessage.FlowType", file_descriptor_proto())
        })
    }
}

impl ::std::marker::Copy for FlowMessage_FlowType {
}

impl ::std::default::Default for FlowMessage_FlowType {
    fn default() -> Self {
        FlowMessage_FlowType::FLOWUNKNOWN
    }
}

impl ::protobuf::reflect::ProtobufValue for FlowMessage_FlowType {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Enum(::protobuf::ProtobufEnum::descriptor(self))
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum FlowMessage_NormalizedType {
    No = 0,
    Yes = 1,
}

impl ::protobuf::ProtobufEnum for FlowMessage_NormalizedType {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<FlowMessage_NormalizedType> {
        match value {
            0 => ::std::option::Option::Some(FlowMessage_NormalizedType::No),
            1 => ::std::option::Option::Some(FlowMessage_NormalizedType::Yes),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [FlowMessage_NormalizedType] = &[
            FlowMessage_NormalizedType::No,
            FlowMessage_NormalizedType::Yes,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            ::protobuf::reflect::EnumDescriptor::new_pb_name::<FlowMessage_NormalizedType>("FlowMessage.NormalizedType", file_descriptor_proto())
        })
    }
}

impl ::std::marker::Copy for FlowMessage_NormalizedType {
}

impl ::std::default::Default for FlowMessage_NormalizedType {
    fn default() -> Self {
        FlowMessage_NormalizedType::No
    }
}

impl ::protobuf::reflect::ProtobufValue for FlowMessage_NormalizedType {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Enum(::protobuf::ProtobufEnum::descriptor(self))
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum FlowMessage_RemoteAddrType {
    Neither = 0,
    Src = 1,
    Dst = 2,
}

impl ::protobuf::ProtobufEnum for FlowMessage_RemoteAddrType {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<FlowMessage_RemoteAddrType> {
        match value {
            0 => ::std::option::Option::Some(FlowMessage_RemoteAddrType::Neither),
            1 => ::std::option::Option::Some(FlowMessage_RemoteAddrType::Src),
            2 => ::std::option::Option::Some(FlowMessage_RemoteAddrType::Dst),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [FlowMessage_RemoteAddrType] = &[
            FlowMessage_RemoteAddrType::Neither,
            FlowMessage_RemoteAddrType::Src,
            FlowMessage_RemoteAddrType::Dst,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            ::protobuf::reflect::EnumDescriptor::new_pb_name::<FlowMessage_RemoteAddrType>("FlowMessage.RemoteAddrType", file_descriptor_proto())
        })
    }
}

impl ::std::marker::Copy for FlowMessage_RemoteAddrType {
}

impl ::std::default::Default for FlowMessage_RemoteAddrType {
    fn default() -> Self {
        FlowMessage_RemoteAddrType::Neither
    }
}

impl ::protobuf::reflect::ProtobufValue for FlowMessage_RemoteAddrType {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Enum(::protobuf::ProtobufEnum::descriptor(self))
    }
}

static file_descriptor_proto_data: &'static [u8] = b"\
    \n\x1cflow-messages-enriched.proto\x12\x13flowmessageenriched\"\x8b\x11\
    \n\x0bFlowMessage\x12=\n\x04Type\x18\x01\x20\x01(\x0e2).flowmessageenric\
    hed.FlowMessage.FlowTypeR\x04Type\x12\"\n\x0cTimeReceived\x18\x02\x20\
    \x01(\x04R\x0cTimeReceived\x12\x20\n\x0bSequenceNum\x18\x04\x20\x01(\rR\
    \x0bSequenceNum\x12\"\n\x0cSamplingRate\x18\x03\x20\x01(\x04R\x0cSamplin\
    gRate\x12$\n\rFlowDirection\x18*\x20\x01(\rR\rFlowDirection\x12&\n\x0eSa\
    mplerAddress\x18\x0b\x20\x01(\x0cR\x0eSamplerAddress\x12$\n\rTimeFlowSta\
    rt\x18&\x20\x01(\x04R\rTimeFlowStart\x12\x20\n\x0bTimeFlowEnd\x18\x05\
    \x20\x01(\x04R\x0bTimeFlowEnd\x12\x14\n\x05Bytes\x18\t\x20\x01(\x04R\x05\
    Bytes\x12\x18\n\x07Packets\x18\n\x20\x01(\x04R\x07Packets\x12\x18\n\x07S\
    rcAddr\x18\x06\x20\x01(\x0cR\x07SrcAddr\x12\x18\n\x07DstAddr\x18\x07\x20\
    \x01(\x0cR\x07DstAddr\x12\x14\n\x05Etype\x18\x1e\x20\x01(\rR\x05Etype\
    \x12\x14\n\x05Proto\x18\x14\x20\x01(\rR\x05Proto\x12\x18\n\x07SrcPort\
    \x18\x15\x20\x01(\rR\x07SrcPort\x12\x18\n\x07DstPort\x18\x16\x20\x01(\rR\
    \x07DstPort\x12\x12\n\x04InIf\x18\x12\x20\x01(\rR\x04InIf\x12\x14\n\x05O\
    utIf\x18\x13\x20\x01(\rR\x05OutIf\x12\x16\n\x06SrcMac\x18\x1b\x20\x01(\
    \x04R\x06SrcMac\x12\x16\n\x06DstMac\x18\x1c\x20\x01(\x04R\x06DstMac\x12\
    \x18\n\x07SrcVlan\x18!\x20\x01(\rR\x07SrcVlan\x12\x18\n\x07DstVlan\x18\"\
    \x20\x01(\rR\x07DstVlan\x12\x16\n\x06VlanId\x18\x1d\x20\x01(\rR\x06VlanI\
    d\x12\"\n\x0cIngressVrfID\x18'\x20\x01(\rR\x0cIngressVrfID\x12\x20\n\x0b\
    EgressVrfID\x18(\x20\x01(\rR\x0bEgressVrfID\x12\x14\n\x05IPTos\x18\x17\
    \x20\x01(\rR\x05IPTos\x12*\n\x10ForwardingStatus\x18\x18\x20\x01(\rR\x10\
    ForwardingStatus\x12\x14\n\x05IPTTL\x18\x19\x20\x01(\rR\x05IPTTL\x12\x1a\
    \n\x08TCPFlags\x18\x1a\x20\x01(\rR\x08TCPFlags\x12\x1a\n\x08IcmpType\x18\
    \x1f\x20\x01(\rR\x08IcmpType\x12\x1a\n\x08IcmpCode\x18\x20\x20\x01(\rR\
    \x08IcmpCode\x12$\n\rIPv6FlowLabel\x18%\x20\x01(\rR\rIPv6FlowLabel\x12\
    \x1e\n\nFragmentId\x18#\x20\x01(\rR\nFragmentId\x12&\n\x0eFragmentOffset\
    \x18$\x20\x01(\rR\x0eFragmentOffset\x12(\n\x0fBiFlowDirection\x18)\x20\
    \x01(\rR\x0fBiFlowDirection\x12\x14\n\x05SrcAS\x18\x0e\x20\x01(\rR\x05Sr\
    cAS\x12\x14\n\x05DstAS\x18\x0f\x20\x01(\rR\x05DstAS\x12\x18\n\x07NextHop\
    \x18\x0c\x20\x01(\x0cR\x07NextHop\x12\x1c\n\tNextHopAS\x18\r\x20\x01(\rR\
    \tNextHopAS\x12\x16\n\x06SrcNet\x18\x10\x20\x01(\rR\x06SrcNet\x12\x16\n\
    \x06DstNet\x18\x11\x20\x01(\rR\x06DstNet\x12\x18\n\x07HasMPLS\x185\x20\
    \x01(\x08R\x07HasMPLS\x12\x1c\n\tMPLSCount\x186\x20\x01(\rR\tMPLSCount\
    \x12\x1a\n\x08MPLS1TTL\x187\x20\x01(\rR\x08MPLS1TTL\x12\x1e\n\nMPLS1Labe\
    l\x188\x20\x01(\rR\nMPLS1Label\x12\x1a\n\x08MPLS2TTL\x189\x20\x01(\rR\
    \x08MPLS2TTL\x12\x1e\n\nMPLS2Label\x18:\x20\x01(\rR\nMPLS2Label\x12\x1a\
    \n\x08MPLS3TTL\x18;\x20\x01(\rR\x08MPLS3TTL\x12\x1e\n\nMPLS3Label\x18<\
    \x20\x01(\rR\nMPLS3Label\x12\x20\n\x0bMPLSLastTTL\x18=\x20\x01(\rR\x0bMP\
    LSLastTTL\x12$\n\rMPLSLastLabel\x18>\x20\x01(\rR\rMPLSLastLabel\x12\x11\
    \n\x03Cid\x18\xe8\x07\x20\x01(\rR\x03Cid\x12\x1d\n\tCidString\x18\xe9\
    \x07\x20\x01(\tR\tCidString\x12P\n\nNormalized\x18\xea\x07\x20\x01(\x0e2\
    /.flowmessageenriched.FlowMessage.NormalizedTypeR\nNormalized\x12\x1d\n\
    \tSrcIfName\x18\xeb\x07\x20\x01(\tR\tSrcIfName\x12\x1d\n\tSrcIfDesc\x18\
    \xec\x07\x20\x01(\tR\tSrcIfDesc\x12\x1f\n\nSrcIfSpeed\x18\xed\x07\x20\
    \x01(\rR\nSrcIfSpeed\x12\x1d\n\tDstIfName\x18\xee\x07\x20\x01(\tR\tDstIf\
    Name\x12\x1d\n\tDstIfDesc\x18\xef\x07\x20\x01(\tR\tDstIfDesc\x12\x1f\n\n\
    DstIfSpeed\x18\xf0\x07\x20\x01(\rR\nDstIfSpeed\x12\x1d\n\tProtoName\x18\
    \xf1\x07\x20\x01(\tR\tProtoName\x12%\n\rRemoteCountry\x18\xf2\x07\x20\
    \x01(\tR\rRemoteCountry\x12P\n\nRemoteAddr\x18\xf3\x07\x20\x01(\x0e2/.fl\
    owmessageenriched.FlowMessage.RemoteAddrTypeR\nRemoteAddr\"S\n\x08FlowTy\
    pe\x12\x0f\n\x0bFLOWUNKNOWN\x10\0\x12\x0b\n\x07SFLOW_5\x10\x01\x12\x0e\n\
    \nNETFLOW_V5\x10\x02\x12\x0e\n\nNETFLOW_V9\x10\x03\x12\t\n\x05IPFIX\x10\
    \x04\"!\n\x0eNormalizedType\x12\x06\n\x02No\x10\0\x12\x07\n\x03Yes\x10\
    \x01\"/\n\x0eRemoteAddrType\x12\x0b\n\x07Neither\x10\0\x12\x07\n\x03Src\
    \x10\x01\x12\x07\n\x03Dst\x10\x02BX\n\tbwnetflowB\x15FlowMessageEnriched\
    PbZ4github.com/bwNetFlow/protobuf/go;flowmessageenrichedJ\xa8)\n\x07\x12\
    \x05\0\0\x83\x01\x01\n\x08\n\x01\x0c\x12\x03\0\0\x12\n\x08\n\x01\x02\x12\
    \x03\x01\0\x1c\n\x08\n\x01\x08\x12\x03\x02\0\"\n\t\n\x02\x08\x01\x12\x03\
    \x02\0\"\n\x08\n\x01\x08\x12\x03\x03\06\n\t\n\x02\x08\x08\x12\x03\x03\06\
    \n\x08\n\x01\x08\x12\x03\x04\0K\n\t\n\x02\x08\x0b\x12\x03\x04\0K\n\x0b\n\
    \x02\x04\0\x12\x05\x06\0\x83\x01\x01\n\n\n\x03\x04\0\x01\x12\x03\x06\x08\
    \x13\n\x0c\n\x04\x04\0\x04\0\x12\x04\x07\x02\r\x03\n\x0c\n\x05\x04\0\x04\
    \0\x01\x12\x03\x07\x07\x0f\n\r\n\x06\x04\0\x04\0\x02\0\x12\x03\x08\x04\
    \x14\n\x0e\n\x07\x04\0\x04\0\x02\0\x01\x12\x03\x08\x04\x0f\n\x0e\n\x07\
    \x04\0\x04\0\x02\0\x02\x12\x03\x08\x12\x13\n\r\n\x06\x04\0\x04\0\x02\x01\
    \x12\x03\t\x04\x10\n\x0e\n\x07\x04\0\x04\0\x02\x01\x01\x12\x03\t\x04\x0b\
    \n\x0e\n\x07\x04\0\x04\0\x02\x01\x02\x12\x03\t\x0e\x0f\n\r\n\x06\x04\0\
    \x04\0\x02\x02\x12\x03\n\x04\x13\n\x0e\n\x07\x04\0\x04\0\x02\x02\x01\x12\
    \x03\n\x04\x0e\n\x0e\n\x07\x04\0\x04\0\x02\x02\x02\x12\x03\n\x11\x12\n\r\
    \n\x06\x04\0\x04\0\x02\x03\x12\x03\x0b\x04\x13\n\x0e\n\x07\x04\0\x04\0\
    \x02\x03\x01\x12\x03\x0b\x04\x0e\n\x0e\n\x07\x04\0\x04\0\x02\x03\x02\x12\
    \x03\x0b\x11\x12\n\r\n\x06\x04\0\x04\0\x02\x04\x12\x03\x0c\x04\x0e\n\x0e\
    \n\x07\x04\0\x04\0\x02\x04\x01\x12\x03\x0c\x04\t\n\x0e\n\x07\x04\0\x04\0\
    \x02\x04\x02\x12\x03\x0c\x0c\r\n\x0b\n\x04\x04\0\x02\0\x12\x03\x0e\x02\
    \x14\n\x0c\n\x05\x04\0\x02\0\x06\x12\x03\x0e\x02\n\n\x0c\n\x05\x04\0\x02\
    \0\x01\x12\x03\x0e\x0b\x0f\n\x0c\n\x05\x04\0\x02\0\x03\x12\x03\x0e\x12\
    \x13\n\x0b\n\x04\x04\0\x02\x01\x12\x03\x10\x02\x1a\n\x0c\n\x05\x04\0\x02\
    \x01\x05\x12\x03\x10\x02\x08\n\x0c\n\x05\x04\0\x02\x01\x01\x12\x03\x10\t\
    \x15\n\x0c\n\x05\x04\0\x02\x01\x03\x12\x03\x10\x18\x19\n\x0b\n\x04\x04\0\
    \x02\x02\x12\x03\x11\x02\x19\n\x0c\n\x05\x04\0\x02\x02\x05\x12\x03\x11\
    \x02\x08\n\x0c\n\x05\x04\0\x02\x02\x01\x12\x03\x11\t\x14\n\x0c\n\x05\x04\
    \0\x02\x02\x03\x12\x03\x11\x17\x18\n\x0b\n\x04\x04\0\x02\x03\x12\x03\x12\
    \x02\x1a\n\x0c\n\x05\x04\0\x02\x03\x05\x12\x03\x12\x02\x08\n\x0c\n\x05\
    \x04\0\x02\x03\x01\x12\x03\x12\t\x15\n\x0c\n\x05\x04\0\x02\x03\x03\x12\
    \x03\x12\x18\x19\n\x0b\n\x04\x04\0\x02\x04\x12\x03\x14\x02\x1c\n\x0c\n\
    \x05\x04\0\x02\x04\x05\x12\x03\x14\x02\x08\n\x0c\n\x05\x04\0\x02\x04\x01\
    \x12\x03\x14\t\x16\n\x0c\n\x05\x04\0\x02\x04\x03\x12\x03\x14\x19\x1b\n\"\
    \n\x04\x04\0\x02\x05\x12\x03\x17\x02\x1c\x1a\x15\x20Sampler\x20informati\
    on\n\n\x0c\n\x05\x04\0\x02\x05\x05\x12\x03\x17\x02\x07\n\x0c\n\x05\x04\0\
    \x02\x05\x01\x12\x03\x17\x08\x16\n\x0c\n\x05\x04\0\x02\x05\x03\x12\x03\
    \x17\x19\x1b\n\"\n\x04\x04\0\x02\x06\x12\x03\x1a\x02\x1c\x1a\x15\x20Foun\
    d\x20inside\x20packet\n\n\x0c\n\x05\x04\0\x02\x06\x05\x12\x03\x1a\x02\
    \x08\n\x0c\n\x05\x04\0\x02\x06\x01\x12\x03\x1a\t\x16\n\x0c\n\x05\x04\0\
    \x02\x06\x03\x12\x03\x1a\x19\x1b\n\x0b\n\x04\x04\0\x02\x07\x12\x03\x1b\
    \x02\x19\n\x0c\n\x05\x04\0\x02\x07\x05\x12\x03\x1b\x02\x08\n\x0c\n\x05\
    \x04\0\x02\x07\x01\x12\x03\x1b\t\x14\n\x0c\n\x05\x04\0\x02\x07\x03\x12\
    \x03\x1b\x17\x18\n)\n\x04\x04\0\x02\x08\x12\x03\x1e\x02\x13\x1a\x1c\x20S\
    ize\x20of\x20the\x20sampled\x20packet\n\n\x0c\n\x05\x04\0\x02\x08\x05\
    \x12\x03\x1e\x02\x08\n\x0c\n\x05\x04\0\x02\x08\x01\x12\x03\x1e\t\x0e\n\
    \x0c\n\x05\x04\0\x02\x08\x03\x12\x03\x1e\x11\x12\n\x0b\n\x04\x04\0\x02\t\
    \x12\x03\x1f\x02\x16\n\x0c\n\x05\x04\0\x02\t\x05\x12\x03\x1f\x02\x08\n\
    \x0c\n\x05\x04\0\x02\t\x01\x12\x03\x1f\t\x10\n\x0c\n\x05\x04\0\x02\t\x03\
    \x12\x03\x1f\x13\x15\n+\n\x04\x04\0\x02\n\x12\x03\"\x02\x14\x1a\x1e\x20S\
    ource/destination\x20addresses\n\n\x0c\n\x05\x04\0\x02\n\x05\x12\x03\"\
    \x02\x07\n\x0c\n\x05\x04\0\x02\n\x01\x12\x03\"\x08\x0f\n\x0c\n\x05\x04\0\
    \x02\n\x03\x12\x03\"\x12\x13\n\x0b\n\x04\x04\0\x02\x0b\x12\x03#\x02\x14\
    \n\x0c\n\x05\x04\0\x02\x0b\x05\x12\x03#\x02\x07\n\x0c\n\x05\x04\0\x02\
    \x0b\x01\x12\x03#\x08\x0f\n\x0c\n\x05\x04\0\x02\x0b\x03\x12\x03#\x12\x13\
    \n7\n\x04\x04\0\x02\x0c\x12\x03&\x02\x14\x1a*\x20Layer\x203\x20protocol\
    \x20(IPv4/IPv6/ARP/MPLS...)\n\n\x0c\n\x05\x04\0\x02\x0c\x05\x12\x03&\x02\
    \x08\n\x0c\n\x05\x04\0\x02\x0c\x01\x12\x03&\t\x0e\n\x0c\n\x05\x04\0\x02\
    \x0c\x03\x12\x03&\x11\x13\n\x1f\n\x04\x04\0\x02\r\x12\x03)\x02\x14\x1a\
    \x12\x20Layer\x204\x20protocol\n\n\x0c\n\x05\x04\0\x02\r\x05\x12\x03)\
    \x02\x08\n\x0c\n\x05\x04\0\x02\r\x01\x12\x03)\t\x0e\n\x0c\n\x05\x04\0\
    \x02\r\x03\x12\x03)\x11\x13\n$\n\x04\x04\0\x02\x0e\x12\x03,\x02\x16\x1a\
    \x17\x20Ports\x20for\x20UDP\x20and\x20TCP\n\n\x0c\n\x05\x04\0\x02\x0e\
    \x05\x12\x03,\x02\x08\n\x0c\n\x05\x04\0\x02\x0e\x01\x12\x03,\t\x10\n\x0c\
    \n\x05\x04\0\x02\x0e\x03\x12\x03,\x13\x15\n\x0b\n\x04\x04\0\x02\x0f\x12\
    \x03-\x02\x16\n\x0c\n\x05\x04\0\x02\x0f\x05\x12\x03-\x02\x08\n\x0c\n\x05\
    \x04\0\x02\x0f\x01\x12\x03-\t\x10\n\x0c\n\x05\x04\0\x02\x0f\x03\x12\x03-\
    \x13\x15\n\x19\n\x04\x04\0\x02\x10\x12\x030\x02\x13\x1a\x0c\x20Interface\
    s\n\n\x0c\n\x05\x04\0\x02\x10\x05\x12\x030\x02\x08\n\x0c\n\x05\x04\0\x02\
    \x10\x01\x12\x030\t\r\n\x0c\n\x05\x04\0\x02\x10\x03\x12\x030\x10\x12\n\
    \x0b\n\x04\x04\0\x02\x11\x12\x031\x02\x14\n\x0c\n\x05\x04\0\x02\x11\x05\
    \x12\x031\x02\x08\n\x0c\n\x05\x04\0\x02\x11\x01\x12\x031\t\x0e\n\x0c\n\
    \x05\x04\0\x02\x11\x03\x12\x031\x11\x13\n#\n\x04\x04\0\x02\x12\x12\x034\
    \x02\x15\x1a\x16\x20Ethernet\x20information\n\n\x0c\n\x05\x04\0\x02\x12\
    \x05\x12\x034\x02\x08\n\x0c\n\x05\x04\0\x02\x12\x01\x12\x034\t\x0f\n\x0c\
    \n\x05\x04\0\x02\x12\x03\x12\x034\x12\x14\n\x0b\n\x04\x04\0\x02\x13\x12\
    \x035\x02\x15\n\x0c\n\x05\x04\0\x02\x13\x05\x12\x035\x02\x08\n\x0c\n\x05\
    \x04\0\x02\x13\x01\x12\x035\t\x0f\n\x0c\n\x05\x04\0\x02\x13\x03\x12\x035\
    \x12\x14\n\x13\n\x04\x04\0\x02\x14\x12\x038\x02\x16\x1a\x06\x20Vlan\n\n\
    \x0c\n\x05\x04\0\x02\x14\x05\x12\x038\x02\x08\n\x0c\n\x05\x04\0\x02\x14\
    \x01\x12\x038\t\x10\n\x0c\n\x05\x04\0\x02\x14\x03\x12\x038\x13\x15\n\x0b\
    \n\x04\x04\0\x02\x15\x12\x039\x02\x16\n\x0c\n\x05\x04\0\x02\x15\x05\x12\
    \x039\x02\x08\n\x0c\n\x05\x04\0\x02\x15\x01\x12\x039\t\x10\n\x0c\n\x05\
    \x04\0\x02\x15\x03\x12\x039\x13\x15\n,\n\x04\x04\0\x02\x16\x12\x03;\x02\
    \x15\x1a\x1f\x20802.1q\x20VLAN\x20in\x20sampled\x20packet\n\n\x0c\n\x05\
    \x04\0\x02\x16\x05\x12\x03;\x02\x08\n\x0c\n\x05\x04\0\x02\x16\x01\x12\
    \x03;\t\x0f\n\x0c\n\x05\x04\0\x02\x16\x03\x12\x03;\x12\x14\n\x12\n\x04\
    \x04\0\x02\x17\x12\x03>\x02\x1b\x1a\x05\x20VRF\n\n\x0c\n\x05\x04\0\x02\
    \x17\x05\x12\x03>\x02\x08\n\x0c\n\x05\x04\0\x02\x17\x01\x12\x03>\t\x15\n\
    \x0c\n\x05\x04\0\x02\x17\x03\x12\x03>\x18\x1a\n\x0b\n\x04\x04\0\x02\x18\
    \x12\x03?\x02\x1a\n\x0c\n\x05\x04\0\x02\x18\x05\x12\x03?\x02\x08\n\x0c\n\
    \x05\x04\0\x02\x18\x01\x12\x03?\t\x14\n\x0c\n\x05\x04\0\x02\x18\x03\x12\
    \x03?\x17\x19\n'\n\x04\x04\0\x02\x19\x12\x03B\x02\x14\x1a\x1a\x20IP\x20a\
    nd\x20TCP\x20special\x20flags\n\n\x0c\n\x05\x04\0\x02\x19\x05\x12\x03B\
    \x02\x08\n\x0c\n\x05\x04\0\x02\x19\x01\x12\x03B\t\x0e\n\x0c\n\x05\x04\0\
    \x02\x19\x03\x12\x03B\x11\x13\n\x0b\n\x04\x04\0\x02\x1a\x12\x03C\x02\x1f\
    \n\x0c\n\x05\x04\0\x02\x1a\x05\x12\x03C\x02\x08\n\x0c\n\x05\x04\0\x02\
    \x1a\x01\x12\x03C\t\x19\n\x0c\n\x05\x04\0\x02\x1a\x03\x12\x03C\x1c\x1e\n\
    \x0b\n\x04\x04\0\x02\x1b\x12\x03D\x02\x14\n\x0c\n\x05\x04\0\x02\x1b\x05\
    \x12\x03D\x02\x08\n\x0c\n\x05\x04\0\x02\x1b\x01\x12\x03D\t\x0e\n\x0c\n\
    \x05\x04\0\x02\x1b\x03\x12\x03D\x11\x13\n\x0b\n\x04\x04\0\x02\x1c\x12\
    \x03E\x02\x17\n\x0c\n\x05\x04\0\x02\x1c\x05\x12\x03E\x02\x08\n\x0c\n\x05\
    \x04\0\x02\x1c\x01\x12\x03E\t\x11\n\x0c\n\x05\x04\0\x02\x1c\x03\x12\x03E\
    \x14\x16\n\x0b\n\x04\x04\0\x02\x1d\x12\x03F\x02\x17\n\x0c\n\x05\x04\0\
    \x02\x1d\x05\x12\x03F\x02\x08\n\x0c\n\x05\x04\0\x02\x1d\x01\x12\x03F\t\
    \x11\n\x0c\n\x05\x04\0\x02\x1d\x03\x12\x03F\x14\x16\n\x0b\n\x04\x04\0\
    \x02\x1e\x12\x03G\x02\x17\n\x0c\n\x05\x04\0\x02\x1e\x05\x12\x03G\x02\x08\
    \n\x0c\n\x05\x04\0\x02\x1e\x01\x12\x03G\t\x11\n\x0c\n\x05\x04\0\x02\x1e\
    \x03\x12\x03G\x14\x16\n\x0b\n\x04\x04\0\x02\x1f\x12\x03H\x02\x1c\n\x0c\n\
    \x05\x04\0\x02\x1f\x05\x12\x03H\x02\x08\n\x0c\n\x05\x04\0\x02\x1f\x01\
    \x12\x03H\t\x16\n\x0c\n\x05\x04\0\x02\x1f\x03\x12\x03H\x19\x1b\n$\n\x04\
    \x04\0\x02\x20\x12\x03J\x02\x19\x1a\x17\x20Fragments\x20(IPv4/IPv6)\n\n\
    \x0c\n\x05\x04\0\x02\x20\x05\x12\x03J\x02\x08\n\x0c\n\x05\x04\0\x02\x20\
    \x01\x12\x03J\t\x13\n\x0c\n\x05\x04\0\x02\x20\x03\x12\x03J\x16\x18\n\x0b\
    \n\x04\x04\0\x02!\x12\x03K\x02\x1d\n\x0c\n\x05\x04\0\x02!\x05\x12\x03K\
    \x02\x08\n\x0c\n\x05\x04\0\x02!\x01\x12\x03K\t\x17\n\x0c\n\x05\x04\0\x02\
    !\x03\x12\x03K\x1a\x1c\n\x0b\n\x04\x04\0\x02\"\x12\x03L\x02\x1e\n\x0c\n\
    \x05\x04\0\x02\"\x05\x12\x03L\x02\x08\n\x0c\n\x05\x04\0\x02\"\x01\x12\
    \x03L\t\x18\n\x0c\n\x05\x04\0\x02\"\x03\x12\x03L\x1b\x1d\n,\n\x04\x04\0\
    \x02#\x12\x03O\x02\x14\x1a\x1f\x20Autonomous\x20system\x20information\n\
    \n\x0c\n\x05\x04\0\x02#\x05\x12\x03O\x02\x08\n\x0c\n\x05\x04\0\x02#\x01\
    \x12\x03O\t\x0e\n\x0c\n\x05\x04\0\x02#\x03\x12\x03O\x11\x13\n\x0b\n\x04\
    \x04\0\x02$\x12\x03P\x02\x14\n\x0c\n\x05\x04\0\x02$\x05\x12\x03P\x02\x08\
    \n\x0c\n\x05\x04\0\x02$\x01\x12\x03P\t\x0e\n\x0c\n\x05\x04\0\x02$\x03\
    \x12\x03P\x11\x13\n\x0b\n\x04\x04\0\x02%\x12\x03R\x02\x15\n\x0c\n\x05\
    \x04\0\x02%\x05\x12\x03R\x02\x07\n\x0c\n\x05\x04\0\x02%\x01\x12\x03R\x08\
    \x0f\n\x0c\n\x05\x04\0\x02%\x03\x12\x03R\x12\x14\n\x0b\n\x04\x04\0\x02&\
    \x12\x03S\x02\x18\n\x0c\n\x05\x04\0\x02&\x05\x12\x03S\x02\x08\n\x0c\n\
    \x05\x04\0\x02&\x01\x12\x03S\t\x12\n\x0c\n\x05\x04\0\x02&\x03\x12\x03S\
    \x15\x17\n\x1a\n\x04\x04\0\x02'\x12\x03V\x02\x15\x1a\r\x20Prefix\x20size\
    \n\n\x0c\n\x05\x04\0\x02'\x05\x12\x03V\x02\x08\n\x0c\n\x05\x04\0\x02'\
    \x01\x12\x03V\t\x0f\n\x0c\n\x05\x04\0\x02'\x03\x12\x03V\x12\x14\n\x0b\n\
    \x04\x04\0\x02(\x12\x03W\x02\x15\n\x0c\n\x05\x04\0\x02(\x05\x12\x03W\x02\
    \x08\n\x0c\n\x05\x04\0\x02(\x01\x12\x03W\t\x0f\n\x0c\n\x05\x04\0\x02(\
    \x03\x12\x03W\x12\x14\n\x1f\n\x04\x04\0\x02)\x12\x03Z\x02\x14\x1a\x12\
    \x20MPLS\x20information\n\n\x0c\n\x05\x04\0\x02)\x05\x12\x03Z\x02\x06\n\
    \x0c\n\x05\x04\0\x02)\x01\x12\x03Z\x07\x0e\n\x0c\n\x05\x04\0\x02)\x03\
    \x12\x03Z\x11\x13\n\x0b\n\x04\x04\0\x02*\x12\x03[\x02\x18\n\x0c\n\x05\
    \x04\0\x02*\x05\x12\x03[\x02\x08\n\x0c\n\x05\x04\0\x02*\x01\x12\x03[\t\
    \x12\n\x0c\n\x05\x04\0\x02*\x03\x12\x03[\x15\x17\n\x18\n\x04\x04\0\x02+\
    \x12\x03\\\x02\x17\"\x0b\x20First\x20TTL\n\n\x0c\n\x05\x04\0\x02+\x05\
    \x12\x03\\\x02\x08\n\x0c\n\x05\x04\0\x02+\x01\x12\x03\\\t\x11\n\x0c\n\
    \x05\x04\0\x02+\x03\x12\x03\\\x14\x16\n\x1a\n\x04\x04\0\x02,\x12\x03]\
    \x02\x19\"\r\x20First\x20Label\n\n\x0c\n\x05\x04\0\x02,\x05\x12\x03]\x02\
    \x08\n\x0c\n\x05\x04\0\x02,\x01\x12\x03]\t\x13\n\x0c\n\x05\x04\0\x02,\
    \x03\x12\x03]\x16\x18\n\x19\n\x04\x04\0\x02-\x12\x03^\x02\x17\"\x0c\x20S\
    econd\x20TTL\n\n\x0c\n\x05\x04\0\x02-\x05\x12\x03^\x02\x08\n\x0c\n\x05\
    \x04\0\x02-\x01\x12\x03^\t\x11\n\x0c\n\x05\x04\0\x02-\x03\x12\x03^\x14\
    \x16\n\x1b\n\x04\x04\0\x02.\x12\x03_\x02\x19\"\x0e\x20Second\x20Label\n\
    \n\x0c\n\x05\x04\0\x02.\x05\x12\x03_\x02\x08\n\x0c\n\x05\x04\0\x02.\x01\
    \x12\x03_\t\x13\n\x0c\n\x05\x04\0\x02.\x03\x12\x03_\x16\x18\n\x18\n\x04\
    \x04\0\x02/\x12\x03`\x02\x17\"\x0b\x20Third\x20TTL\n\n\x0c\n\x05\x04\0\
    \x02/\x05\x12\x03`\x02\x08\n\x0c\n\x05\x04\0\x02/\x01\x12\x03`\t\x11\n\
    \x0c\n\x05\x04\0\x02/\x03\x12\x03`\x14\x16\n\x1a\n\x04\x04\0\x020\x12\
    \x03a\x02\x19\"\r\x20Third\x20Label\n\n\x0c\n\x05\x04\0\x020\x05\x12\x03\
    a\x02\x08\n\x0c\n\x05\x04\0\x020\x01\x12\x03a\t\x13\n\x0c\n\x05\x04\0\
    \x020\x03\x12\x03a\x16\x18\n\x17\n\x04\x04\0\x021\x12\x03b\x02\x1a\"\n\
    \x20Last\x20TTL\n\n\x0c\n\x05\x04\0\x021\x05\x12\x03b\x02\x08\n\x0c\n\
    \x05\x04\0\x021\x01\x12\x03b\t\x14\n\x0c\n\x05\x04\0\x021\x03\x12\x03b\
    \x17\x19\n\x19\n\x04\x04\0\x022\x12\x03c\x02\x1c\"\x0c\x20Last\x20Label\
    \n\n\x0c\n\x05\x04\0\x022\x05\x12\x03c\x02\x08\n\x0c\n\x05\x04\0\x022\
    \x01\x12\x03c\t\x16\n\x0c\n\x05\x04\0\x022\x03\x12\x03c\x19\x1b\n\x9f\
    \x01\n\x04\x04\0\x023\x12\x03i\x02\x14\x1a\x1b\x20bwNetFlow\x20enricher\
    \x20fields\n\"0\x20Customer\x20ID\x20-\x20numerical\x20ID,\x20assigned\
    \x20by\x20prefix\n2C\x20Custom\x20fields:\x20start\x20after\x20ID\x20100\
    0:\n\x20uint32\x20MyCustomField\x20=\x201000;\n\n\x0c\n\x05\x04\0\x023\
    \x05\x12\x03i\x02\x08\n\x0c\n\x05\x04\0\x023\x01\x12\x03i\t\x0c\n\x0c\n\
    \x05\x04\0\x023\x03\x12\x03i\x0f\x13\nF\n\x04\x04\0\x024\x12\x03j\x02\
    \x1a\"9\x20Customer\x20ID\x20-\x20a\x20more\x20generalized\x20ID,\x20ass\
    igned\x20by\x20prefix\n\n\x0c\n\x05\x04\0\x024\x05\x12\x03j\x02\x08\n\
    \x0c\n\x05\x04\0\x024\x01\x12\x03j\t\x12\n\x0c\n\x05\x04\0\x024\x03\x12\
    \x03j\x15\x19\n\x0c\n\x04\x04\0\x04\x01\x12\x04l\x02o\x03\n\x0c\n\x05\
    \x04\0\x04\x01\x01\x12\x03l\x07\x15\n\r\n\x06\x04\0\x04\x01\x02\0\x12\
    \x03m\x04\x0b\n\x0e\n\x07\x04\0\x04\x01\x02\0\x01\x12\x03m\x04\x06\n\x0e\
    \n\x07\x04\0\x04\x01\x02\0\x02\x12\x03m\t\n\n\r\n\x06\x04\0\x04\x01\x02\
    \x01\x12\x03n\x04\x0c\n\x0e\n\x07\x04\0\x04\x01\x02\x01\x01\x12\x03n\x04\
    \x07\n\x0e\n\x07\x04\0\x04\x01\x02\x01\x02\x12\x03n\n\x0b\nI\n\x04\x04\0\
    \x025\x12\x03p\x02#\"<\x20Normalization\x20-\x20whether\x20the\x20sampli\
    ng\x20rate\x20is\x20accounted\x20for\n\n\x0c\n\x05\x04\0\x025\x06\x12\
    \x03p\x02\x10\n\x0c\n\x05\x04\0\x025\x01\x12\x03p\x11\x1b\n\x0c\n\x05\
    \x04\0\x025\x03\x12\x03p\x1e\"\ni\n\x04\x04\0\x026\x12\x03s\x02\x1a\x1a7\
    \x20Fields\x20for\x20Interface\x20Usability\x20--\x20enriched\x20using\
    \x20SNMP\n\"#\x20set\x20to\x20the\x20name,\x20unset\x20by\x20default\n\n\
    \x0c\n\x05\x04\0\x026\x05\x12\x03s\x02\x08\n\x0c\n\x05\x04\0\x026\x01\
    \x12\x03s\t\x12\n\x0c\n\x05\x04\0\x026\x03\x12\x03s\x15\x19\nI\n\x04\x04\
    \0\x027\x12\x03t\x02\x1a\"<\x20set\x20to\x20the\x20descrition,\x20filter\
    ed\x20by\x20a\x20regex\x20in\x20the\x20enricher\n\n\x0c\n\x05\x04\0\x027\
    \x05\x12\x03t\x02\x08\n\x0c\n\x05\x04\0\x027\x01\x12\x03t\t\x12\n\x0c\n\
    \x05\x04\0\x027\x03\x12\x03t\x15\x19\n\x1a\n\x04\x04\0\x028\x12\x03u\x02\
    \x1b\"\r\x20iface\x20speed\n\n\x0c\n\x05\x04\0\x028\x05\x12\x03u\x02\x08\
    \n\x0c\n\x05\x04\0\x028\x01\x12\x03u\t\x13\n\x0c\n\x05\x04\0\x028\x03\
    \x12\x03u\x16\x1a\n\x0b\n\x04\x04\0\x029\x12\x03v\x02\x1a\n\x0c\n\x05\
    \x04\0\x029\x05\x12\x03v\x02\x08\n\x0c\n\x05\x04\0\x029\x01\x12\x03v\t\
    \x12\n\x0c\n\x05\x04\0\x029\x03\x12\x03v\x15\x19\n\x0b\n\x04\x04\0\x02:\
    \x12\x03w\x02\x1a\n\x0c\n\x05\x04\0\x02:\x05\x12\x03w\x02\x08\n\x0c\n\
    \x05\x04\0\x02:\x01\x12\x03w\t\x12\n\x0c\n\x05\x04\0\x02:\x03\x12\x03w\
    \x15\x19\n\x0b\n\x04\x04\0\x02;\x12\x03x\x02\x1b\n\x0c\n\x05\x04\0\x02;\
    \x05\x12\x03x\x02\x08\n\x0c\n\x05\x04\0\x02;\x01\x12\x03x\t\x13\n\x0c\n\
    \x05\x04\0\x02;\x03\x12\x03x\x16\x1a\nQ\n\x04\x04\0\x02<\x12\x03z\x02\
    \x1a\"D\x20Protocol\x20Name\x20--\x20set\x20for\x20some\x20well\x20known\
    \x20protocols,\x20based\x20on\x20Proto\n\n\x0c\n\x05\x04\0\x02<\x05\x12\
    \x03z\x02\x08\n\x0c\n\x05\x04\0\x02<\x01\x12\x03z\t\x12\n\x0c\n\x05\x04\
    \0\x02<\x03\x12\x03z\x15\x19\n=\n\x04\x04\0\x02=\x12\x03{\x02\x1e\"0\x20\
    Geolocation\x20--\x20set\x20using\x20the\x20provided\x20database\n\n\x0c\
    \n\x05\x04\0\x02=\x05\x12\x03{\x02\x08\n\x0c\n\x05\x04\0\x02=\x01\x12\
    \x03{\t\x16\n\x0c\n\x05\x04\0\x02=\x03\x12\x03{\x19\x1d\n\r\n\x04\x04\0\
    \x04\x02\x12\x05}\x02\x81\x01\x03\n\x0c\n\x05\x04\0\x04\x02\x01\x12\x03}\
    \x07\x15\n\r\n\x06\x04\0\x04\x02\x02\0\x12\x03~\x04\x10\n\x0e\n\x07\x04\
    \0\x04\x02\x02\0\x01\x12\x03~\x04\x0b\n\x0e\n\x07\x04\0\x04\x02\x02\0\
    \x02\x12\x03~\x0e\x0f\n\r\n\x06\x04\0\x04\x02\x02\x01\x12\x03\x7f\x04\
    \x0c\n\x0e\n\x07\x04\0\x04\x02\x02\x01\x01\x12\x03\x7f\x04\x07\n\x0e\n\
    \x07\x04\0\x04\x02\x02\x01\x02\x12\x03\x7f\n\x0b\n\x0e\n\x06\x04\0\x04\
    \x02\x02\x02\x12\x04\x80\x01\x04\x0c\n\x0f\n\x07\x04\0\x04\x02\x02\x02\
    \x01\x12\x04\x80\x01\x04\x07\n\x0f\n\x07\x04\0\x04\x02\x02\x02\x02\x12\
    \x04\x80\x01\n\x0b\nO\n\x04\x04\0\x02>\x12\x04\x82\x01\x02#\"A\x20Remote\
    Addr\x20-\x20which\x20Addr\x20field\x20contains\x20the\x20remote/local\
    \x20address\n\n\r\n\x05\x04\0\x02>\x06\x12\x04\x82\x01\x02\x10\n\r\n\x05\
    \x04\0\x02>\x01\x12\x04\x82\x01\x11\x1b\n\r\n\x05\x04\0\x02>\x03\x12\x04\
    \x82\x01\x1e\"b\x06proto3\
";

static file_descriptor_proto_lazy: ::protobuf::rt::LazyV2<::protobuf::descriptor::FileDescriptorProto> = ::protobuf::rt::LazyV2::INIT;

fn parse_descriptor_proto() -> ::protobuf::descriptor::FileDescriptorProto {
    ::protobuf::Message::parse_from_bytes(file_descriptor_proto_data).unwrap()
}

pub fn file_descriptor_proto() -> &'static ::protobuf::descriptor::FileDescriptorProto {
    file_descriptor_proto_lazy.get(|| {
        parse_descriptor_proto()
    })
}
