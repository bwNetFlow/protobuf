// This file is generated by rust-protobuf 2.0.4. Do not edit
// @generated

// https://github.com/Manishearth/rust-clippy/issues/702
#![allow(unknown_lints)]
#![allow(clippy)]

#![cfg_attr(rustfmt, rustfmt_skip)]

#![allow(box_pointers)]
#![allow(dead_code)]
#![allow(missing_docs)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(non_upper_case_globals)]
#![allow(trivial_casts)]
#![allow(unsafe_code)]
#![allow(unused_imports)]
#![allow(unused_results)]

use protobuf::Message as Message_imported_for_functions;
use protobuf::ProtobufEnum as ProtobufEnum_imported_for_functions;

#[derive(PartialEq,Clone,Default)]
pub struct FlowMessage {
    // message fields
    pub Type: FlowMessage_FlowType,
    pub TimeReceived: u64,
    pub SequenceNum: u32,
    pub SamplingRate: u64,
    pub FlowDirection: u32,
    pub SamplerAddress: ::std::vec::Vec<u8>,
    pub TimeFlowStart: u64,
    pub TimeFlowEnd: u64,
    pub Bytes: u64,
    pub Packets: u64,
    pub SrcAddr: ::std::vec::Vec<u8>,
    pub DstAddr: ::std::vec::Vec<u8>,
    pub Etype: u32,
    pub Proto: u32,
    pub SrcPort: u32,
    pub DstPort: u32,
    pub InIf: u32,
    pub OutIf: u32,
    pub SrcMac: u64,
    pub DstMac: u64,
    pub SrcVlan: u32,
    pub DstVlan: u32,
    pub VlanId: u32,
    pub IngressVrfID: u32,
    pub EgressVrfID: u32,
    pub IPTos: u32,
    pub ForwardingStatus: u32,
    pub IPTTL: u32,
    pub TCPFlags: u32,
    pub IcmpType: u32,
    pub IcmpCode: u32,
    pub IPv6FlowLabel: u32,
    pub FragmentId: u32,
    pub FragmentOffset: u32,
    pub BiFlowDirection: u32,
    pub SrcAS: u32,
    pub DstAS: u32,
    pub NextHop: ::std::vec::Vec<u8>,
    pub NextHopAS: u32,
    pub SrcNet: u32,
    pub DstNet: u32,
    pub HasEncap: bool,
    pub SrcAddrEncap: ::std::vec::Vec<u8>,
    pub DstAddrEncap: ::std::vec::Vec<u8>,
    pub ProtoEncap: u32,
    pub EtypeEncap: u32,
    pub IPTosEncap: u32,
    pub IPTTLEncap: u32,
    pub IPv6FlowLabelEncap: u32,
    pub FragmentIdEncap: u32,
    pub FragmentOffsetEncap: u32,
    pub HasMPLS: bool,
    pub MPLSCount: u32,
    pub MPLS1TTL: u32,
    pub MPLS1Label: u32,
    pub MPLS2TTL: u32,
    pub MPLS2Label: u32,
    pub MPLS3TTL: u32,
    pub MPLS3Label: u32,
    pub MPLSLastTTL: u32,
    pub MPLSLastLabel: u32,
    pub HasPPP: bool,
    pub PPPAddressControl: u32,
    pub Cid: u32,
    pub CidString: ::std::string::String,
    pub Normalized: FlowMessage_NormalizedType,
    pub SrcIfName: ::std::string::String,
    pub SrcIfDesc: ::std::string::String,
    pub SrcIfSpeed: u32,
    pub DstIfName: ::std::string::String,
    pub DstIfDesc: ::std::string::String,
    pub DstIfSpeed: u32,
    pub ProtoName: ::std::string::String,
    pub RemoteCountry: ::std::string::String,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

impl FlowMessage {
    pub fn new() -> FlowMessage {
        ::std::default::Default::default()
    }

    // .flowmessageenriched.FlowMessage.FlowType Type = 1;

    pub fn clear_Type(&mut self) {
        self.Type = FlowMessage_FlowType::FLOWUNKNOWN;
    }

    // Param is passed by value, moved
    pub fn set_Type(&mut self, v: FlowMessage_FlowType) {
        self.Type = v;
    }

    pub fn get_Type(&self) -> FlowMessage_FlowType {
        self.Type
    }

    // uint64 TimeReceived = 2;

    pub fn clear_TimeReceived(&mut self) {
        self.TimeReceived = 0;
    }

    // Param is passed by value, moved
    pub fn set_TimeReceived(&mut self, v: u64) {
        self.TimeReceived = v;
    }

    pub fn get_TimeReceived(&self) -> u64 {
        self.TimeReceived
    }

    // uint32 SequenceNum = 4;

    pub fn clear_SequenceNum(&mut self) {
        self.SequenceNum = 0;
    }

    // Param is passed by value, moved
    pub fn set_SequenceNum(&mut self, v: u32) {
        self.SequenceNum = v;
    }

    pub fn get_SequenceNum(&self) -> u32 {
        self.SequenceNum
    }

    // uint64 SamplingRate = 3;

    pub fn clear_SamplingRate(&mut self) {
        self.SamplingRate = 0;
    }

    // Param is passed by value, moved
    pub fn set_SamplingRate(&mut self, v: u64) {
        self.SamplingRate = v;
    }

    pub fn get_SamplingRate(&self) -> u64 {
        self.SamplingRate
    }

    // uint32 FlowDirection = 42;

    pub fn clear_FlowDirection(&mut self) {
        self.FlowDirection = 0;
    }

    // Param is passed by value, moved
    pub fn set_FlowDirection(&mut self, v: u32) {
        self.FlowDirection = v;
    }

    pub fn get_FlowDirection(&self) -> u32 {
        self.FlowDirection
    }

    // bytes SamplerAddress = 11;

    pub fn clear_SamplerAddress(&mut self) {
        self.SamplerAddress.clear();
    }

    // Param is passed by value, moved
    pub fn set_SamplerAddress(&mut self, v: ::std::vec::Vec<u8>) {
        self.SamplerAddress = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_SamplerAddress(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.SamplerAddress
    }

    // Take field
    pub fn take_SamplerAddress(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.SamplerAddress, ::std::vec::Vec::new())
    }

    pub fn get_SamplerAddress(&self) -> &[u8] {
        &self.SamplerAddress
    }

    // uint64 TimeFlowStart = 38;

    pub fn clear_TimeFlowStart(&mut self) {
        self.TimeFlowStart = 0;
    }

    // Param is passed by value, moved
    pub fn set_TimeFlowStart(&mut self, v: u64) {
        self.TimeFlowStart = v;
    }

    pub fn get_TimeFlowStart(&self) -> u64 {
        self.TimeFlowStart
    }

    // uint64 TimeFlowEnd = 5;

    pub fn clear_TimeFlowEnd(&mut self) {
        self.TimeFlowEnd = 0;
    }

    // Param is passed by value, moved
    pub fn set_TimeFlowEnd(&mut self, v: u64) {
        self.TimeFlowEnd = v;
    }

    pub fn get_TimeFlowEnd(&self) -> u64 {
        self.TimeFlowEnd
    }

    // uint64 Bytes = 9;

    pub fn clear_Bytes(&mut self) {
        self.Bytes = 0;
    }

    // Param is passed by value, moved
    pub fn set_Bytes(&mut self, v: u64) {
        self.Bytes = v;
    }

    pub fn get_Bytes(&self) -> u64 {
        self.Bytes
    }

    // uint64 Packets = 10;

    pub fn clear_Packets(&mut self) {
        self.Packets = 0;
    }

    // Param is passed by value, moved
    pub fn set_Packets(&mut self, v: u64) {
        self.Packets = v;
    }

    pub fn get_Packets(&self) -> u64 {
        self.Packets
    }

    // bytes SrcAddr = 6;

    pub fn clear_SrcAddr(&mut self) {
        self.SrcAddr.clear();
    }

    // Param is passed by value, moved
    pub fn set_SrcAddr(&mut self, v: ::std::vec::Vec<u8>) {
        self.SrcAddr = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_SrcAddr(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.SrcAddr
    }

    // Take field
    pub fn take_SrcAddr(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.SrcAddr, ::std::vec::Vec::new())
    }

    pub fn get_SrcAddr(&self) -> &[u8] {
        &self.SrcAddr
    }

    // bytes DstAddr = 7;

    pub fn clear_DstAddr(&mut self) {
        self.DstAddr.clear();
    }

    // Param is passed by value, moved
    pub fn set_DstAddr(&mut self, v: ::std::vec::Vec<u8>) {
        self.DstAddr = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_DstAddr(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.DstAddr
    }

    // Take field
    pub fn take_DstAddr(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.DstAddr, ::std::vec::Vec::new())
    }

    pub fn get_DstAddr(&self) -> &[u8] {
        &self.DstAddr
    }

    // uint32 Etype = 30;

    pub fn clear_Etype(&mut self) {
        self.Etype = 0;
    }

    // Param is passed by value, moved
    pub fn set_Etype(&mut self, v: u32) {
        self.Etype = v;
    }

    pub fn get_Etype(&self) -> u32 {
        self.Etype
    }

    // uint32 Proto = 20;

    pub fn clear_Proto(&mut self) {
        self.Proto = 0;
    }

    // Param is passed by value, moved
    pub fn set_Proto(&mut self, v: u32) {
        self.Proto = v;
    }

    pub fn get_Proto(&self) -> u32 {
        self.Proto
    }

    // uint32 SrcPort = 21;

    pub fn clear_SrcPort(&mut self) {
        self.SrcPort = 0;
    }

    // Param is passed by value, moved
    pub fn set_SrcPort(&mut self, v: u32) {
        self.SrcPort = v;
    }

    pub fn get_SrcPort(&self) -> u32 {
        self.SrcPort
    }

    // uint32 DstPort = 22;

    pub fn clear_DstPort(&mut self) {
        self.DstPort = 0;
    }

    // Param is passed by value, moved
    pub fn set_DstPort(&mut self, v: u32) {
        self.DstPort = v;
    }

    pub fn get_DstPort(&self) -> u32 {
        self.DstPort
    }

    // uint32 InIf = 18;

    pub fn clear_InIf(&mut self) {
        self.InIf = 0;
    }

    // Param is passed by value, moved
    pub fn set_InIf(&mut self, v: u32) {
        self.InIf = v;
    }

    pub fn get_InIf(&self) -> u32 {
        self.InIf
    }

    // uint32 OutIf = 19;

    pub fn clear_OutIf(&mut self) {
        self.OutIf = 0;
    }

    // Param is passed by value, moved
    pub fn set_OutIf(&mut self, v: u32) {
        self.OutIf = v;
    }

    pub fn get_OutIf(&self) -> u32 {
        self.OutIf
    }

    // uint64 SrcMac = 27;

    pub fn clear_SrcMac(&mut self) {
        self.SrcMac = 0;
    }

    // Param is passed by value, moved
    pub fn set_SrcMac(&mut self, v: u64) {
        self.SrcMac = v;
    }

    pub fn get_SrcMac(&self) -> u64 {
        self.SrcMac
    }

    // uint64 DstMac = 28;

    pub fn clear_DstMac(&mut self) {
        self.DstMac = 0;
    }

    // Param is passed by value, moved
    pub fn set_DstMac(&mut self, v: u64) {
        self.DstMac = v;
    }

    pub fn get_DstMac(&self) -> u64 {
        self.DstMac
    }

    // uint32 SrcVlan = 33;

    pub fn clear_SrcVlan(&mut self) {
        self.SrcVlan = 0;
    }

    // Param is passed by value, moved
    pub fn set_SrcVlan(&mut self, v: u32) {
        self.SrcVlan = v;
    }

    pub fn get_SrcVlan(&self) -> u32 {
        self.SrcVlan
    }

    // uint32 DstVlan = 34;

    pub fn clear_DstVlan(&mut self) {
        self.DstVlan = 0;
    }

    // Param is passed by value, moved
    pub fn set_DstVlan(&mut self, v: u32) {
        self.DstVlan = v;
    }

    pub fn get_DstVlan(&self) -> u32 {
        self.DstVlan
    }

    // uint32 VlanId = 29;

    pub fn clear_VlanId(&mut self) {
        self.VlanId = 0;
    }

    // Param is passed by value, moved
    pub fn set_VlanId(&mut self, v: u32) {
        self.VlanId = v;
    }

    pub fn get_VlanId(&self) -> u32 {
        self.VlanId
    }

    // uint32 IngressVrfID = 39;

    pub fn clear_IngressVrfID(&mut self) {
        self.IngressVrfID = 0;
    }

    // Param is passed by value, moved
    pub fn set_IngressVrfID(&mut self, v: u32) {
        self.IngressVrfID = v;
    }

    pub fn get_IngressVrfID(&self) -> u32 {
        self.IngressVrfID
    }

    // uint32 EgressVrfID = 40;

    pub fn clear_EgressVrfID(&mut self) {
        self.EgressVrfID = 0;
    }

    // Param is passed by value, moved
    pub fn set_EgressVrfID(&mut self, v: u32) {
        self.EgressVrfID = v;
    }

    pub fn get_EgressVrfID(&self) -> u32 {
        self.EgressVrfID
    }

    // uint32 IPTos = 23;

    pub fn clear_IPTos(&mut self) {
        self.IPTos = 0;
    }

    // Param is passed by value, moved
    pub fn set_IPTos(&mut self, v: u32) {
        self.IPTos = v;
    }

    pub fn get_IPTos(&self) -> u32 {
        self.IPTos
    }

    // uint32 ForwardingStatus = 24;

    pub fn clear_ForwardingStatus(&mut self) {
        self.ForwardingStatus = 0;
    }

    // Param is passed by value, moved
    pub fn set_ForwardingStatus(&mut self, v: u32) {
        self.ForwardingStatus = v;
    }

    pub fn get_ForwardingStatus(&self) -> u32 {
        self.ForwardingStatus
    }

    // uint32 IPTTL = 25;

    pub fn clear_IPTTL(&mut self) {
        self.IPTTL = 0;
    }

    // Param is passed by value, moved
    pub fn set_IPTTL(&mut self, v: u32) {
        self.IPTTL = v;
    }

    pub fn get_IPTTL(&self) -> u32 {
        self.IPTTL
    }

    // uint32 TCPFlags = 26;

    pub fn clear_TCPFlags(&mut self) {
        self.TCPFlags = 0;
    }

    // Param is passed by value, moved
    pub fn set_TCPFlags(&mut self, v: u32) {
        self.TCPFlags = v;
    }

    pub fn get_TCPFlags(&self) -> u32 {
        self.TCPFlags
    }

    // uint32 IcmpType = 31;

    pub fn clear_IcmpType(&mut self) {
        self.IcmpType = 0;
    }

    // Param is passed by value, moved
    pub fn set_IcmpType(&mut self, v: u32) {
        self.IcmpType = v;
    }

    pub fn get_IcmpType(&self) -> u32 {
        self.IcmpType
    }

    // uint32 IcmpCode = 32;

    pub fn clear_IcmpCode(&mut self) {
        self.IcmpCode = 0;
    }

    // Param is passed by value, moved
    pub fn set_IcmpCode(&mut self, v: u32) {
        self.IcmpCode = v;
    }

    pub fn get_IcmpCode(&self) -> u32 {
        self.IcmpCode
    }

    // uint32 IPv6FlowLabel = 37;

    pub fn clear_IPv6FlowLabel(&mut self) {
        self.IPv6FlowLabel = 0;
    }

    // Param is passed by value, moved
    pub fn set_IPv6FlowLabel(&mut self, v: u32) {
        self.IPv6FlowLabel = v;
    }

    pub fn get_IPv6FlowLabel(&self) -> u32 {
        self.IPv6FlowLabel
    }

    // uint32 FragmentId = 35;

    pub fn clear_FragmentId(&mut self) {
        self.FragmentId = 0;
    }

    // Param is passed by value, moved
    pub fn set_FragmentId(&mut self, v: u32) {
        self.FragmentId = v;
    }

    pub fn get_FragmentId(&self) -> u32 {
        self.FragmentId
    }

    // uint32 FragmentOffset = 36;

    pub fn clear_FragmentOffset(&mut self) {
        self.FragmentOffset = 0;
    }

    // Param is passed by value, moved
    pub fn set_FragmentOffset(&mut self, v: u32) {
        self.FragmentOffset = v;
    }

    pub fn get_FragmentOffset(&self) -> u32 {
        self.FragmentOffset
    }

    // uint32 BiFlowDirection = 41;

    pub fn clear_BiFlowDirection(&mut self) {
        self.BiFlowDirection = 0;
    }

    // Param is passed by value, moved
    pub fn set_BiFlowDirection(&mut self, v: u32) {
        self.BiFlowDirection = v;
    }

    pub fn get_BiFlowDirection(&self) -> u32 {
        self.BiFlowDirection
    }

    // uint32 SrcAS = 14;

    pub fn clear_SrcAS(&mut self) {
        self.SrcAS = 0;
    }

    // Param is passed by value, moved
    pub fn set_SrcAS(&mut self, v: u32) {
        self.SrcAS = v;
    }

    pub fn get_SrcAS(&self) -> u32 {
        self.SrcAS
    }

    // uint32 DstAS = 15;

    pub fn clear_DstAS(&mut self) {
        self.DstAS = 0;
    }

    // Param is passed by value, moved
    pub fn set_DstAS(&mut self, v: u32) {
        self.DstAS = v;
    }

    pub fn get_DstAS(&self) -> u32 {
        self.DstAS
    }

    // bytes NextHop = 12;

    pub fn clear_NextHop(&mut self) {
        self.NextHop.clear();
    }

    // Param is passed by value, moved
    pub fn set_NextHop(&mut self, v: ::std::vec::Vec<u8>) {
        self.NextHop = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_NextHop(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.NextHop
    }

    // Take field
    pub fn take_NextHop(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.NextHop, ::std::vec::Vec::new())
    }

    pub fn get_NextHop(&self) -> &[u8] {
        &self.NextHop
    }

    // uint32 NextHopAS = 13;

    pub fn clear_NextHopAS(&mut self) {
        self.NextHopAS = 0;
    }

    // Param is passed by value, moved
    pub fn set_NextHopAS(&mut self, v: u32) {
        self.NextHopAS = v;
    }

    pub fn get_NextHopAS(&self) -> u32 {
        self.NextHopAS
    }

    // uint32 SrcNet = 16;

    pub fn clear_SrcNet(&mut self) {
        self.SrcNet = 0;
    }

    // Param is passed by value, moved
    pub fn set_SrcNet(&mut self, v: u32) {
        self.SrcNet = v;
    }

    pub fn get_SrcNet(&self) -> u32 {
        self.SrcNet
    }

    // uint32 DstNet = 17;

    pub fn clear_DstNet(&mut self) {
        self.DstNet = 0;
    }

    // Param is passed by value, moved
    pub fn set_DstNet(&mut self, v: u32) {
        self.DstNet = v;
    }

    pub fn get_DstNet(&self) -> u32 {
        self.DstNet
    }

    // bool HasEncap = 43;

    pub fn clear_HasEncap(&mut self) {
        self.HasEncap = false;
    }

    // Param is passed by value, moved
    pub fn set_HasEncap(&mut self, v: bool) {
        self.HasEncap = v;
    }

    pub fn get_HasEncap(&self) -> bool {
        self.HasEncap
    }

    // bytes SrcAddrEncap = 44;

    pub fn clear_SrcAddrEncap(&mut self) {
        self.SrcAddrEncap.clear();
    }

    // Param is passed by value, moved
    pub fn set_SrcAddrEncap(&mut self, v: ::std::vec::Vec<u8>) {
        self.SrcAddrEncap = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_SrcAddrEncap(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.SrcAddrEncap
    }

    // Take field
    pub fn take_SrcAddrEncap(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.SrcAddrEncap, ::std::vec::Vec::new())
    }

    pub fn get_SrcAddrEncap(&self) -> &[u8] {
        &self.SrcAddrEncap
    }

    // bytes DstAddrEncap = 45;

    pub fn clear_DstAddrEncap(&mut self) {
        self.DstAddrEncap.clear();
    }

    // Param is passed by value, moved
    pub fn set_DstAddrEncap(&mut self, v: ::std::vec::Vec<u8>) {
        self.DstAddrEncap = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_DstAddrEncap(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.DstAddrEncap
    }

    // Take field
    pub fn take_DstAddrEncap(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.DstAddrEncap, ::std::vec::Vec::new())
    }

    pub fn get_DstAddrEncap(&self) -> &[u8] {
        &self.DstAddrEncap
    }

    // uint32 ProtoEncap = 46;

    pub fn clear_ProtoEncap(&mut self) {
        self.ProtoEncap = 0;
    }

    // Param is passed by value, moved
    pub fn set_ProtoEncap(&mut self, v: u32) {
        self.ProtoEncap = v;
    }

    pub fn get_ProtoEncap(&self) -> u32 {
        self.ProtoEncap
    }

    // uint32 EtypeEncap = 47;

    pub fn clear_EtypeEncap(&mut self) {
        self.EtypeEncap = 0;
    }

    // Param is passed by value, moved
    pub fn set_EtypeEncap(&mut self, v: u32) {
        self.EtypeEncap = v;
    }

    pub fn get_EtypeEncap(&self) -> u32 {
        self.EtypeEncap
    }

    // uint32 IPTosEncap = 48;

    pub fn clear_IPTosEncap(&mut self) {
        self.IPTosEncap = 0;
    }

    // Param is passed by value, moved
    pub fn set_IPTosEncap(&mut self, v: u32) {
        self.IPTosEncap = v;
    }

    pub fn get_IPTosEncap(&self) -> u32 {
        self.IPTosEncap
    }

    // uint32 IPTTLEncap = 49;

    pub fn clear_IPTTLEncap(&mut self) {
        self.IPTTLEncap = 0;
    }

    // Param is passed by value, moved
    pub fn set_IPTTLEncap(&mut self, v: u32) {
        self.IPTTLEncap = v;
    }

    pub fn get_IPTTLEncap(&self) -> u32 {
        self.IPTTLEncap
    }

    // uint32 IPv6FlowLabelEncap = 50;

    pub fn clear_IPv6FlowLabelEncap(&mut self) {
        self.IPv6FlowLabelEncap = 0;
    }

    // Param is passed by value, moved
    pub fn set_IPv6FlowLabelEncap(&mut self, v: u32) {
        self.IPv6FlowLabelEncap = v;
    }

    pub fn get_IPv6FlowLabelEncap(&self) -> u32 {
        self.IPv6FlowLabelEncap
    }

    // uint32 FragmentIdEncap = 51;

    pub fn clear_FragmentIdEncap(&mut self) {
        self.FragmentIdEncap = 0;
    }

    // Param is passed by value, moved
    pub fn set_FragmentIdEncap(&mut self, v: u32) {
        self.FragmentIdEncap = v;
    }

    pub fn get_FragmentIdEncap(&self) -> u32 {
        self.FragmentIdEncap
    }

    // uint32 FragmentOffsetEncap = 52;

    pub fn clear_FragmentOffsetEncap(&mut self) {
        self.FragmentOffsetEncap = 0;
    }

    // Param is passed by value, moved
    pub fn set_FragmentOffsetEncap(&mut self, v: u32) {
        self.FragmentOffsetEncap = v;
    }

    pub fn get_FragmentOffsetEncap(&self) -> u32 {
        self.FragmentOffsetEncap
    }

    // bool HasMPLS = 53;

    pub fn clear_HasMPLS(&mut self) {
        self.HasMPLS = false;
    }

    // Param is passed by value, moved
    pub fn set_HasMPLS(&mut self, v: bool) {
        self.HasMPLS = v;
    }

    pub fn get_HasMPLS(&self) -> bool {
        self.HasMPLS
    }

    // uint32 MPLSCount = 54;

    pub fn clear_MPLSCount(&mut self) {
        self.MPLSCount = 0;
    }

    // Param is passed by value, moved
    pub fn set_MPLSCount(&mut self, v: u32) {
        self.MPLSCount = v;
    }

    pub fn get_MPLSCount(&self) -> u32 {
        self.MPLSCount
    }

    // uint32 MPLS1TTL = 55;

    pub fn clear_MPLS1TTL(&mut self) {
        self.MPLS1TTL = 0;
    }

    // Param is passed by value, moved
    pub fn set_MPLS1TTL(&mut self, v: u32) {
        self.MPLS1TTL = v;
    }

    pub fn get_MPLS1TTL(&self) -> u32 {
        self.MPLS1TTL
    }

    // uint32 MPLS1Label = 56;

    pub fn clear_MPLS1Label(&mut self) {
        self.MPLS1Label = 0;
    }

    // Param is passed by value, moved
    pub fn set_MPLS1Label(&mut self, v: u32) {
        self.MPLS1Label = v;
    }

    pub fn get_MPLS1Label(&self) -> u32 {
        self.MPLS1Label
    }

    // uint32 MPLS2TTL = 57;

    pub fn clear_MPLS2TTL(&mut self) {
        self.MPLS2TTL = 0;
    }

    // Param is passed by value, moved
    pub fn set_MPLS2TTL(&mut self, v: u32) {
        self.MPLS2TTL = v;
    }

    pub fn get_MPLS2TTL(&self) -> u32 {
        self.MPLS2TTL
    }

    // uint32 MPLS2Label = 58;

    pub fn clear_MPLS2Label(&mut self) {
        self.MPLS2Label = 0;
    }

    // Param is passed by value, moved
    pub fn set_MPLS2Label(&mut self, v: u32) {
        self.MPLS2Label = v;
    }

    pub fn get_MPLS2Label(&self) -> u32 {
        self.MPLS2Label
    }

    // uint32 MPLS3TTL = 59;

    pub fn clear_MPLS3TTL(&mut self) {
        self.MPLS3TTL = 0;
    }

    // Param is passed by value, moved
    pub fn set_MPLS3TTL(&mut self, v: u32) {
        self.MPLS3TTL = v;
    }

    pub fn get_MPLS3TTL(&self) -> u32 {
        self.MPLS3TTL
    }

    // uint32 MPLS3Label = 60;

    pub fn clear_MPLS3Label(&mut self) {
        self.MPLS3Label = 0;
    }

    // Param is passed by value, moved
    pub fn set_MPLS3Label(&mut self, v: u32) {
        self.MPLS3Label = v;
    }

    pub fn get_MPLS3Label(&self) -> u32 {
        self.MPLS3Label
    }

    // uint32 MPLSLastTTL = 61;

    pub fn clear_MPLSLastTTL(&mut self) {
        self.MPLSLastTTL = 0;
    }

    // Param is passed by value, moved
    pub fn set_MPLSLastTTL(&mut self, v: u32) {
        self.MPLSLastTTL = v;
    }

    pub fn get_MPLSLastTTL(&self) -> u32 {
        self.MPLSLastTTL
    }

    // uint32 MPLSLastLabel = 62;

    pub fn clear_MPLSLastLabel(&mut self) {
        self.MPLSLastLabel = 0;
    }

    // Param is passed by value, moved
    pub fn set_MPLSLastLabel(&mut self, v: u32) {
        self.MPLSLastLabel = v;
    }

    pub fn get_MPLSLastLabel(&self) -> u32 {
        self.MPLSLastLabel
    }

    // bool HasPPP = 63;

    pub fn clear_HasPPP(&mut self) {
        self.HasPPP = false;
    }

    // Param is passed by value, moved
    pub fn set_HasPPP(&mut self, v: bool) {
        self.HasPPP = v;
    }

    pub fn get_HasPPP(&self) -> bool {
        self.HasPPP
    }

    // uint32 PPPAddressControl = 64;

    pub fn clear_PPPAddressControl(&mut self) {
        self.PPPAddressControl = 0;
    }

    // Param is passed by value, moved
    pub fn set_PPPAddressControl(&mut self, v: u32) {
        self.PPPAddressControl = v;
    }

    pub fn get_PPPAddressControl(&self) -> u32 {
        self.PPPAddressControl
    }

    // uint32 Cid = 1000;

    pub fn clear_Cid(&mut self) {
        self.Cid = 0;
    }

    // Param is passed by value, moved
    pub fn set_Cid(&mut self, v: u32) {
        self.Cid = v;
    }

    pub fn get_Cid(&self) -> u32 {
        self.Cid
    }

    // string CidString = 1001;

    pub fn clear_CidString(&mut self) {
        self.CidString.clear();
    }

    // Param is passed by value, moved
    pub fn set_CidString(&mut self, v: ::std::string::String) {
        self.CidString = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_CidString(&mut self) -> &mut ::std::string::String {
        &mut self.CidString
    }

    // Take field
    pub fn take_CidString(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.CidString, ::std::string::String::new())
    }

    pub fn get_CidString(&self) -> &str {
        &self.CidString
    }

    // .flowmessageenriched.FlowMessage.NormalizedType Normalized = 1002;

    pub fn clear_Normalized(&mut self) {
        self.Normalized = FlowMessage_NormalizedType::No;
    }

    // Param is passed by value, moved
    pub fn set_Normalized(&mut self, v: FlowMessage_NormalizedType) {
        self.Normalized = v;
    }

    pub fn get_Normalized(&self) -> FlowMessage_NormalizedType {
        self.Normalized
    }

    // string SrcIfName = 1003;

    pub fn clear_SrcIfName(&mut self) {
        self.SrcIfName.clear();
    }

    // Param is passed by value, moved
    pub fn set_SrcIfName(&mut self, v: ::std::string::String) {
        self.SrcIfName = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_SrcIfName(&mut self) -> &mut ::std::string::String {
        &mut self.SrcIfName
    }

    // Take field
    pub fn take_SrcIfName(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.SrcIfName, ::std::string::String::new())
    }

    pub fn get_SrcIfName(&self) -> &str {
        &self.SrcIfName
    }

    // string SrcIfDesc = 1004;

    pub fn clear_SrcIfDesc(&mut self) {
        self.SrcIfDesc.clear();
    }

    // Param is passed by value, moved
    pub fn set_SrcIfDesc(&mut self, v: ::std::string::String) {
        self.SrcIfDesc = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_SrcIfDesc(&mut self) -> &mut ::std::string::String {
        &mut self.SrcIfDesc
    }

    // Take field
    pub fn take_SrcIfDesc(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.SrcIfDesc, ::std::string::String::new())
    }

    pub fn get_SrcIfDesc(&self) -> &str {
        &self.SrcIfDesc
    }

    // uint32 SrcIfSpeed = 1005;

    pub fn clear_SrcIfSpeed(&mut self) {
        self.SrcIfSpeed = 0;
    }

    // Param is passed by value, moved
    pub fn set_SrcIfSpeed(&mut self, v: u32) {
        self.SrcIfSpeed = v;
    }

    pub fn get_SrcIfSpeed(&self) -> u32 {
        self.SrcIfSpeed
    }

    // string DstIfName = 1006;

    pub fn clear_DstIfName(&mut self) {
        self.DstIfName.clear();
    }

    // Param is passed by value, moved
    pub fn set_DstIfName(&mut self, v: ::std::string::String) {
        self.DstIfName = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_DstIfName(&mut self) -> &mut ::std::string::String {
        &mut self.DstIfName
    }

    // Take field
    pub fn take_DstIfName(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.DstIfName, ::std::string::String::new())
    }

    pub fn get_DstIfName(&self) -> &str {
        &self.DstIfName
    }

    // string DstIfDesc = 1007;

    pub fn clear_DstIfDesc(&mut self) {
        self.DstIfDesc.clear();
    }

    // Param is passed by value, moved
    pub fn set_DstIfDesc(&mut self, v: ::std::string::String) {
        self.DstIfDesc = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_DstIfDesc(&mut self) -> &mut ::std::string::String {
        &mut self.DstIfDesc
    }

    // Take field
    pub fn take_DstIfDesc(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.DstIfDesc, ::std::string::String::new())
    }

    pub fn get_DstIfDesc(&self) -> &str {
        &self.DstIfDesc
    }

    // uint32 DstIfSpeed = 1008;

    pub fn clear_DstIfSpeed(&mut self) {
        self.DstIfSpeed = 0;
    }

    // Param is passed by value, moved
    pub fn set_DstIfSpeed(&mut self, v: u32) {
        self.DstIfSpeed = v;
    }

    pub fn get_DstIfSpeed(&self) -> u32 {
        self.DstIfSpeed
    }

    // string ProtoName = 1009;

    pub fn clear_ProtoName(&mut self) {
        self.ProtoName.clear();
    }

    // Param is passed by value, moved
    pub fn set_ProtoName(&mut self, v: ::std::string::String) {
        self.ProtoName = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_ProtoName(&mut self) -> &mut ::std::string::String {
        &mut self.ProtoName
    }

    // Take field
    pub fn take_ProtoName(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.ProtoName, ::std::string::String::new())
    }

    pub fn get_ProtoName(&self) -> &str {
        &self.ProtoName
    }

    // string RemoteCountry = 1010;

    pub fn clear_RemoteCountry(&mut self) {
        self.RemoteCountry.clear();
    }

    // Param is passed by value, moved
    pub fn set_RemoteCountry(&mut self, v: ::std::string::String) {
        self.RemoteCountry = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_RemoteCountry(&mut self) -> &mut ::std::string::String {
        &mut self.RemoteCountry
    }

    // Take field
    pub fn take_RemoteCountry(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.RemoteCountry, ::std::string::String::new())
    }

    pub fn get_RemoteCountry(&self) -> &str {
        &self.RemoteCountry
    }
}

impl ::protobuf::Message for FlowMessage {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.Type, 1, &mut self.unknown_fields)?
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.TimeReceived = tmp;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.SequenceNum = tmp;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.SamplingRate = tmp;
                },
                42 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.FlowDirection = tmp;
                },
                11 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.SamplerAddress)?;
                },
                38 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.TimeFlowStart = tmp;
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.TimeFlowEnd = tmp;
                },
                9 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.Bytes = tmp;
                },
                10 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.Packets = tmp;
                },
                6 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.SrcAddr)?;
                },
                7 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.DstAddr)?;
                },
                30 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.Etype = tmp;
                },
                20 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.Proto = tmp;
                },
                21 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.SrcPort = tmp;
                },
                22 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.DstPort = tmp;
                },
                18 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.InIf = tmp;
                },
                19 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.OutIf = tmp;
                },
                27 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.SrcMac = tmp;
                },
                28 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.DstMac = tmp;
                },
                33 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.SrcVlan = tmp;
                },
                34 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.DstVlan = tmp;
                },
                29 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.VlanId = tmp;
                },
                39 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.IngressVrfID = tmp;
                },
                40 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.EgressVrfID = tmp;
                },
                23 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.IPTos = tmp;
                },
                24 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.ForwardingStatus = tmp;
                },
                25 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.IPTTL = tmp;
                },
                26 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.TCPFlags = tmp;
                },
                31 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.IcmpType = tmp;
                },
                32 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.IcmpCode = tmp;
                },
                37 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.IPv6FlowLabel = tmp;
                },
                35 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.FragmentId = tmp;
                },
                36 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.FragmentOffset = tmp;
                },
                41 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.BiFlowDirection = tmp;
                },
                14 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.SrcAS = tmp;
                },
                15 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.DstAS = tmp;
                },
                12 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.NextHop)?;
                },
                13 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.NextHopAS = tmp;
                },
                16 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.SrcNet = tmp;
                },
                17 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.DstNet = tmp;
                },
                43 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.HasEncap = tmp;
                },
                44 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.SrcAddrEncap)?;
                },
                45 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.DstAddrEncap)?;
                },
                46 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.ProtoEncap = tmp;
                },
                47 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.EtypeEncap = tmp;
                },
                48 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.IPTosEncap = tmp;
                },
                49 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.IPTTLEncap = tmp;
                },
                50 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.IPv6FlowLabelEncap = tmp;
                },
                51 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.FragmentIdEncap = tmp;
                },
                52 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.FragmentOffsetEncap = tmp;
                },
                53 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.HasMPLS = tmp;
                },
                54 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.MPLSCount = tmp;
                },
                55 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.MPLS1TTL = tmp;
                },
                56 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.MPLS1Label = tmp;
                },
                57 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.MPLS2TTL = tmp;
                },
                58 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.MPLS2Label = tmp;
                },
                59 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.MPLS3TTL = tmp;
                },
                60 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.MPLS3Label = tmp;
                },
                61 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.MPLSLastTTL = tmp;
                },
                62 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.MPLSLastLabel = tmp;
                },
                63 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.HasPPP = tmp;
                },
                64 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.PPPAddressControl = tmp;
                },
                1000 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.Cid = tmp;
                },
                1001 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.CidString)?;
                },
                1002 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.Normalized, 1002, &mut self.unknown_fields)?
                },
                1003 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.SrcIfName)?;
                },
                1004 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.SrcIfDesc)?;
                },
                1005 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.SrcIfSpeed = tmp;
                },
                1006 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.DstIfName)?;
                },
                1007 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.DstIfDesc)?;
                },
                1008 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.DstIfSpeed = tmp;
                },
                1009 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.ProtoName)?;
                },
                1010 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.RemoteCountry)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.Type != FlowMessage_FlowType::FLOWUNKNOWN {
            my_size += ::protobuf::rt::enum_size(1, self.Type);
        }
        if self.TimeReceived != 0 {
            my_size += ::protobuf::rt::value_size(2, self.TimeReceived, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.SequenceNum != 0 {
            my_size += ::protobuf::rt::value_size(4, self.SequenceNum, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.SamplingRate != 0 {
            my_size += ::protobuf::rt::value_size(3, self.SamplingRate, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.FlowDirection != 0 {
            my_size += ::protobuf::rt::value_size(42, self.FlowDirection, ::protobuf::wire_format::WireTypeVarint);
        }
        if !self.SamplerAddress.is_empty() {
            my_size += ::protobuf::rt::bytes_size(11, &self.SamplerAddress);
        }
        if self.TimeFlowStart != 0 {
            my_size += ::protobuf::rt::value_size(38, self.TimeFlowStart, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.TimeFlowEnd != 0 {
            my_size += ::protobuf::rt::value_size(5, self.TimeFlowEnd, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.Bytes != 0 {
            my_size += ::protobuf::rt::value_size(9, self.Bytes, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.Packets != 0 {
            my_size += ::protobuf::rt::value_size(10, self.Packets, ::protobuf::wire_format::WireTypeVarint);
        }
        if !self.SrcAddr.is_empty() {
            my_size += ::protobuf::rt::bytes_size(6, &self.SrcAddr);
        }
        if !self.DstAddr.is_empty() {
            my_size += ::protobuf::rt::bytes_size(7, &self.DstAddr);
        }
        if self.Etype != 0 {
            my_size += ::protobuf::rt::value_size(30, self.Etype, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.Proto != 0 {
            my_size += ::protobuf::rt::value_size(20, self.Proto, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.SrcPort != 0 {
            my_size += ::protobuf::rt::value_size(21, self.SrcPort, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.DstPort != 0 {
            my_size += ::protobuf::rt::value_size(22, self.DstPort, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.InIf != 0 {
            my_size += ::protobuf::rt::value_size(18, self.InIf, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.OutIf != 0 {
            my_size += ::protobuf::rt::value_size(19, self.OutIf, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.SrcMac != 0 {
            my_size += ::protobuf::rt::value_size(27, self.SrcMac, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.DstMac != 0 {
            my_size += ::protobuf::rt::value_size(28, self.DstMac, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.SrcVlan != 0 {
            my_size += ::protobuf::rt::value_size(33, self.SrcVlan, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.DstVlan != 0 {
            my_size += ::protobuf::rt::value_size(34, self.DstVlan, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.VlanId != 0 {
            my_size += ::protobuf::rt::value_size(29, self.VlanId, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.IngressVrfID != 0 {
            my_size += ::protobuf::rt::value_size(39, self.IngressVrfID, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.EgressVrfID != 0 {
            my_size += ::protobuf::rt::value_size(40, self.EgressVrfID, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.IPTos != 0 {
            my_size += ::protobuf::rt::value_size(23, self.IPTos, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.ForwardingStatus != 0 {
            my_size += ::protobuf::rt::value_size(24, self.ForwardingStatus, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.IPTTL != 0 {
            my_size += ::protobuf::rt::value_size(25, self.IPTTL, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.TCPFlags != 0 {
            my_size += ::protobuf::rt::value_size(26, self.TCPFlags, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.IcmpType != 0 {
            my_size += ::protobuf::rt::value_size(31, self.IcmpType, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.IcmpCode != 0 {
            my_size += ::protobuf::rt::value_size(32, self.IcmpCode, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.IPv6FlowLabel != 0 {
            my_size += ::protobuf::rt::value_size(37, self.IPv6FlowLabel, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.FragmentId != 0 {
            my_size += ::protobuf::rt::value_size(35, self.FragmentId, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.FragmentOffset != 0 {
            my_size += ::protobuf::rt::value_size(36, self.FragmentOffset, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.BiFlowDirection != 0 {
            my_size += ::protobuf::rt::value_size(41, self.BiFlowDirection, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.SrcAS != 0 {
            my_size += ::protobuf::rt::value_size(14, self.SrcAS, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.DstAS != 0 {
            my_size += ::protobuf::rt::value_size(15, self.DstAS, ::protobuf::wire_format::WireTypeVarint);
        }
        if !self.NextHop.is_empty() {
            my_size += ::protobuf::rt::bytes_size(12, &self.NextHop);
        }
        if self.NextHopAS != 0 {
            my_size += ::protobuf::rt::value_size(13, self.NextHopAS, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.SrcNet != 0 {
            my_size += ::protobuf::rt::value_size(16, self.SrcNet, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.DstNet != 0 {
            my_size += ::protobuf::rt::value_size(17, self.DstNet, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.HasEncap != false {
            my_size += 3;
        }
        if !self.SrcAddrEncap.is_empty() {
            my_size += ::protobuf::rt::bytes_size(44, &self.SrcAddrEncap);
        }
        if !self.DstAddrEncap.is_empty() {
            my_size += ::protobuf::rt::bytes_size(45, &self.DstAddrEncap);
        }
        if self.ProtoEncap != 0 {
            my_size += ::protobuf::rt::value_size(46, self.ProtoEncap, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.EtypeEncap != 0 {
            my_size += ::protobuf::rt::value_size(47, self.EtypeEncap, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.IPTosEncap != 0 {
            my_size += ::protobuf::rt::value_size(48, self.IPTosEncap, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.IPTTLEncap != 0 {
            my_size += ::protobuf::rt::value_size(49, self.IPTTLEncap, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.IPv6FlowLabelEncap != 0 {
            my_size += ::protobuf::rt::value_size(50, self.IPv6FlowLabelEncap, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.FragmentIdEncap != 0 {
            my_size += ::protobuf::rt::value_size(51, self.FragmentIdEncap, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.FragmentOffsetEncap != 0 {
            my_size += ::protobuf::rt::value_size(52, self.FragmentOffsetEncap, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.HasMPLS != false {
            my_size += 3;
        }
        if self.MPLSCount != 0 {
            my_size += ::protobuf::rt::value_size(54, self.MPLSCount, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.MPLS1TTL != 0 {
            my_size += ::protobuf::rt::value_size(55, self.MPLS1TTL, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.MPLS1Label != 0 {
            my_size += ::protobuf::rt::value_size(56, self.MPLS1Label, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.MPLS2TTL != 0 {
            my_size += ::protobuf::rt::value_size(57, self.MPLS2TTL, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.MPLS2Label != 0 {
            my_size += ::protobuf::rt::value_size(58, self.MPLS2Label, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.MPLS3TTL != 0 {
            my_size += ::protobuf::rt::value_size(59, self.MPLS3TTL, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.MPLS3Label != 0 {
            my_size += ::protobuf::rt::value_size(60, self.MPLS3Label, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.MPLSLastTTL != 0 {
            my_size += ::protobuf::rt::value_size(61, self.MPLSLastTTL, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.MPLSLastLabel != 0 {
            my_size += ::protobuf::rt::value_size(62, self.MPLSLastLabel, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.HasPPP != false {
            my_size += 3;
        }
        if self.PPPAddressControl != 0 {
            my_size += ::protobuf::rt::value_size(64, self.PPPAddressControl, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.Cid != 0 {
            my_size += ::protobuf::rt::value_size(1000, self.Cid, ::protobuf::wire_format::WireTypeVarint);
        }
        if !self.CidString.is_empty() {
            my_size += ::protobuf::rt::string_size(1001, &self.CidString);
        }
        if self.Normalized != FlowMessage_NormalizedType::No {
            my_size += ::protobuf::rt::enum_size(1002, self.Normalized);
        }
        if !self.SrcIfName.is_empty() {
            my_size += ::protobuf::rt::string_size(1003, &self.SrcIfName);
        }
        if !self.SrcIfDesc.is_empty() {
            my_size += ::protobuf::rt::string_size(1004, &self.SrcIfDesc);
        }
        if self.SrcIfSpeed != 0 {
            my_size += ::protobuf::rt::value_size(1005, self.SrcIfSpeed, ::protobuf::wire_format::WireTypeVarint);
        }
        if !self.DstIfName.is_empty() {
            my_size += ::protobuf::rt::string_size(1006, &self.DstIfName);
        }
        if !self.DstIfDesc.is_empty() {
            my_size += ::protobuf::rt::string_size(1007, &self.DstIfDesc);
        }
        if self.DstIfSpeed != 0 {
            my_size += ::protobuf::rt::value_size(1008, self.DstIfSpeed, ::protobuf::wire_format::WireTypeVarint);
        }
        if !self.ProtoName.is_empty() {
            my_size += ::protobuf::rt::string_size(1009, &self.ProtoName);
        }
        if !self.RemoteCountry.is_empty() {
            my_size += ::protobuf::rt::string_size(1010, &self.RemoteCountry);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if self.Type != FlowMessage_FlowType::FLOWUNKNOWN {
            os.write_enum(1, self.Type.value())?;
        }
        if self.TimeReceived != 0 {
            os.write_uint64(2, self.TimeReceived)?;
        }
        if self.SequenceNum != 0 {
            os.write_uint32(4, self.SequenceNum)?;
        }
        if self.SamplingRate != 0 {
            os.write_uint64(3, self.SamplingRate)?;
        }
        if self.FlowDirection != 0 {
            os.write_uint32(42, self.FlowDirection)?;
        }
        if !self.SamplerAddress.is_empty() {
            os.write_bytes(11, &self.SamplerAddress)?;
        }
        if self.TimeFlowStart != 0 {
            os.write_uint64(38, self.TimeFlowStart)?;
        }
        if self.TimeFlowEnd != 0 {
            os.write_uint64(5, self.TimeFlowEnd)?;
        }
        if self.Bytes != 0 {
            os.write_uint64(9, self.Bytes)?;
        }
        if self.Packets != 0 {
            os.write_uint64(10, self.Packets)?;
        }
        if !self.SrcAddr.is_empty() {
            os.write_bytes(6, &self.SrcAddr)?;
        }
        if !self.DstAddr.is_empty() {
            os.write_bytes(7, &self.DstAddr)?;
        }
        if self.Etype != 0 {
            os.write_uint32(30, self.Etype)?;
        }
        if self.Proto != 0 {
            os.write_uint32(20, self.Proto)?;
        }
        if self.SrcPort != 0 {
            os.write_uint32(21, self.SrcPort)?;
        }
        if self.DstPort != 0 {
            os.write_uint32(22, self.DstPort)?;
        }
        if self.InIf != 0 {
            os.write_uint32(18, self.InIf)?;
        }
        if self.OutIf != 0 {
            os.write_uint32(19, self.OutIf)?;
        }
        if self.SrcMac != 0 {
            os.write_uint64(27, self.SrcMac)?;
        }
        if self.DstMac != 0 {
            os.write_uint64(28, self.DstMac)?;
        }
        if self.SrcVlan != 0 {
            os.write_uint32(33, self.SrcVlan)?;
        }
        if self.DstVlan != 0 {
            os.write_uint32(34, self.DstVlan)?;
        }
        if self.VlanId != 0 {
            os.write_uint32(29, self.VlanId)?;
        }
        if self.IngressVrfID != 0 {
            os.write_uint32(39, self.IngressVrfID)?;
        }
        if self.EgressVrfID != 0 {
            os.write_uint32(40, self.EgressVrfID)?;
        }
        if self.IPTos != 0 {
            os.write_uint32(23, self.IPTos)?;
        }
        if self.ForwardingStatus != 0 {
            os.write_uint32(24, self.ForwardingStatus)?;
        }
        if self.IPTTL != 0 {
            os.write_uint32(25, self.IPTTL)?;
        }
        if self.TCPFlags != 0 {
            os.write_uint32(26, self.TCPFlags)?;
        }
        if self.IcmpType != 0 {
            os.write_uint32(31, self.IcmpType)?;
        }
        if self.IcmpCode != 0 {
            os.write_uint32(32, self.IcmpCode)?;
        }
        if self.IPv6FlowLabel != 0 {
            os.write_uint32(37, self.IPv6FlowLabel)?;
        }
        if self.FragmentId != 0 {
            os.write_uint32(35, self.FragmentId)?;
        }
        if self.FragmentOffset != 0 {
            os.write_uint32(36, self.FragmentOffset)?;
        }
        if self.BiFlowDirection != 0 {
            os.write_uint32(41, self.BiFlowDirection)?;
        }
        if self.SrcAS != 0 {
            os.write_uint32(14, self.SrcAS)?;
        }
        if self.DstAS != 0 {
            os.write_uint32(15, self.DstAS)?;
        }
        if !self.NextHop.is_empty() {
            os.write_bytes(12, &self.NextHop)?;
        }
        if self.NextHopAS != 0 {
            os.write_uint32(13, self.NextHopAS)?;
        }
        if self.SrcNet != 0 {
            os.write_uint32(16, self.SrcNet)?;
        }
        if self.DstNet != 0 {
            os.write_uint32(17, self.DstNet)?;
        }
        if self.HasEncap != false {
            os.write_bool(43, self.HasEncap)?;
        }
        if !self.SrcAddrEncap.is_empty() {
            os.write_bytes(44, &self.SrcAddrEncap)?;
        }
        if !self.DstAddrEncap.is_empty() {
            os.write_bytes(45, &self.DstAddrEncap)?;
        }
        if self.ProtoEncap != 0 {
            os.write_uint32(46, self.ProtoEncap)?;
        }
        if self.EtypeEncap != 0 {
            os.write_uint32(47, self.EtypeEncap)?;
        }
        if self.IPTosEncap != 0 {
            os.write_uint32(48, self.IPTosEncap)?;
        }
        if self.IPTTLEncap != 0 {
            os.write_uint32(49, self.IPTTLEncap)?;
        }
        if self.IPv6FlowLabelEncap != 0 {
            os.write_uint32(50, self.IPv6FlowLabelEncap)?;
        }
        if self.FragmentIdEncap != 0 {
            os.write_uint32(51, self.FragmentIdEncap)?;
        }
        if self.FragmentOffsetEncap != 0 {
            os.write_uint32(52, self.FragmentOffsetEncap)?;
        }
        if self.HasMPLS != false {
            os.write_bool(53, self.HasMPLS)?;
        }
        if self.MPLSCount != 0 {
            os.write_uint32(54, self.MPLSCount)?;
        }
        if self.MPLS1TTL != 0 {
            os.write_uint32(55, self.MPLS1TTL)?;
        }
        if self.MPLS1Label != 0 {
            os.write_uint32(56, self.MPLS1Label)?;
        }
        if self.MPLS2TTL != 0 {
            os.write_uint32(57, self.MPLS2TTL)?;
        }
        if self.MPLS2Label != 0 {
            os.write_uint32(58, self.MPLS2Label)?;
        }
        if self.MPLS3TTL != 0 {
            os.write_uint32(59, self.MPLS3TTL)?;
        }
        if self.MPLS3Label != 0 {
            os.write_uint32(60, self.MPLS3Label)?;
        }
        if self.MPLSLastTTL != 0 {
            os.write_uint32(61, self.MPLSLastTTL)?;
        }
        if self.MPLSLastLabel != 0 {
            os.write_uint32(62, self.MPLSLastLabel)?;
        }
        if self.HasPPP != false {
            os.write_bool(63, self.HasPPP)?;
        }
        if self.PPPAddressControl != 0 {
            os.write_uint32(64, self.PPPAddressControl)?;
        }
        if self.Cid != 0 {
            os.write_uint32(1000, self.Cid)?;
        }
        if !self.CidString.is_empty() {
            os.write_string(1001, &self.CidString)?;
        }
        if self.Normalized != FlowMessage_NormalizedType::No {
            os.write_enum(1002, self.Normalized.value())?;
        }
        if !self.SrcIfName.is_empty() {
            os.write_string(1003, &self.SrcIfName)?;
        }
        if !self.SrcIfDesc.is_empty() {
            os.write_string(1004, &self.SrcIfDesc)?;
        }
        if self.SrcIfSpeed != 0 {
            os.write_uint32(1005, self.SrcIfSpeed)?;
        }
        if !self.DstIfName.is_empty() {
            os.write_string(1006, &self.DstIfName)?;
        }
        if !self.DstIfDesc.is_empty() {
            os.write_string(1007, &self.DstIfDesc)?;
        }
        if self.DstIfSpeed != 0 {
            os.write_uint32(1008, self.DstIfSpeed)?;
        }
        if !self.ProtoName.is_empty() {
            os.write_string(1009, &self.ProtoName)?;
        }
        if !self.RemoteCountry.is_empty() {
            os.write_string(1010, &self.RemoteCountry)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> FlowMessage {
        FlowMessage::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<FlowMessage_FlowType>>(
                    "Type",
                    |m: &FlowMessage| { &m.Type },
                    |m: &mut FlowMessage| { &mut m.Type },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "TimeReceived",
                    |m: &FlowMessage| { &m.TimeReceived },
                    |m: &mut FlowMessage| { &mut m.TimeReceived },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "SequenceNum",
                    |m: &FlowMessage| { &m.SequenceNum },
                    |m: &mut FlowMessage| { &mut m.SequenceNum },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "SamplingRate",
                    |m: &FlowMessage| { &m.SamplingRate },
                    |m: &mut FlowMessage| { &mut m.SamplingRate },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "FlowDirection",
                    |m: &FlowMessage| { &m.FlowDirection },
                    |m: &mut FlowMessage| { &mut m.FlowDirection },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "SamplerAddress",
                    |m: &FlowMessage| { &m.SamplerAddress },
                    |m: &mut FlowMessage| { &mut m.SamplerAddress },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "TimeFlowStart",
                    |m: &FlowMessage| { &m.TimeFlowStart },
                    |m: &mut FlowMessage| { &mut m.TimeFlowStart },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "TimeFlowEnd",
                    |m: &FlowMessage| { &m.TimeFlowEnd },
                    |m: &mut FlowMessage| { &mut m.TimeFlowEnd },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "Bytes",
                    |m: &FlowMessage| { &m.Bytes },
                    |m: &mut FlowMessage| { &mut m.Bytes },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "Packets",
                    |m: &FlowMessage| { &m.Packets },
                    |m: &mut FlowMessage| { &mut m.Packets },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "SrcAddr",
                    |m: &FlowMessage| { &m.SrcAddr },
                    |m: &mut FlowMessage| { &mut m.SrcAddr },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "DstAddr",
                    |m: &FlowMessage| { &m.DstAddr },
                    |m: &mut FlowMessage| { &mut m.DstAddr },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "Etype",
                    |m: &FlowMessage| { &m.Etype },
                    |m: &mut FlowMessage| { &mut m.Etype },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "Proto",
                    |m: &FlowMessage| { &m.Proto },
                    |m: &mut FlowMessage| { &mut m.Proto },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "SrcPort",
                    |m: &FlowMessage| { &m.SrcPort },
                    |m: &mut FlowMessage| { &mut m.SrcPort },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "DstPort",
                    |m: &FlowMessage| { &m.DstPort },
                    |m: &mut FlowMessage| { &mut m.DstPort },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "InIf",
                    |m: &FlowMessage| { &m.InIf },
                    |m: &mut FlowMessage| { &mut m.InIf },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "OutIf",
                    |m: &FlowMessage| { &m.OutIf },
                    |m: &mut FlowMessage| { &mut m.OutIf },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "SrcMac",
                    |m: &FlowMessage| { &m.SrcMac },
                    |m: &mut FlowMessage| { &mut m.SrcMac },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "DstMac",
                    |m: &FlowMessage| { &m.DstMac },
                    |m: &mut FlowMessage| { &mut m.DstMac },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "SrcVlan",
                    |m: &FlowMessage| { &m.SrcVlan },
                    |m: &mut FlowMessage| { &mut m.SrcVlan },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "DstVlan",
                    |m: &FlowMessage| { &m.DstVlan },
                    |m: &mut FlowMessage| { &mut m.DstVlan },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "VlanId",
                    |m: &FlowMessage| { &m.VlanId },
                    |m: &mut FlowMessage| { &mut m.VlanId },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "IngressVrfID",
                    |m: &FlowMessage| { &m.IngressVrfID },
                    |m: &mut FlowMessage| { &mut m.IngressVrfID },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "EgressVrfID",
                    |m: &FlowMessage| { &m.EgressVrfID },
                    |m: &mut FlowMessage| { &mut m.EgressVrfID },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "IPTos",
                    |m: &FlowMessage| { &m.IPTos },
                    |m: &mut FlowMessage| { &mut m.IPTos },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "ForwardingStatus",
                    |m: &FlowMessage| { &m.ForwardingStatus },
                    |m: &mut FlowMessage| { &mut m.ForwardingStatus },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "IPTTL",
                    |m: &FlowMessage| { &m.IPTTL },
                    |m: &mut FlowMessage| { &mut m.IPTTL },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "TCPFlags",
                    |m: &FlowMessage| { &m.TCPFlags },
                    |m: &mut FlowMessage| { &mut m.TCPFlags },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "IcmpType",
                    |m: &FlowMessage| { &m.IcmpType },
                    |m: &mut FlowMessage| { &mut m.IcmpType },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "IcmpCode",
                    |m: &FlowMessage| { &m.IcmpCode },
                    |m: &mut FlowMessage| { &mut m.IcmpCode },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "IPv6FlowLabel",
                    |m: &FlowMessage| { &m.IPv6FlowLabel },
                    |m: &mut FlowMessage| { &mut m.IPv6FlowLabel },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "FragmentId",
                    |m: &FlowMessage| { &m.FragmentId },
                    |m: &mut FlowMessage| { &mut m.FragmentId },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "FragmentOffset",
                    |m: &FlowMessage| { &m.FragmentOffset },
                    |m: &mut FlowMessage| { &mut m.FragmentOffset },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "BiFlowDirection",
                    |m: &FlowMessage| { &m.BiFlowDirection },
                    |m: &mut FlowMessage| { &mut m.BiFlowDirection },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "SrcAS",
                    |m: &FlowMessage| { &m.SrcAS },
                    |m: &mut FlowMessage| { &mut m.SrcAS },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "DstAS",
                    |m: &FlowMessage| { &m.DstAS },
                    |m: &mut FlowMessage| { &mut m.DstAS },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "NextHop",
                    |m: &FlowMessage| { &m.NextHop },
                    |m: &mut FlowMessage| { &mut m.NextHop },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "NextHopAS",
                    |m: &FlowMessage| { &m.NextHopAS },
                    |m: &mut FlowMessage| { &mut m.NextHopAS },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "SrcNet",
                    |m: &FlowMessage| { &m.SrcNet },
                    |m: &mut FlowMessage| { &mut m.SrcNet },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "DstNet",
                    |m: &FlowMessage| { &m.DstNet },
                    |m: &mut FlowMessage| { &mut m.DstNet },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "HasEncap",
                    |m: &FlowMessage| { &m.HasEncap },
                    |m: &mut FlowMessage| { &mut m.HasEncap },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "SrcAddrEncap",
                    |m: &FlowMessage| { &m.SrcAddrEncap },
                    |m: &mut FlowMessage| { &mut m.SrcAddrEncap },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "DstAddrEncap",
                    |m: &FlowMessage| { &m.DstAddrEncap },
                    |m: &mut FlowMessage| { &mut m.DstAddrEncap },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "ProtoEncap",
                    |m: &FlowMessage| { &m.ProtoEncap },
                    |m: &mut FlowMessage| { &mut m.ProtoEncap },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "EtypeEncap",
                    |m: &FlowMessage| { &m.EtypeEncap },
                    |m: &mut FlowMessage| { &mut m.EtypeEncap },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "IPTosEncap",
                    |m: &FlowMessage| { &m.IPTosEncap },
                    |m: &mut FlowMessage| { &mut m.IPTosEncap },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "IPTTLEncap",
                    |m: &FlowMessage| { &m.IPTTLEncap },
                    |m: &mut FlowMessage| { &mut m.IPTTLEncap },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "IPv6FlowLabelEncap",
                    |m: &FlowMessage| { &m.IPv6FlowLabelEncap },
                    |m: &mut FlowMessage| { &mut m.IPv6FlowLabelEncap },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "FragmentIdEncap",
                    |m: &FlowMessage| { &m.FragmentIdEncap },
                    |m: &mut FlowMessage| { &mut m.FragmentIdEncap },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "FragmentOffsetEncap",
                    |m: &FlowMessage| { &m.FragmentOffsetEncap },
                    |m: &mut FlowMessage| { &mut m.FragmentOffsetEncap },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "HasMPLS",
                    |m: &FlowMessage| { &m.HasMPLS },
                    |m: &mut FlowMessage| { &mut m.HasMPLS },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "MPLSCount",
                    |m: &FlowMessage| { &m.MPLSCount },
                    |m: &mut FlowMessage| { &mut m.MPLSCount },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "MPLS1TTL",
                    |m: &FlowMessage| { &m.MPLS1TTL },
                    |m: &mut FlowMessage| { &mut m.MPLS1TTL },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "MPLS1Label",
                    |m: &FlowMessage| { &m.MPLS1Label },
                    |m: &mut FlowMessage| { &mut m.MPLS1Label },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "MPLS2TTL",
                    |m: &FlowMessage| { &m.MPLS2TTL },
                    |m: &mut FlowMessage| { &mut m.MPLS2TTL },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "MPLS2Label",
                    |m: &FlowMessage| { &m.MPLS2Label },
                    |m: &mut FlowMessage| { &mut m.MPLS2Label },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "MPLS3TTL",
                    |m: &FlowMessage| { &m.MPLS3TTL },
                    |m: &mut FlowMessage| { &mut m.MPLS3TTL },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "MPLS3Label",
                    |m: &FlowMessage| { &m.MPLS3Label },
                    |m: &mut FlowMessage| { &mut m.MPLS3Label },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "MPLSLastTTL",
                    |m: &FlowMessage| { &m.MPLSLastTTL },
                    |m: &mut FlowMessage| { &mut m.MPLSLastTTL },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "MPLSLastLabel",
                    |m: &FlowMessage| { &m.MPLSLastLabel },
                    |m: &mut FlowMessage| { &mut m.MPLSLastLabel },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "HasPPP",
                    |m: &FlowMessage| { &m.HasPPP },
                    |m: &mut FlowMessage| { &mut m.HasPPP },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "PPPAddressControl",
                    |m: &FlowMessage| { &m.PPPAddressControl },
                    |m: &mut FlowMessage| { &mut m.PPPAddressControl },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "Cid",
                    |m: &FlowMessage| { &m.Cid },
                    |m: &mut FlowMessage| { &mut m.Cid },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "CidString",
                    |m: &FlowMessage| { &m.CidString },
                    |m: &mut FlowMessage| { &mut m.CidString },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<FlowMessage_NormalizedType>>(
                    "Normalized",
                    |m: &FlowMessage| { &m.Normalized },
                    |m: &mut FlowMessage| { &mut m.Normalized },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "SrcIfName",
                    |m: &FlowMessage| { &m.SrcIfName },
                    |m: &mut FlowMessage| { &mut m.SrcIfName },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "SrcIfDesc",
                    |m: &FlowMessage| { &m.SrcIfDesc },
                    |m: &mut FlowMessage| { &mut m.SrcIfDesc },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "SrcIfSpeed",
                    |m: &FlowMessage| { &m.SrcIfSpeed },
                    |m: &mut FlowMessage| { &mut m.SrcIfSpeed },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "DstIfName",
                    |m: &FlowMessage| { &m.DstIfName },
                    |m: &mut FlowMessage| { &mut m.DstIfName },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "DstIfDesc",
                    |m: &FlowMessage| { &m.DstIfDesc },
                    |m: &mut FlowMessage| { &mut m.DstIfDesc },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "DstIfSpeed",
                    |m: &FlowMessage| { &m.DstIfSpeed },
                    |m: &mut FlowMessage| { &mut m.DstIfSpeed },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "ProtoName",
                    |m: &FlowMessage| { &m.ProtoName },
                    |m: &mut FlowMessage| { &mut m.ProtoName },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "RemoteCountry",
                    |m: &FlowMessage| { &m.RemoteCountry },
                    |m: &mut FlowMessage| { &mut m.RemoteCountry },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<FlowMessage>(
                    "FlowMessage",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static FlowMessage {
        static mut instance: ::protobuf::lazy::Lazy<FlowMessage> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const FlowMessage,
        };
        unsafe {
            instance.get(FlowMessage::new)
        }
    }
}

impl ::protobuf::Clear for FlowMessage {
    fn clear(&mut self) {
        self.clear_Type();
        self.clear_TimeReceived();
        self.clear_SequenceNum();
        self.clear_SamplingRate();
        self.clear_FlowDirection();
        self.clear_SamplerAddress();
        self.clear_TimeFlowStart();
        self.clear_TimeFlowEnd();
        self.clear_Bytes();
        self.clear_Packets();
        self.clear_SrcAddr();
        self.clear_DstAddr();
        self.clear_Etype();
        self.clear_Proto();
        self.clear_SrcPort();
        self.clear_DstPort();
        self.clear_InIf();
        self.clear_OutIf();
        self.clear_SrcMac();
        self.clear_DstMac();
        self.clear_SrcVlan();
        self.clear_DstVlan();
        self.clear_VlanId();
        self.clear_IngressVrfID();
        self.clear_EgressVrfID();
        self.clear_IPTos();
        self.clear_ForwardingStatus();
        self.clear_IPTTL();
        self.clear_TCPFlags();
        self.clear_IcmpType();
        self.clear_IcmpCode();
        self.clear_IPv6FlowLabel();
        self.clear_FragmentId();
        self.clear_FragmentOffset();
        self.clear_BiFlowDirection();
        self.clear_SrcAS();
        self.clear_DstAS();
        self.clear_NextHop();
        self.clear_NextHopAS();
        self.clear_SrcNet();
        self.clear_DstNet();
        self.clear_HasEncap();
        self.clear_SrcAddrEncap();
        self.clear_DstAddrEncap();
        self.clear_ProtoEncap();
        self.clear_EtypeEncap();
        self.clear_IPTosEncap();
        self.clear_IPTTLEncap();
        self.clear_IPv6FlowLabelEncap();
        self.clear_FragmentIdEncap();
        self.clear_FragmentOffsetEncap();
        self.clear_HasMPLS();
        self.clear_MPLSCount();
        self.clear_MPLS1TTL();
        self.clear_MPLS1Label();
        self.clear_MPLS2TTL();
        self.clear_MPLS2Label();
        self.clear_MPLS3TTL();
        self.clear_MPLS3Label();
        self.clear_MPLSLastTTL();
        self.clear_MPLSLastLabel();
        self.clear_HasPPP();
        self.clear_PPPAddressControl();
        self.clear_Cid();
        self.clear_CidString();
        self.clear_Normalized();
        self.clear_SrcIfName();
        self.clear_SrcIfDesc();
        self.clear_SrcIfSpeed();
        self.clear_DstIfName();
        self.clear_DstIfDesc();
        self.clear_DstIfSpeed();
        self.clear_ProtoName();
        self.clear_RemoteCountry();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for FlowMessage {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for FlowMessage {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum FlowMessage_FlowType {
    FLOWUNKNOWN = 0,
    SFLOW_5 = 1,
    NETFLOW_V5 = 2,
    NETFLOW_V9 = 3,
    IPFIX = 4,
}

impl ::protobuf::ProtobufEnum for FlowMessage_FlowType {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<FlowMessage_FlowType> {
        match value {
            0 => ::std::option::Option::Some(FlowMessage_FlowType::FLOWUNKNOWN),
            1 => ::std::option::Option::Some(FlowMessage_FlowType::SFLOW_5),
            2 => ::std::option::Option::Some(FlowMessage_FlowType::NETFLOW_V5),
            3 => ::std::option::Option::Some(FlowMessage_FlowType::NETFLOW_V9),
            4 => ::std::option::Option::Some(FlowMessage_FlowType::IPFIX),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [FlowMessage_FlowType] = &[
            FlowMessage_FlowType::FLOWUNKNOWN,
            FlowMessage_FlowType::SFLOW_5,
            FlowMessage_FlowType::NETFLOW_V5,
            FlowMessage_FlowType::NETFLOW_V9,
            FlowMessage_FlowType::IPFIX,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::EnumDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                ::protobuf::reflect::EnumDescriptor::new("FlowMessage_FlowType", file_descriptor_proto())
            })
        }
    }
}

impl ::std::marker::Copy for FlowMessage_FlowType {
}

impl ::std::default::Default for FlowMessage_FlowType {
    fn default() -> Self {
        FlowMessage_FlowType::FLOWUNKNOWN
    }
}

impl ::protobuf::reflect::ProtobufValue for FlowMessage_FlowType {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Enum(self.descriptor())
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum FlowMessage_NormalizedType {
    No = 0,
    Yes = 1,
}

impl ::protobuf::ProtobufEnum for FlowMessage_NormalizedType {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<FlowMessage_NormalizedType> {
        match value {
            0 => ::std::option::Option::Some(FlowMessage_NormalizedType::No),
            1 => ::std::option::Option::Some(FlowMessage_NormalizedType::Yes),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [FlowMessage_NormalizedType] = &[
            FlowMessage_NormalizedType::No,
            FlowMessage_NormalizedType::Yes,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::EnumDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                ::protobuf::reflect::EnumDescriptor::new("FlowMessage_NormalizedType", file_descriptor_proto())
            })
        }
    }
}

impl ::std::marker::Copy for FlowMessage_NormalizedType {
}

impl ::std::default::Default for FlowMessage_NormalizedType {
    fn default() -> Self {
        FlowMessage_NormalizedType::No
    }
}

impl ::protobuf::reflect::ProtobufValue for FlowMessage_NormalizedType {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Enum(self.descriptor())
    }
}

static file_descriptor_proto_data: &'static [u8] = b"\
    \n\x1cflow-messages-enriched.proto\x12\x13flowmessageenriched\"\xbe\x13\
    \n\x0bFlowMessage\x12=\n\x04Type\x18\x01\x20\x01(\x0e2).flowmessageenric\
    hed.FlowMessage.FlowTypeR\x04Type\x12\"\n\x0cTimeReceived\x18\x02\x20\
    \x01(\x04R\x0cTimeReceived\x12\x20\n\x0bSequenceNum\x18\x04\x20\x01(\rR\
    \x0bSequenceNum\x12\"\n\x0cSamplingRate\x18\x03\x20\x01(\x04R\x0cSamplin\
    gRate\x12$\n\rFlowDirection\x18*\x20\x01(\rR\rFlowDirection\x12&\n\x0eSa\
    mplerAddress\x18\x0b\x20\x01(\x0cR\x0eSamplerAddress\x12$\n\rTimeFlowSta\
    rt\x18&\x20\x01(\x04R\rTimeFlowStart\x12\x20\n\x0bTimeFlowEnd\x18\x05\
    \x20\x01(\x04R\x0bTimeFlowEnd\x12\x14\n\x05Bytes\x18\t\x20\x01(\x04R\x05\
    Bytes\x12\x18\n\x07Packets\x18\n\x20\x01(\x04R\x07Packets\x12\x18\n\x07S\
    rcAddr\x18\x06\x20\x01(\x0cR\x07SrcAddr\x12\x18\n\x07DstAddr\x18\x07\x20\
    \x01(\x0cR\x07DstAddr\x12\x14\n\x05Etype\x18\x1e\x20\x01(\rR\x05Etype\
    \x12\x14\n\x05Proto\x18\x14\x20\x01(\rR\x05Proto\x12\x18\n\x07SrcPort\
    \x18\x15\x20\x01(\rR\x07SrcPort\x12\x18\n\x07DstPort\x18\x16\x20\x01(\rR\
    \x07DstPort\x12\x12\n\x04InIf\x18\x12\x20\x01(\rR\x04InIf\x12\x14\n\x05O\
    utIf\x18\x13\x20\x01(\rR\x05OutIf\x12\x16\n\x06SrcMac\x18\x1b\x20\x01(\
    \x04R\x06SrcMac\x12\x16\n\x06DstMac\x18\x1c\x20\x01(\x04R\x06DstMac\x12\
    \x18\n\x07SrcVlan\x18!\x20\x01(\rR\x07SrcVlan\x12\x18\n\x07DstVlan\x18\"\
    \x20\x01(\rR\x07DstVlan\x12\x16\n\x06VlanId\x18\x1d\x20\x01(\rR\x06VlanI\
    d\x12\"\n\x0cIngressVrfID\x18'\x20\x01(\rR\x0cIngressVrfID\x12\x20\n\x0b\
    EgressVrfID\x18(\x20\x01(\rR\x0bEgressVrfID\x12\x14\n\x05IPTos\x18\x17\
    \x20\x01(\rR\x05IPTos\x12*\n\x10ForwardingStatus\x18\x18\x20\x01(\rR\x10\
    ForwardingStatus\x12\x14\n\x05IPTTL\x18\x19\x20\x01(\rR\x05IPTTL\x12\x1a\
    \n\x08TCPFlags\x18\x1a\x20\x01(\rR\x08TCPFlags\x12\x1a\n\x08IcmpType\x18\
    \x1f\x20\x01(\rR\x08IcmpType\x12\x1a\n\x08IcmpCode\x18\x20\x20\x01(\rR\
    \x08IcmpCode\x12$\n\rIPv6FlowLabel\x18%\x20\x01(\rR\rIPv6FlowLabel\x12\
    \x1e\n\nFragmentId\x18#\x20\x01(\rR\nFragmentId\x12&\n\x0eFragmentOffset\
    \x18$\x20\x01(\rR\x0eFragmentOffset\x12(\n\x0fBiFlowDirection\x18)\x20\
    \x01(\rR\x0fBiFlowDirection\x12\x14\n\x05SrcAS\x18\x0e\x20\x01(\rR\x05Sr\
    cAS\x12\x14\n\x05DstAS\x18\x0f\x20\x01(\rR\x05DstAS\x12\x18\n\x07NextHop\
    \x18\x0c\x20\x01(\x0cR\x07NextHop\x12\x1c\n\tNextHopAS\x18\r\x20\x01(\rR\
    \tNextHopAS\x12\x16\n\x06SrcNet\x18\x10\x20\x01(\rR\x06SrcNet\x12\x16\n\
    \x06DstNet\x18\x11\x20\x01(\rR\x06DstNet\x12\x1a\n\x08HasEncap\x18+\x20\
    \x01(\x08R\x08HasEncap\x12\"\n\x0cSrcAddrEncap\x18,\x20\x01(\x0cR\x0cSrc\
    AddrEncap\x12\"\n\x0cDstAddrEncap\x18-\x20\x01(\x0cR\x0cDstAddrEncap\x12\
    \x1e\n\nProtoEncap\x18.\x20\x01(\rR\nProtoEncap\x12\x1e\n\nEtypeEncap\
    \x18/\x20\x01(\rR\nEtypeEncap\x12\x1e\n\nIPTosEncap\x180\x20\x01(\rR\nIP\
    TosEncap\x12\x1e\n\nIPTTLEncap\x181\x20\x01(\rR\nIPTTLEncap\x12.\n\x12IP\
    v6FlowLabelEncap\x182\x20\x01(\rR\x12IPv6FlowLabelEncap\x12(\n\x0fFragme\
    ntIdEncap\x183\x20\x01(\rR\x0fFragmentIdEncap\x120\n\x13FragmentOffsetEn\
    cap\x184\x20\x01(\rR\x13FragmentOffsetEncap\x12\x18\n\x07HasMPLS\x185\
    \x20\x01(\x08R\x07HasMPLS\x12\x1c\n\tMPLSCount\x186\x20\x01(\rR\tMPLSCou\
    nt\x12\x1a\n\x08MPLS1TTL\x187\x20\x01(\rR\x08MPLS1TTL\x12\x1e\n\nMPLS1La\
    bel\x188\x20\x01(\rR\nMPLS1Label\x12\x1a\n\x08MPLS2TTL\x189\x20\x01(\rR\
    \x08MPLS2TTL\x12\x1e\n\nMPLS2Label\x18:\x20\x01(\rR\nMPLS2Label\x12\x1a\
    \n\x08MPLS3TTL\x18;\x20\x01(\rR\x08MPLS3TTL\x12\x1e\n\nMPLS3Label\x18<\
    \x20\x01(\rR\nMPLS3Label\x12\x20\n\x0bMPLSLastTTL\x18=\x20\x01(\rR\x0bMP\
    LSLastTTL\x12$\n\rMPLSLastLabel\x18>\x20\x01(\rR\rMPLSLastLabel\x12\x16\
    \n\x06HasPPP\x18?\x20\x01(\x08R\x06HasPPP\x12,\n\x11PPPAddressControl\
    \x18@\x20\x01(\rR\x11PPPAddressControl\x12\x11\n\x03Cid\x18\xe8\x07\x20\
    \x01(\rR\x03Cid\x12\x1d\n\tCidString\x18\xe9\x07\x20\x01(\tR\tCidString\
    \x12P\n\nNormalized\x18\xea\x07\x20\x01(\x0e2/.flowmessageenriched.FlowM\
    essage.NormalizedTypeR\nNormalized\x12\x1d\n\tSrcIfName\x18\xeb\x07\x20\
    \x01(\tR\tSrcIfName\x12\x1d\n\tSrcIfDesc\x18\xec\x07\x20\x01(\tR\tSrcIfD\
    esc\x12\x1f\n\nSrcIfSpeed\x18\xed\x07\x20\x01(\rR\nSrcIfSpeed\x12\x1d\n\
    \tDstIfName\x18\xee\x07\x20\x01(\tR\tDstIfName\x12\x1d\n\tDstIfDesc\x18\
    \xef\x07\x20\x01(\tR\tDstIfDesc\x12\x1f\n\nDstIfSpeed\x18\xf0\x07\x20\
    \x01(\rR\nDstIfSpeed\x12\x1d\n\tProtoName\x18\xf1\x07\x20\x01(\tR\tProto\
    Name\x12%\n\rRemoteCountry\x18\xf2\x07\x20\x01(\tR\rRemoteCountry\"S\n\
    \x08FlowType\x12\x0f\n\x0bFLOWUNKNOWN\x10\0\x12\x0b\n\x07SFLOW_5\x10\x01\
    \x12\x0e\n\nNETFLOW_V5\x10\x02\x12\x0e\n\nNETFLOW_V9\x10\x03\x12\t\n\x05\
    IPFIX\x10\x04\"!\n\x0eNormalizedType\x12\x06\n\x02No\x10\0\x12\x07\n\x03\
    Yes\x10\x01B\"\n\tbwnetflowB\x15FlowMessageEnrichedPbJ\xd4,\n\x07\x12\
    \x05\0\0\x8d\x01\x01\n\x08\n\x01\x0c\x12\x03\0\0\x12\n\x08\n\x01\x02\x12\
    \x03\x01\0\x1c\n\x08\n\x01\x08\x12\x03\x03\0\"\n\t\n\x02\x08\x01\x12\x03\
    \x03\0\"\n\x08\n\x01\x08\x12\x03\x04\06\n\t\n\x02\x08\x08\x12\x03\x04\06\
    \n\x0b\n\x02\x04\0\x12\x05\x06\0\x8d\x01\x01\n\n\n\x03\x04\0\x01\x12\x03\
    \x06\x08\x13\n\x0c\n\x04\x04\0\x04\0\x12\x04\x07\x02\r\x03\n\x0c\n\x05\
    \x04\0\x04\0\x01\x12\x03\x07\x07\x0f\n\r\n\x06\x04\0\x04\0\x02\0\x12\x03\
    \x08\x04\x14\n\x0e\n\x07\x04\0\x04\0\x02\0\x01\x12\x03\x08\x04\x0f\n\x0e\
    \n\x07\x04\0\x04\0\x02\0\x02\x12\x03\x08\x12\x13\n\r\n\x06\x04\0\x04\0\
    \x02\x01\x12\x03\t\x04\x10\n\x0e\n\x07\x04\0\x04\0\x02\x01\x01\x12\x03\t\
    \x04\x0b\n\x0e\n\x07\x04\0\x04\0\x02\x01\x02\x12\x03\t\x0e\x0f\n\r\n\x06\
    \x04\0\x04\0\x02\x02\x12\x03\n\x04\x13\n\x0e\n\x07\x04\0\x04\0\x02\x02\
    \x01\x12\x03\n\x04\x0e\n\x0e\n\x07\x04\0\x04\0\x02\x02\x02\x12\x03\n\x11\
    \x12\n\r\n\x06\x04\0\x04\0\x02\x03\x12\x03\x0b\x04\x13\n\x0e\n\x07\x04\0\
    \x04\0\x02\x03\x01\x12\x03\x0b\x04\x0e\n\x0e\n\x07\x04\0\x04\0\x02\x03\
    \x02\x12\x03\x0b\x11\x12\n\r\n\x06\x04\0\x04\0\x02\x04\x12\x03\x0c\x04\
    \x0e\n\x0e\n\x07\x04\0\x04\0\x02\x04\x01\x12\x03\x0c\x04\t\n\x0e\n\x07\
    \x04\0\x04\0\x02\x04\x02\x12\x03\x0c\x0c\r\n\x0b\n\x04\x04\0\x02\0\x12\
    \x03\x0e\x02\x14\n\x0c\n\x05\x04\0\x02\0\x06\x12\x03\x0e\x02\n\n\x0c\n\
    \x05\x04\0\x02\0\x01\x12\x03\x0e\x0b\x0f\n\x0c\n\x05\x04\0\x02\0\x03\x12\
    \x03\x0e\x12\x13\n\x0b\n\x04\x04\0\x02\x01\x12\x03\x10\x02\x1a\n\x0c\n\
    \x05\x04\0\x02\x01\x05\x12\x03\x10\x02\x08\n\x0c\n\x05\x04\0\x02\x01\x01\
    \x12\x03\x10\t\x15\n\x0c\n\x05\x04\0\x02\x01\x03\x12\x03\x10\x18\x19\n\
    \x0b\n\x04\x04\0\x02\x02\x12\x03\x11\x02\x19\n\x0c\n\x05\x04\0\x02\x02\
    \x05\x12\x03\x11\x02\x08\n\x0c\n\x05\x04\0\x02\x02\x01\x12\x03\x11\t\x14\
    \n\x0c\n\x05\x04\0\x02\x02\x03\x12\x03\x11\x17\x18\n\x0b\n\x04\x04\0\x02\
    \x03\x12\x03\x12\x02\x1a\n\x0c\n\x05\x04\0\x02\x03\x05\x12\x03\x12\x02\
    \x08\n\x0c\n\x05\x04\0\x02\x03\x01\x12\x03\x12\t\x15\n\x0c\n\x05\x04\0\
    \x02\x03\x03\x12\x03\x12\x18\x19\n\x0b\n\x04\x04\0\x02\x04\x12\x03\x14\
    \x02\x1c\n\x0c\n\x05\x04\0\x02\x04\x05\x12\x03\x14\x02\x08\n\x0c\n\x05\
    \x04\0\x02\x04\x01\x12\x03\x14\t\x16\n\x0c\n\x05\x04\0\x02\x04\x03\x12\
    \x03\x14\x19\x1b\n\"\n\x04\x04\0\x02\x05\x12\x03\x17\x02\x1c\x1a\x15\x20\
    Sampler\x20information\n\n\x0c\n\x05\x04\0\x02\x05\x05\x12\x03\x17\x02\
    \x07\n\x0c\n\x05\x04\0\x02\x05\x01\x12\x03\x17\x08\x16\n\x0c\n\x05\x04\0\
    \x02\x05\x03\x12\x03\x17\x19\x1b\n\"\n\x04\x04\0\x02\x06\x12\x03\x1a\x02\
    \x1c\x1a\x15\x20Found\x20inside\x20packet\n\n\x0c\n\x05\x04\0\x02\x06\
    \x05\x12\x03\x1a\x02\x08\n\x0c\n\x05\x04\0\x02\x06\x01\x12\x03\x1a\t\x16\
    \n\x0c\n\x05\x04\0\x02\x06\x03\x12\x03\x1a\x19\x1b\n\x0b\n\x04\x04\0\x02\
    \x07\x12\x03\x1b\x02\x19\n\x0c\n\x05\x04\0\x02\x07\x05\x12\x03\x1b\x02\
    \x08\n\x0c\n\x05\x04\0\x02\x07\x01\x12\x03\x1b\t\x14\n\x0c\n\x05\x04\0\
    \x02\x07\x03\x12\x03\x1b\x17\x18\n)\n\x04\x04\0\x02\x08\x12\x03\x1e\x02\
    \x13\x1a\x1c\x20Size\x20of\x20the\x20sampled\x20packet\n\n\x0c\n\x05\x04\
    \0\x02\x08\x05\x12\x03\x1e\x02\x08\n\x0c\n\x05\x04\0\x02\x08\x01\x12\x03\
    \x1e\t\x0e\n\x0c\n\x05\x04\0\x02\x08\x03\x12\x03\x1e\x11\x12\n\x0b\n\x04\
    \x04\0\x02\t\x12\x03\x1f\x02\x16\n\x0c\n\x05\x04\0\x02\t\x05\x12\x03\x1f\
    \x02\x08\n\x0c\n\x05\x04\0\x02\t\x01\x12\x03\x1f\t\x10\n\x0c\n\x05\x04\0\
    \x02\t\x03\x12\x03\x1f\x13\x15\n+\n\x04\x04\0\x02\n\x12\x03\"\x02\x14\
    \x1a\x1e\x20Source/destination\x20addresses\n\n\x0c\n\x05\x04\0\x02\n\
    \x05\x12\x03\"\x02\x07\n\x0c\n\x05\x04\0\x02\n\x01\x12\x03\"\x08\x0f\n\
    \x0c\n\x05\x04\0\x02\n\x03\x12\x03\"\x12\x13\n\x0b\n\x04\x04\0\x02\x0b\
    \x12\x03#\x02\x14\n\x0c\n\x05\x04\0\x02\x0b\x05\x12\x03#\x02\x07\n\x0c\n\
    \x05\x04\0\x02\x0b\x01\x12\x03#\x08\x0f\n\x0c\n\x05\x04\0\x02\x0b\x03\
    \x12\x03#\x12\x13\n7\n\x04\x04\0\x02\x0c\x12\x03&\x02\x14\x1a*\x20Layer\
    \x203\x20protocol\x20(IPv4/IPv6/ARP/MPLS...)\n\n\x0c\n\x05\x04\0\x02\x0c\
    \x05\x12\x03&\x02\x08\n\x0c\n\x05\x04\0\x02\x0c\x01\x12\x03&\t\x0e\n\x0c\
    \n\x05\x04\0\x02\x0c\x03\x12\x03&\x11\x13\n\x1f\n\x04\x04\0\x02\r\x12\
    \x03)\x02\x14\x1a\x12\x20Layer\x204\x20protocol\n\n\x0c\n\x05\x04\0\x02\
    \r\x05\x12\x03)\x02\x08\n\x0c\n\x05\x04\0\x02\r\x01\x12\x03)\t\x0e\n\x0c\
    \n\x05\x04\0\x02\r\x03\x12\x03)\x11\x13\n$\n\x04\x04\0\x02\x0e\x12\x03,\
    \x02\x16\x1a\x17\x20Ports\x20for\x20UDP\x20and\x20TCP\n\n\x0c\n\x05\x04\
    \0\x02\x0e\x05\x12\x03,\x02\x08\n\x0c\n\x05\x04\0\x02\x0e\x01\x12\x03,\t\
    \x10\n\x0c\n\x05\x04\0\x02\x0e\x03\x12\x03,\x13\x15\n\x0b\n\x04\x04\0\
    \x02\x0f\x12\x03-\x02\x16\n\x0c\n\x05\x04\0\x02\x0f\x05\x12\x03-\x02\x08\
    \n\x0c\n\x05\x04\0\x02\x0f\x01\x12\x03-\t\x10\n\x0c\n\x05\x04\0\x02\x0f\
    \x03\x12\x03-\x13\x15\n\x19\n\x04\x04\0\x02\x10\x12\x030\x02\x13\x1a\x0c\
    \x20Interfaces\n\n\x0c\n\x05\x04\0\x02\x10\x05\x12\x030\x02\x08\n\x0c\n\
    \x05\x04\0\x02\x10\x01\x12\x030\t\r\n\x0c\n\x05\x04\0\x02\x10\x03\x12\
    \x030\x10\x12\n\x0b\n\x04\x04\0\x02\x11\x12\x031\x02\x14\n\x0c\n\x05\x04\
    \0\x02\x11\x05\x12\x031\x02\x08\n\x0c\n\x05\x04\0\x02\x11\x01\x12\x031\t\
    \x0e\n\x0c\n\x05\x04\0\x02\x11\x03\x12\x031\x11\x13\n#\n\x04\x04\0\x02\
    \x12\x12\x034\x02\x15\x1a\x16\x20Ethernet\x20information\n\n\x0c\n\x05\
    \x04\0\x02\x12\x05\x12\x034\x02\x08\n\x0c\n\x05\x04\0\x02\x12\x01\x12\
    \x034\t\x0f\n\x0c\n\x05\x04\0\x02\x12\x03\x12\x034\x12\x14\n\x0b\n\x04\
    \x04\0\x02\x13\x12\x035\x02\x15\n\x0c\n\x05\x04\0\x02\x13\x05\x12\x035\
    \x02\x08\n\x0c\n\x05\x04\0\x02\x13\x01\x12\x035\t\x0f\n\x0c\n\x05\x04\0\
    \x02\x13\x03\x12\x035\x12\x14\n\x13\n\x04\x04\0\x02\x14\x12\x038\x02\x16\
    \x1a\x06\x20Vlan\n\n\x0c\n\x05\x04\0\x02\x14\x05\x12\x038\x02\x08\n\x0c\
    \n\x05\x04\0\x02\x14\x01\x12\x038\t\x10\n\x0c\n\x05\x04\0\x02\x14\x03\
    \x12\x038\x13\x15\n\x0b\n\x04\x04\0\x02\x15\x12\x039\x02\x16\n\x0c\n\x05\
    \x04\0\x02\x15\x05\x12\x039\x02\x08\n\x0c\n\x05\x04\0\x02\x15\x01\x12\
    \x039\t\x10\n\x0c\n\x05\x04\0\x02\x15\x03\x12\x039\x13\x15\n,\n\x04\x04\
    \0\x02\x16\x12\x03;\x02\x15\x1a\x1f\x20802.1q\x20VLAN\x20in\x20sampled\
    \x20packet\n\n\x0c\n\x05\x04\0\x02\x16\x05\x12\x03;\x02\x08\n\x0c\n\x05\
    \x04\0\x02\x16\x01\x12\x03;\t\x0f\n\x0c\n\x05\x04\0\x02\x16\x03\x12\x03;\
    \x12\x14\n\x12\n\x04\x04\0\x02\x17\x12\x03>\x02\x1b\x1a\x05\x20VRF\n\n\
    \x0c\n\x05\x04\0\x02\x17\x05\x12\x03>\x02\x08\n\x0c\n\x05\x04\0\x02\x17\
    \x01\x12\x03>\t\x15\n\x0c\n\x05\x04\0\x02\x17\x03\x12\x03>\x18\x1a\n\x0b\
    \n\x04\x04\0\x02\x18\x12\x03?\x02\x1a\n\x0c\n\x05\x04\0\x02\x18\x05\x12\
    \x03?\x02\x08\n\x0c\n\x05\x04\0\x02\x18\x01\x12\x03?\t\x14\n\x0c\n\x05\
    \x04\0\x02\x18\x03\x12\x03?\x17\x19\n'\n\x04\x04\0\x02\x19\x12\x03B\x02\
    \x14\x1a\x1a\x20IP\x20and\x20TCP\x20special\x20flags\n\n\x0c\n\x05\x04\0\
    \x02\x19\x05\x12\x03B\x02\x08\n\x0c\n\x05\x04\0\x02\x19\x01\x12\x03B\t\
    \x0e\n\x0c\n\x05\x04\0\x02\x19\x03\x12\x03B\x11\x13\n\x0b\n\x04\x04\0\
    \x02\x1a\x12\x03C\x02\x1f\n\x0c\n\x05\x04\0\x02\x1a\x05\x12\x03C\x02\x08\
    \n\x0c\n\x05\x04\0\x02\x1a\x01\x12\x03C\t\x19\n\x0c\n\x05\x04\0\x02\x1a\
    \x03\x12\x03C\x1c\x1e\n\x0b\n\x04\x04\0\x02\x1b\x12\x03D\x02\x14\n\x0c\n\
    \x05\x04\0\x02\x1b\x05\x12\x03D\x02\x08\n\x0c\n\x05\x04\0\x02\x1b\x01\
    \x12\x03D\t\x0e\n\x0c\n\x05\x04\0\x02\x1b\x03\x12\x03D\x11\x13\n\x0b\n\
    \x04\x04\0\x02\x1c\x12\x03E\x02\x17\n\x0c\n\x05\x04\0\x02\x1c\x05\x12\
    \x03E\x02\x08\n\x0c\n\x05\x04\0\x02\x1c\x01\x12\x03E\t\x11\n\x0c\n\x05\
    \x04\0\x02\x1c\x03\x12\x03E\x14\x16\n\x0b\n\x04\x04\0\x02\x1d\x12\x03F\
    \x02\x17\n\x0c\n\x05\x04\0\x02\x1d\x05\x12\x03F\x02\x08\n\x0c\n\x05\x04\
    \0\x02\x1d\x01\x12\x03F\t\x11\n\x0c\n\x05\x04\0\x02\x1d\x03\x12\x03F\x14\
    \x16\n\x0b\n\x04\x04\0\x02\x1e\x12\x03G\x02\x17\n\x0c\n\x05\x04\0\x02\
    \x1e\x05\x12\x03G\x02\x08\n\x0c\n\x05\x04\0\x02\x1e\x01\x12\x03G\t\x11\n\
    \x0c\n\x05\x04\0\x02\x1e\x03\x12\x03G\x14\x16\n\x0b\n\x04\x04\0\x02\x1f\
    \x12\x03H\x02\x1c\n\x0c\n\x05\x04\0\x02\x1f\x05\x12\x03H\x02\x08\n\x0c\n\
    \x05\x04\0\x02\x1f\x01\x12\x03H\t\x16\n\x0c\n\x05\x04\0\x02\x1f\x03\x12\
    \x03H\x19\x1b\n$\n\x04\x04\0\x02\x20\x12\x03J\x02\x19\x1a\x17\x20Fragmen\
    ts\x20(IPv4/IPv6)\n\n\x0c\n\x05\x04\0\x02\x20\x05\x12\x03J\x02\x08\n\x0c\
    \n\x05\x04\0\x02\x20\x01\x12\x03J\t\x13\n\x0c\n\x05\x04\0\x02\x20\x03\
    \x12\x03J\x16\x18\n\x0b\n\x04\x04\0\x02!\x12\x03K\x02\x1d\n\x0c\n\x05\
    \x04\0\x02!\x05\x12\x03K\x02\x08\n\x0c\n\x05\x04\0\x02!\x01\x12\x03K\t\
    \x17\n\x0c\n\x05\x04\0\x02!\x03\x12\x03K\x1a\x1c\n\x0b\n\x04\x04\0\x02\"\
    \x12\x03L\x02\x1e\n\x0c\n\x05\x04\0\x02\"\x05\x12\x03L\x02\x08\n\x0c\n\
    \x05\x04\0\x02\"\x01\x12\x03L\t\x18\n\x0c\n\x05\x04\0\x02\"\x03\x12\x03L\
    \x1b\x1d\n,\n\x04\x04\0\x02#\x12\x03O\x02\x14\x1a\x1f\x20Autonomous\x20s\
    ystem\x20information\n\n\x0c\n\x05\x04\0\x02#\x05\x12\x03O\x02\x08\n\x0c\
    \n\x05\x04\0\x02#\x01\x12\x03O\t\x0e\n\x0c\n\x05\x04\0\x02#\x03\x12\x03O\
    \x11\x13\n\x0b\n\x04\x04\0\x02$\x12\x03P\x02\x14\n\x0c\n\x05\x04\0\x02$\
    \x05\x12\x03P\x02\x08\n\x0c\n\x05\x04\0\x02$\x01\x12\x03P\t\x0e\n\x0c\n\
    \x05\x04\0\x02$\x03\x12\x03P\x11\x13\n\x0b\n\x04\x04\0\x02%\x12\x03R\x02\
    \x15\n\x0c\n\x05\x04\0\x02%\x05\x12\x03R\x02\x07\n\x0c\n\x05\x04\0\x02%\
    \x01\x12\x03R\x08\x0f\n\x0c\n\x05\x04\0\x02%\x03\x12\x03R\x12\x14\n\x0b\
    \n\x04\x04\0\x02&\x12\x03S\x02\x18\n\x0c\n\x05\x04\0\x02&\x05\x12\x03S\
    \x02\x08\n\x0c\n\x05\x04\0\x02&\x01\x12\x03S\t\x12\n\x0c\n\x05\x04\0\x02\
    &\x03\x12\x03S\x15\x17\n\x1a\n\x04\x04\0\x02'\x12\x03V\x02\x15\x1a\r\x20\
    Prefix\x20size\n\n\x0c\n\x05\x04\0\x02'\x05\x12\x03V\x02\x08\n\x0c\n\x05\
    \x04\0\x02'\x01\x12\x03V\t\x0f\n\x0c\n\x05\x04\0\x02'\x03\x12\x03V\x12\
    \x14\n\x0b\n\x04\x04\0\x02(\x12\x03W\x02\x15\n\x0c\n\x05\x04\0\x02(\x05\
    \x12\x03W\x02\x08\n\x0c\n\x05\x04\0\x02(\x01\x12\x03W\t\x0f\n\x0c\n\x05\
    \x04\0\x02(\x03\x12\x03W\x12\x14\n+\n\x04\x04\0\x02)\x12\x03Z\x02\x15\
    \x1a\x1e\x20IP\x20encapsulation\x20information\n\n\x0c\n\x05\x04\0\x02)\
    \x05\x12\x03Z\x02\x06\n\x0c\n\x05\x04\0\x02)\x01\x12\x03Z\x07\x0f\n\x0c\
    \n\x05\x04\0\x02)\x03\x12\x03Z\x12\x14\n\x0b\n\x04\x04\0\x02*\x12\x03[\
    \x02\x1a\n\x0c\n\x05\x04\0\x02*\x05\x12\x03[\x02\x07\n\x0c\n\x05\x04\0\
    \x02*\x01\x12\x03[\x08\x14\n\x0c\n\x05\x04\0\x02*\x03\x12\x03[\x17\x19\n\
    \x0b\n\x04\x04\0\x02+\x12\x03\\\x02\x1a\n\x0c\n\x05\x04\0\x02+\x05\x12\
    \x03\\\x02\x07\n\x0c\n\x05\x04\0\x02+\x01\x12\x03\\\x08\x14\n\x0c\n\x05\
    \x04\0\x02+\x03\x12\x03\\\x17\x19\n\x0b\n\x04\x04\0\x02,\x12\x03]\x02\
    \x19\n\x0c\n\x05\x04\0\x02,\x05\x12\x03]\x02\x08\n\x0c\n\x05\x04\0\x02,\
    \x01\x12\x03]\t\x13\n\x0c\n\x05\x04\0\x02,\x03\x12\x03]\x16\x18\n\x0b\n\
    \x04\x04\0\x02-\x12\x03^\x02\x19\n\x0c\n\x05\x04\0\x02-\x05\x12\x03^\x02\
    \x08\n\x0c\n\x05\x04\0\x02-\x01\x12\x03^\t\x13\n\x0c\n\x05\x04\0\x02-\
    \x03\x12\x03^\x16\x18\n\x0b\n\x04\x04\0\x02.\x12\x03`\x02\x19\n\x0c\n\
    \x05\x04\0\x02.\x05\x12\x03`\x02\x08\n\x0c\n\x05\x04\0\x02.\x01\x12\x03`\
    \t\x13\n\x0c\n\x05\x04\0\x02.\x03\x12\x03`\x16\x18\n\x0b\n\x04\x04\0\x02\
    /\x12\x03a\x02\x19\n\x0c\n\x05\x04\0\x02/\x05\x12\x03a\x02\x08\n\x0c\n\
    \x05\x04\0\x02/\x01\x12\x03a\t\x13\n\x0c\n\x05\x04\0\x02/\x03\x12\x03a\
    \x16\x18\n\x0b\n\x04\x04\0\x020\x12\x03b\x02!\n\x0c\n\x05\x04\0\x020\x05\
    \x12\x03b\x02\x08\n\x0c\n\x05\x04\0\x020\x01\x12\x03b\t\x1b\n\x0c\n\x05\
    \x04\0\x020\x03\x12\x03b\x1e\x20\n\x0b\n\x04\x04\0\x021\x12\x03c\x02\x1e\
    \n\x0c\n\x05\x04\0\x021\x05\x12\x03c\x02\x08\n\x0c\n\x05\x04\0\x021\x01\
    \x12\x03c\t\x18\n\x0c\n\x05\x04\0\x021\x03\x12\x03c\x1b\x1d\n\x0b\n\x04\
    \x04\0\x022\x12\x03d\x02\"\n\x0c\n\x05\x04\0\x022\x05\x12\x03d\x02\x08\n\
    \x0c\n\x05\x04\0\x022\x01\x12\x03d\t\x1c\n\x0c\n\x05\x04\0\x022\x03\x12\
    \x03d\x1f!\n\x1f\n\x04\x04\0\x023\x12\x03g\x02\x14\x1a\x12\x20MPLS\x20in\
    formation\n\n\x0c\n\x05\x04\0\x023\x05\x12\x03g\x02\x06\n\x0c\n\x05\x04\
    \0\x023\x01\x12\x03g\x07\x0e\n\x0c\n\x05\x04\0\x023\x03\x12\x03g\x11\x13\
    \n\x0b\n\x04\x04\0\x024\x12\x03h\x02\x18\n\x0c\n\x05\x04\0\x024\x05\x12\
    \x03h\x02\x08\n\x0c\n\x05\x04\0\x024\x01\x12\x03h\t\x12\n\x0c\n\x05\x04\
    \0\x024\x03\x12\x03h\x15\x17\n\x18\n\x04\x04\0\x025\x12\x03i\x02\x17\"\
    \x0b\x20First\x20TTL\n\n\x0c\n\x05\x04\0\x025\x05\x12\x03i\x02\x08\n\x0c\
    \n\x05\x04\0\x025\x01\x12\x03i\t\x11\n\x0c\n\x05\x04\0\x025\x03\x12\x03i\
    \x14\x16\n\x1a\n\x04\x04\0\x026\x12\x03j\x02\x19\"\r\x20First\x20Label\n\
    \n\x0c\n\x05\x04\0\x026\x05\x12\x03j\x02\x08\n\x0c\n\x05\x04\0\x026\x01\
    \x12\x03j\t\x13\n\x0c\n\x05\x04\0\x026\x03\x12\x03j\x16\x18\n\x19\n\x04\
    \x04\0\x027\x12\x03k\x02\x17\"\x0c\x20Second\x20TTL\n\n\x0c\n\x05\x04\0\
    \x027\x05\x12\x03k\x02\x08\n\x0c\n\x05\x04\0\x027\x01\x12\x03k\t\x11\n\
    \x0c\n\x05\x04\0\x027\x03\x12\x03k\x14\x16\n\x1b\n\x04\x04\0\x028\x12\
    \x03l\x02\x19\"\x0e\x20Second\x20Label\n\n\x0c\n\x05\x04\0\x028\x05\x12\
    \x03l\x02\x08\n\x0c\n\x05\x04\0\x028\x01\x12\x03l\t\x13\n\x0c\n\x05\x04\
    \0\x028\x03\x12\x03l\x16\x18\n\x18\n\x04\x04\0\x029\x12\x03m\x02\x17\"\
    \x0b\x20Third\x20TTL\n\n\x0c\n\x05\x04\0\x029\x05\x12\x03m\x02\x08\n\x0c\
    \n\x05\x04\0\x029\x01\x12\x03m\t\x11\n\x0c\n\x05\x04\0\x029\x03\x12\x03m\
    \x14\x16\n\x1a\n\x04\x04\0\x02:\x12\x03n\x02\x19\"\r\x20Third\x20Label\n\
    \n\x0c\n\x05\x04\0\x02:\x05\x12\x03n\x02\x08\n\x0c\n\x05\x04\0\x02:\x01\
    \x12\x03n\t\x13\n\x0c\n\x05\x04\0\x02:\x03\x12\x03n\x16\x18\n\x17\n\x04\
    \x04\0\x02;\x12\x03o\x02\x1a\"\n\x20Last\x20TTL\n\n\x0c\n\x05\x04\0\x02;\
    \x05\x12\x03o\x02\x08\n\x0c\n\x05\x04\0\x02;\x01\x12\x03o\t\x14\n\x0c\n\
    \x05\x04\0\x02;\x03\x12\x03o\x17\x19\n\x19\n\x04\x04\0\x02<\x12\x03p\x02\
    \x1c\"\x0c\x20Last\x20Label\n\n\x0c\n\x05\x04\0\x02<\x05\x12\x03p\x02\
    \x08\n\x0c\n\x05\x04\0\x02<\x01\x12\x03p\t\x16\n\x0c\n\x05\x04\0\x02<\
    \x03\x12\x03p\x19\x1b\n\x1e\n\x04\x04\0\x02=\x12\x03s\x02\x13\x1a\x11\
    \x20PPP\x20information\n\n\x0c\n\x05\x04\0\x02=\x05\x12\x03s\x02\x06\n\
    \x0c\n\x05\x04\0\x02=\x01\x12\x03s\x07\r\n\x0c\n\x05\x04\0\x02=\x03\x12\
    \x03s\x10\x12\n\x0b\n\x04\x04\0\x02>\x12\x03t\x02\x20\n\x0c\n\x05\x04\0\
    \x02>\x05\x12\x03t\x02\x08\n\x0c\n\x05\x04\0\x02>\x01\x12\x03t\t\x1a\n\
    \x0c\n\x05\x04\0\x02>\x03\x12\x03t\x1d\x1f\n\x9f\x01\n\x04\x04\0\x02?\
    \x12\x03z\x02\x14\x1a\x1b\x20bwNetFlow\x20enricher\x20fields\n\"0\x20Cus\
    tomer\x20ID\x20-\x20numerical\x20ID,\x20assigned\x20by\x20prefix\n2C\x20\
    Custom\x20fields:\x20start\x20after\x20ID\x201000:\n\x20uint32\x20MyCust\
    omField\x20=\x201000;\n\n\x0c\n\x05\x04\0\x02?\x05\x12\x03z\x02\x08\n\
    \x0c\n\x05\x04\0\x02?\x01\x12\x03z\t\x0c\n\x0c\n\x05\x04\0\x02?\x03\x12\
    \x03z\x0f\x13\nF\n\x04\x04\0\x02@\x12\x03{\x02\x1a\"9\x20Customer\x20ID\
    \x20-\x20a\x20more\x20generalized\x20ID,\x20assigned\x20by\x20prefix\n\n\
    \x0c\n\x05\x04\0\x02@\x05\x12\x03{\x02\x08\n\x0c\n\x05\x04\0\x02@\x01\
    \x12\x03{\t\x12\n\x0c\n\x05\x04\0\x02@\x03\x12\x03{\x15\x19\n\r\n\x04\
    \x04\0\x04\x01\x12\x05}\x02\x80\x01\x03\n\x0c\n\x05\x04\0\x04\x01\x01\
    \x12\x03}\x07\x15\n\r\n\x06\x04\0\x04\x01\x02\0\x12\x03~\x04\x0b\n\x0e\n\
    \x07\x04\0\x04\x01\x02\0\x01\x12\x03~\x04\x06\n\x0e\n\x07\x04\0\x04\x01\
    \x02\0\x02\x12\x03~\t\n\n\r\n\x06\x04\0\x04\x01\x02\x01\x12\x03\x7f\x04\
    \x0c\n\x0e\n\x07\x04\0\x04\x01\x02\x01\x01\x12\x03\x7f\x04\x07\n\x0e\n\
    \x07\x04\0\x04\x01\x02\x01\x02\x12\x03\x7f\n\x0b\nJ\n\x04\x04\0\x02A\x12\
    \x04\x81\x01\x02#\"<\x20Normalization\x20-\x20whether\x20the\x20sampling\
    \x20rate\x20is\x20accounted\x20for\n\n\r\n\x05\x04\0\x02A\x06\x12\x04\
    \x81\x01\x02\x10\n\r\n\x05\x04\0\x02A\x01\x12\x04\x81\x01\x11\x1b\n\r\n\
    \x05\x04\0\x02A\x03\x12\x04\x81\x01\x1e\"\nj\n\x04\x04\0\x02B\x12\x04\
    \x84\x01\x02\x1a\x1a7\x20Fields\x20for\x20Interface\x20Usability\x20--\
    \x20enriched\x20using\x20SNMP\n\"#\x20set\x20to\x20the\x20name,\x20unset\
    \x20by\x20default\n\n\r\n\x05\x04\0\x02B\x05\x12\x04\x84\x01\x02\x08\n\r\
    \n\x05\x04\0\x02B\x01\x12\x04\x84\x01\t\x12\n\r\n\x05\x04\0\x02B\x03\x12\
    \x04\x84\x01\x15\x19\nJ\n\x04\x04\0\x02C\x12\x04\x85\x01\x02\x1a\"<\x20s\
    et\x20to\x20the\x20descrition,\x20filtered\x20by\x20a\x20regex\x20in\x20\
    the\x20enricher\n\n\r\n\x05\x04\0\x02C\x05\x12\x04\x85\x01\x02\x08\n\r\n\
    \x05\x04\0\x02C\x01\x12\x04\x85\x01\t\x12\n\r\n\x05\x04\0\x02C\x03\x12\
    \x04\x85\x01\x15\x19\n\x1b\n\x04\x04\0\x02D\x12\x04\x86\x01\x02\x1b\"\r\
    \x20iface\x20speed\n\n\r\n\x05\x04\0\x02D\x05\x12\x04\x86\x01\x02\x08\n\
    \r\n\x05\x04\0\x02D\x01\x12\x04\x86\x01\t\x13\n\r\n\x05\x04\0\x02D\x03\
    \x12\x04\x86\x01\x16\x1a\n\x0c\n\x04\x04\0\x02E\x12\x04\x87\x01\x02\x1a\
    \n\r\n\x05\x04\0\x02E\x05\x12\x04\x87\x01\x02\x08\n\r\n\x05\x04\0\x02E\
    \x01\x12\x04\x87\x01\t\x12\n\r\n\x05\x04\0\x02E\x03\x12\x04\x87\x01\x15\
    \x19\n\x0c\n\x04\x04\0\x02F\x12\x04\x88\x01\x02\x1a\n\r\n\x05\x04\0\x02F\
    \x05\x12\x04\x88\x01\x02\x08\n\r\n\x05\x04\0\x02F\x01\x12\x04\x88\x01\t\
    \x12\n\r\n\x05\x04\0\x02F\x03\x12\x04\x88\x01\x15\x19\n\x0c\n\x04\x04\0\
    \x02G\x12\x04\x89\x01\x02\x1b\n\r\n\x05\x04\0\x02G\x05\x12\x04\x89\x01\
    \x02\x08\n\r\n\x05\x04\0\x02G\x01\x12\x04\x89\x01\t\x13\n\r\n\x05\x04\0\
    \x02G\x03\x12\x04\x89\x01\x16\x1a\nR\n\x04\x04\0\x02H\x12\x04\x8b\x01\
    \x02\x1a\"D\x20Protocol\x20Name\x20--\x20set\x20for\x20some\x20well\x20k\
    nown\x20protocols,\x20based\x20on\x20Proto\n\n\r\n\x05\x04\0\x02H\x05\
    \x12\x04\x8b\x01\x02\x08\n\r\n\x05\x04\0\x02H\x01\x12\x04\x8b\x01\t\x12\
    \n\r\n\x05\x04\0\x02H\x03\x12\x04\x8b\x01\x15\x19\n>\n\x04\x04\0\x02I\
    \x12\x04\x8c\x01\x02\x1e\"0\x20Geolocation\x20--\x20set\x20using\x20the\
    \x20provided\x20database\n\n\r\n\x05\x04\0\x02I\x05\x12\x04\x8c\x01\x02\
    \x08\n\r\n\x05\x04\0\x02I\x01\x12\x04\x8c\x01\t\x16\n\r\n\x05\x04\0\x02I\
    \x03\x12\x04\x8c\x01\x19\x1db\x06proto3\
";

static mut file_descriptor_proto_lazy: ::protobuf::lazy::Lazy<::protobuf::descriptor::FileDescriptorProto> = ::protobuf::lazy::Lazy {
    lock: ::protobuf::lazy::ONCE_INIT,
    ptr: 0 as *const ::protobuf::descriptor::FileDescriptorProto,
};

fn parse_descriptor_proto() -> ::protobuf::descriptor::FileDescriptorProto {
    ::protobuf::parse_from_bytes(file_descriptor_proto_data).unwrap()
}

pub fn file_descriptor_proto() -> &'static ::protobuf::descriptor::FileDescriptorProto {
    unsafe {
        file_descriptor_proto_lazy.get(|| {
            parse_descriptor_proto()
        })
    }
}
