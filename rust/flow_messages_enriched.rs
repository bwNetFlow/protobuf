// This file is generated by rust-protobuf 2.0.4. Do not edit
// @generated

// https://github.com/Manishearth/rust-clippy/issues/702
#![allow(unknown_lints)]
#![allow(clippy)]

#![cfg_attr(rustfmt, rustfmt_skip)]

#![allow(box_pointers)]
#![allow(dead_code)]
#![allow(missing_docs)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(non_upper_case_globals)]
#![allow(trivial_casts)]
#![allow(unsafe_code)]
#![allow(unused_imports)]
#![allow(unused_results)]

use protobuf::Message as Message_imported_for_functions;
use protobuf::ProtobufEnum as ProtobufEnum_imported_for_functions;

#[derive(PartialEq,Clone,Default)]
pub struct FlowMessage {
    // message fields
    pub Type: FlowMessage_FlowType,
    pub TimeReceived: u64,
    pub SequenceNum: u32,
    pub SamplingRate: u64,
    pub FlowDirection: u32,
    pub SamplerAddress: ::std::vec::Vec<u8>,
    pub TimeFlowStart: u64,
    pub TimeFlowEnd: u64,
    pub Bytes: u64,
    pub Packets: u64,
    pub SrcAddr: ::std::vec::Vec<u8>,
    pub DstAddr: ::std::vec::Vec<u8>,
    pub Etype: u32,
    pub Proto: u32,
    pub SrcPort: u32,
    pub DstPort: u32,
    pub SrcIf: u32,
    pub DstIf: u32,
    pub SrcMac: u64,
    pub DstMac: u64,
    pub SrcVlan: u32,
    pub DstVlan: u32,
    pub VlanId: u32,
    pub IngressVrfID: u32,
    pub EgressVrfID: u32,
    pub IPTos: u32,
    pub ForwardingStatus: u32,
    pub IPTTL: u32,
    pub TCPFlags: u32,
    pub IcmpType: u32,
    pub IcmpCode: u32,
    pub IPv6FlowLabel: u32,
    pub IPv6ExtensionHeaders: u32,
    pub FragmentId: u32,
    pub FragmentOffset: u32,
    pub BiFlowDirection: u32,
    pub SrcAS: u32,
    pub DstAS: u32,
    pub NextHop: ::std::vec::Vec<u8>,
    pub NextHopAS: u32,
    pub SrcNet: u32,
    pub DstNet: u32,
    pub Cid: u32,
    pub CidString: ::std::string::String,
    pub Normalized: FlowMessage_NormalizedType,
    pub SrcIfName: ::std::string::String,
    pub SrcIfDesc: ::std::string::String,
    pub SrcIfSpeed: u32,
    pub DstIfName: ::std::string::String,
    pub DstIfDesc: ::std::string::String,
    pub DstIfSpeed: u32,
    pub ProtoName: ::std::string::String,
    pub RemoteCountry: ::std::string::String,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

impl FlowMessage {
    pub fn new() -> FlowMessage {
        ::std::default::Default::default()
    }

    // .flowmessageenriched.FlowMessage.FlowType Type = 1;

    pub fn clear_Type(&mut self) {
        self.Type = FlowMessage_FlowType::FLOWUNKNOWN;
    }

    // Param is passed by value, moved
    pub fn set_Type(&mut self, v: FlowMessage_FlowType) {
        self.Type = v;
    }

    pub fn get_Type(&self) -> FlowMessage_FlowType {
        self.Type
    }

    // uint64 TimeReceived = 2;

    pub fn clear_TimeReceived(&mut self) {
        self.TimeReceived = 0;
    }

    // Param is passed by value, moved
    pub fn set_TimeReceived(&mut self, v: u64) {
        self.TimeReceived = v;
    }

    pub fn get_TimeReceived(&self) -> u64 {
        self.TimeReceived
    }

    // uint32 SequenceNum = 4;

    pub fn clear_SequenceNum(&mut self) {
        self.SequenceNum = 0;
    }

    // Param is passed by value, moved
    pub fn set_SequenceNum(&mut self, v: u32) {
        self.SequenceNum = v;
    }

    pub fn get_SequenceNum(&self) -> u32 {
        self.SequenceNum
    }

    // uint64 SamplingRate = 3;

    pub fn clear_SamplingRate(&mut self) {
        self.SamplingRate = 0;
    }

    // Param is passed by value, moved
    pub fn set_SamplingRate(&mut self, v: u64) {
        self.SamplingRate = v;
    }

    pub fn get_SamplingRate(&self) -> u64 {
        self.SamplingRate
    }

    // uint32 FlowDirection = 42;

    pub fn clear_FlowDirection(&mut self) {
        self.FlowDirection = 0;
    }

    // Param is passed by value, moved
    pub fn set_FlowDirection(&mut self, v: u32) {
        self.FlowDirection = v;
    }

    pub fn get_FlowDirection(&self) -> u32 {
        self.FlowDirection
    }

    // bytes SamplerAddress = 11;

    pub fn clear_SamplerAddress(&mut self) {
        self.SamplerAddress.clear();
    }

    // Param is passed by value, moved
    pub fn set_SamplerAddress(&mut self, v: ::std::vec::Vec<u8>) {
        self.SamplerAddress = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_SamplerAddress(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.SamplerAddress
    }

    // Take field
    pub fn take_SamplerAddress(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.SamplerAddress, ::std::vec::Vec::new())
    }

    pub fn get_SamplerAddress(&self) -> &[u8] {
        &self.SamplerAddress
    }

    // uint64 TimeFlowStart = 38;

    pub fn clear_TimeFlowStart(&mut self) {
        self.TimeFlowStart = 0;
    }

    // Param is passed by value, moved
    pub fn set_TimeFlowStart(&mut self, v: u64) {
        self.TimeFlowStart = v;
    }

    pub fn get_TimeFlowStart(&self) -> u64 {
        self.TimeFlowStart
    }

    // uint64 TimeFlowEnd = 5;

    pub fn clear_TimeFlowEnd(&mut self) {
        self.TimeFlowEnd = 0;
    }

    // Param is passed by value, moved
    pub fn set_TimeFlowEnd(&mut self, v: u64) {
        self.TimeFlowEnd = v;
    }

    pub fn get_TimeFlowEnd(&self) -> u64 {
        self.TimeFlowEnd
    }

    // uint64 Bytes = 9;

    pub fn clear_Bytes(&mut self) {
        self.Bytes = 0;
    }

    // Param is passed by value, moved
    pub fn set_Bytes(&mut self, v: u64) {
        self.Bytes = v;
    }

    pub fn get_Bytes(&self) -> u64 {
        self.Bytes
    }

    // uint64 Packets = 10;

    pub fn clear_Packets(&mut self) {
        self.Packets = 0;
    }

    // Param is passed by value, moved
    pub fn set_Packets(&mut self, v: u64) {
        self.Packets = v;
    }

    pub fn get_Packets(&self) -> u64 {
        self.Packets
    }

    // bytes SrcAddr = 6;

    pub fn clear_SrcAddr(&mut self) {
        self.SrcAddr.clear();
    }

    // Param is passed by value, moved
    pub fn set_SrcAddr(&mut self, v: ::std::vec::Vec<u8>) {
        self.SrcAddr = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_SrcAddr(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.SrcAddr
    }

    // Take field
    pub fn take_SrcAddr(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.SrcAddr, ::std::vec::Vec::new())
    }

    pub fn get_SrcAddr(&self) -> &[u8] {
        &self.SrcAddr
    }

    // bytes DstAddr = 7;

    pub fn clear_DstAddr(&mut self) {
        self.DstAddr.clear();
    }

    // Param is passed by value, moved
    pub fn set_DstAddr(&mut self, v: ::std::vec::Vec<u8>) {
        self.DstAddr = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_DstAddr(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.DstAddr
    }

    // Take field
    pub fn take_DstAddr(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.DstAddr, ::std::vec::Vec::new())
    }

    pub fn get_DstAddr(&self) -> &[u8] {
        &self.DstAddr
    }

    // uint32 Etype = 30;

    pub fn clear_Etype(&mut self) {
        self.Etype = 0;
    }

    // Param is passed by value, moved
    pub fn set_Etype(&mut self, v: u32) {
        self.Etype = v;
    }

    pub fn get_Etype(&self) -> u32 {
        self.Etype
    }

    // uint32 Proto = 20;

    pub fn clear_Proto(&mut self) {
        self.Proto = 0;
    }

    // Param is passed by value, moved
    pub fn set_Proto(&mut self, v: u32) {
        self.Proto = v;
    }

    pub fn get_Proto(&self) -> u32 {
        self.Proto
    }

    // uint32 SrcPort = 21;

    pub fn clear_SrcPort(&mut self) {
        self.SrcPort = 0;
    }

    // Param is passed by value, moved
    pub fn set_SrcPort(&mut self, v: u32) {
        self.SrcPort = v;
    }

    pub fn get_SrcPort(&self) -> u32 {
        self.SrcPort
    }

    // uint32 DstPort = 22;

    pub fn clear_DstPort(&mut self) {
        self.DstPort = 0;
    }

    // Param is passed by value, moved
    pub fn set_DstPort(&mut self, v: u32) {
        self.DstPort = v;
    }

    pub fn get_DstPort(&self) -> u32 {
        self.DstPort
    }

    // uint32 SrcIf = 18;

    pub fn clear_SrcIf(&mut self) {
        self.SrcIf = 0;
    }

    // Param is passed by value, moved
    pub fn set_SrcIf(&mut self, v: u32) {
        self.SrcIf = v;
    }

    pub fn get_SrcIf(&self) -> u32 {
        self.SrcIf
    }

    // uint32 DstIf = 19;

    pub fn clear_DstIf(&mut self) {
        self.DstIf = 0;
    }

    // Param is passed by value, moved
    pub fn set_DstIf(&mut self, v: u32) {
        self.DstIf = v;
    }

    pub fn get_DstIf(&self) -> u32 {
        self.DstIf
    }

    // uint64 SrcMac = 27;

    pub fn clear_SrcMac(&mut self) {
        self.SrcMac = 0;
    }

    // Param is passed by value, moved
    pub fn set_SrcMac(&mut self, v: u64) {
        self.SrcMac = v;
    }

    pub fn get_SrcMac(&self) -> u64 {
        self.SrcMac
    }

    // uint64 DstMac = 28;

    pub fn clear_DstMac(&mut self) {
        self.DstMac = 0;
    }

    // Param is passed by value, moved
    pub fn set_DstMac(&mut self, v: u64) {
        self.DstMac = v;
    }

    pub fn get_DstMac(&self) -> u64 {
        self.DstMac
    }

    // uint32 SrcVlan = 33;

    pub fn clear_SrcVlan(&mut self) {
        self.SrcVlan = 0;
    }

    // Param is passed by value, moved
    pub fn set_SrcVlan(&mut self, v: u32) {
        self.SrcVlan = v;
    }

    pub fn get_SrcVlan(&self) -> u32 {
        self.SrcVlan
    }

    // uint32 DstVlan = 34;

    pub fn clear_DstVlan(&mut self) {
        self.DstVlan = 0;
    }

    // Param is passed by value, moved
    pub fn set_DstVlan(&mut self, v: u32) {
        self.DstVlan = v;
    }

    pub fn get_DstVlan(&self) -> u32 {
        self.DstVlan
    }

    // uint32 VlanId = 29;

    pub fn clear_VlanId(&mut self) {
        self.VlanId = 0;
    }

    // Param is passed by value, moved
    pub fn set_VlanId(&mut self, v: u32) {
        self.VlanId = v;
    }

    pub fn get_VlanId(&self) -> u32 {
        self.VlanId
    }

    // uint32 IngressVrfID = 39;

    pub fn clear_IngressVrfID(&mut self) {
        self.IngressVrfID = 0;
    }

    // Param is passed by value, moved
    pub fn set_IngressVrfID(&mut self, v: u32) {
        self.IngressVrfID = v;
    }

    pub fn get_IngressVrfID(&self) -> u32 {
        self.IngressVrfID
    }

    // uint32 EgressVrfID = 40;

    pub fn clear_EgressVrfID(&mut self) {
        self.EgressVrfID = 0;
    }

    // Param is passed by value, moved
    pub fn set_EgressVrfID(&mut self, v: u32) {
        self.EgressVrfID = v;
    }

    pub fn get_EgressVrfID(&self) -> u32 {
        self.EgressVrfID
    }

    // uint32 IPTos = 23;

    pub fn clear_IPTos(&mut self) {
        self.IPTos = 0;
    }

    // Param is passed by value, moved
    pub fn set_IPTos(&mut self, v: u32) {
        self.IPTos = v;
    }

    pub fn get_IPTos(&self) -> u32 {
        self.IPTos
    }

    // uint32 ForwardingStatus = 24;

    pub fn clear_ForwardingStatus(&mut self) {
        self.ForwardingStatus = 0;
    }

    // Param is passed by value, moved
    pub fn set_ForwardingStatus(&mut self, v: u32) {
        self.ForwardingStatus = v;
    }

    pub fn get_ForwardingStatus(&self) -> u32 {
        self.ForwardingStatus
    }

    // uint32 IPTTL = 25;

    pub fn clear_IPTTL(&mut self) {
        self.IPTTL = 0;
    }

    // Param is passed by value, moved
    pub fn set_IPTTL(&mut self, v: u32) {
        self.IPTTL = v;
    }

    pub fn get_IPTTL(&self) -> u32 {
        self.IPTTL
    }

    // uint32 TCPFlags = 26;

    pub fn clear_TCPFlags(&mut self) {
        self.TCPFlags = 0;
    }

    // Param is passed by value, moved
    pub fn set_TCPFlags(&mut self, v: u32) {
        self.TCPFlags = v;
    }

    pub fn get_TCPFlags(&self) -> u32 {
        self.TCPFlags
    }

    // uint32 IcmpType = 31;

    pub fn clear_IcmpType(&mut self) {
        self.IcmpType = 0;
    }

    // Param is passed by value, moved
    pub fn set_IcmpType(&mut self, v: u32) {
        self.IcmpType = v;
    }

    pub fn get_IcmpType(&self) -> u32 {
        self.IcmpType
    }

    // uint32 IcmpCode = 32;

    pub fn clear_IcmpCode(&mut self) {
        self.IcmpCode = 0;
    }

    // Param is passed by value, moved
    pub fn set_IcmpCode(&mut self, v: u32) {
        self.IcmpCode = v;
    }

    pub fn get_IcmpCode(&self) -> u32 {
        self.IcmpCode
    }

    // uint32 IPv6FlowLabel = 37;

    pub fn clear_IPv6FlowLabel(&mut self) {
        self.IPv6FlowLabel = 0;
    }

    // Param is passed by value, moved
    pub fn set_IPv6FlowLabel(&mut self, v: u32) {
        self.IPv6FlowLabel = v;
    }

    pub fn get_IPv6FlowLabel(&self) -> u32 {
        self.IPv6FlowLabel
    }

    // uint32 IPv6ExtensionHeaders = 43;

    pub fn clear_IPv6ExtensionHeaders(&mut self) {
        self.IPv6ExtensionHeaders = 0;
    }

    // Param is passed by value, moved
    pub fn set_IPv6ExtensionHeaders(&mut self, v: u32) {
        self.IPv6ExtensionHeaders = v;
    }

    pub fn get_IPv6ExtensionHeaders(&self) -> u32 {
        self.IPv6ExtensionHeaders
    }

    // uint32 FragmentId = 35;

    pub fn clear_FragmentId(&mut self) {
        self.FragmentId = 0;
    }

    // Param is passed by value, moved
    pub fn set_FragmentId(&mut self, v: u32) {
        self.FragmentId = v;
    }

    pub fn get_FragmentId(&self) -> u32 {
        self.FragmentId
    }

    // uint32 FragmentOffset = 36;

    pub fn clear_FragmentOffset(&mut self) {
        self.FragmentOffset = 0;
    }

    // Param is passed by value, moved
    pub fn set_FragmentOffset(&mut self, v: u32) {
        self.FragmentOffset = v;
    }

    pub fn get_FragmentOffset(&self) -> u32 {
        self.FragmentOffset
    }

    // uint32 BiFlowDirection = 41;

    pub fn clear_BiFlowDirection(&mut self) {
        self.BiFlowDirection = 0;
    }

    // Param is passed by value, moved
    pub fn set_BiFlowDirection(&mut self, v: u32) {
        self.BiFlowDirection = v;
    }

    pub fn get_BiFlowDirection(&self) -> u32 {
        self.BiFlowDirection
    }

    // uint32 SrcAS = 14;

    pub fn clear_SrcAS(&mut self) {
        self.SrcAS = 0;
    }

    // Param is passed by value, moved
    pub fn set_SrcAS(&mut self, v: u32) {
        self.SrcAS = v;
    }

    pub fn get_SrcAS(&self) -> u32 {
        self.SrcAS
    }

    // uint32 DstAS = 15;

    pub fn clear_DstAS(&mut self) {
        self.DstAS = 0;
    }

    // Param is passed by value, moved
    pub fn set_DstAS(&mut self, v: u32) {
        self.DstAS = v;
    }

    pub fn get_DstAS(&self) -> u32 {
        self.DstAS
    }

    // bytes NextHop = 12;

    pub fn clear_NextHop(&mut self) {
        self.NextHop.clear();
    }

    // Param is passed by value, moved
    pub fn set_NextHop(&mut self, v: ::std::vec::Vec<u8>) {
        self.NextHop = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_NextHop(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.NextHop
    }

    // Take field
    pub fn take_NextHop(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.NextHop, ::std::vec::Vec::new())
    }

    pub fn get_NextHop(&self) -> &[u8] {
        &self.NextHop
    }

    // uint32 NextHopAS = 13;

    pub fn clear_NextHopAS(&mut self) {
        self.NextHopAS = 0;
    }

    // Param is passed by value, moved
    pub fn set_NextHopAS(&mut self, v: u32) {
        self.NextHopAS = v;
    }

    pub fn get_NextHopAS(&self) -> u32 {
        self.NextHopAS
    }

    // uint32 SrcNet = 16;

    pub fn clear_SrcNet(&mut self) {
        self.SrcNet = 0;
    }

    // Param is passed by value, moved
    pub fn set_SrcNet(&mut self, v: u32) {
        self.SrcNet = v;
    }

    pub fn get_SrcNet(&self) -> u32 {
        self.SrcNet
    }

    // uint32 DstNet = 17;

    pub fn clear_DstNet(&mut self) {
        self.DstNet = 0;
    }

    // Param is passed by value, moved
    pub fn set_DstNet(&mut self, v: u32) {
        self.DstNet = v;
    }

    pub fn get_DstNet(&self) -> u32 {
        self.DstNet
    }

    // uint32 Cid = 1000;

    pub fn clear_Cid(&mut self) {
        self.Cid = 0;
    }

    // Param is passed by value, moved
    pub fn set_Cid(&mut self, v: u32) {
        self.Cid = v;
    }

    pub fn get_Cid(&self) -> u32 {
        self.Cid
    }

    // string CidString = 1001;

    pub fn clear_CidString(&mut self) {
        self.CidString.clear();
    }

    // Param is passed by value, moved
    pub fn set_CidString(&mut self, v: ::std::string::String) {
        self.CidString = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_CidString(&mut self) -> &mut ::std::string::String {
        &mut self.CidString
    }

    // Take field
    pub fn take_CidString(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.CidString, ::std::string::String::new())
    }

    pub fn get_CidString(&self) -> &str {
        &self.CidString
    }

    // .flowmessageenriched.FlowMessage.NormalizedType Normalized = 1002;

    pub fn clear_Normalized(&mut self) {
        self.Normalized = FlowMessage_NormalizedType::No;
    }

    // Param is passed by value, moved
    pub fn set_Normalized(&mut self, v: FlowMessage_NormalizedType) {
        self.Normalized = v;
    }

    pub fn get_Normalized(&self) -> FlowMessage_NormalizedType {
        self.Normalized
    }

    // string SrcIfName = 1003;

    pub fn clear_SrcIfName(&mut self) {
        self.SrcIfName.clear();
    }

    // Param is passed by value, moved
    pub fn set_SrcIfName(&mut self, v: ::std::string::String) {
        self.SrcIfName = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_SrcIfName(&mut self) -> &mut ::std::string::String {
        &mut self.SrcIfName
    }

    // Take field
    pub fn take_SrcIfName(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.SrcIfName, ::std::string::String::new())
    }

    pub fn get_SrcIfName(&self) -> &str {
        &self.SrcIfName
    }

    // string SrcIfDesc = 1004;

    pub fn clear_SrcIfDesc(&mut self) {
        self.SrcIfDesc.clear();
    }

    // Param is passed by value, moved
    pub fn set_SrcIfDesc(&mut self, v: ::std::string::String) {
        self.SrcIfDesc = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_SrcIfDesc(&mut self) -> &mut ::std::string::String {
        &mut self.SrcIfDesc
    }

    // Take field
    pub fn take_SrcIfDesc(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.SrcIfDesc, ::std::string::String::new())
    }

    pub fn get_SrcIfDesc(&self) -> &str {
        &self.SrcIfDesc
    }

    // uint32 SrcIfSpeed = 1005;

    pub fn clear_SrcIfSpeed(&mut self) {
        self.SrcIfSpeed = 0;
    }

    // Param is passed by value, moved
    pub fn set_SrcIfSpeed(&mut self, v: u32) {
        self.SrcIfSpeed = v;
    }

    pub fn get_SrcIfSpeed(&self) -> u32 {
        self.SrcIfSpeed
    }

    // string DstIfName = 1006;

    pub fn clear_DstIfName(&mut self) {
        self.DstIfName.clear();
    }

    // Param is passed by value, moved
    pub fn set_DstIfName(&mut self, v: ::std::string::String) {
        self.DstIfName = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_DstIfName(&mut self) -> &mut ::std::string::String {
        &mut self.DstIfName
    }

    // Take field
    pub fn take_DstIfName(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.DstIfName, ::std::string::String::new())
    }

    pub fn get_DstIfName(&self) -> &str {
        &self.DstIfName
    }

    // string DstIfDesc = 1007;

    pub fn clear_DstIfDesc(&mut self) {
        self.DstIfDesc.clear();
    }

    // Param is passed by value, moved
    pub fn set_DstIfDesc(&mut self, v: ::std::string::String) {
        self.DstIfDesc = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_DstIfDesc(&mut self) -> &mut ::std::string::String {
        &mut self.DstIfDesc
    }

    // Take field
    pub fn take_DstIfDesc(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.DstIfDesc, ::std::string::String::new())
    }

    pub fn get_DstIfDesc(&self) -> &str {
        &self.DstIfDesc
    }

    // uint32 DstIfSpeed = 1008;

    pub fn clear_DstIfSpeed(&mut self) {
        self.DstIfSpeed = 0;
    }

    // Param is passed by value, moved
    pub fn set_DstIfSpeed(&mut self, v: u32) {
        self.DstIfSpeed = v;
    }

    pub fn get_DstIfSpeed(&self) -> u32 {
        self.DstIfSpeed
    }

    // string ProtoName = 1009;

    pub fn clear_ProtoName(&mut self) {
        self.ProtoName.clear();
    }

    // Param is passed by value, moved
    pub fn set_ProtoName(&mut self, v: ::std::string::String) {
        self.ProtoName = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_ProtoName(&mut self) -> &mut ::std::string::String {
        &mut self.ProtoName
    }

    // Take field
    pub fn take_ProtoName(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.ProtoName, ::std::string::String::new())
    }

    pub fn get_ProtoName(&self) -> &str {
        &self.ProtoName
    }

    // string RemoteCountry = 1010;

    pub fn clear_RemoteCountry(&mut self) {
        self.RemoteCountry.clear();
    }

    // Param is passed by value, moved
    pub fn set_RemoteCountry(&mut self, v: ::std::string::String) {
        self.RemoteCountry = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_RemoteCountry(&mut self) -> &mut ::std::string::String {
        &mut self.RemoteCountry
    }

    // Take field
    pub fn take_RemoteCountry(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.RemoteCountry, ::std::string::String::new())
    }

    pub fn get_RemoteCountry(&self) -> &str {
        &self.RemoteCountry
    }
}

impl ::protobuf::Message for FlowMessage {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.Type, 1, &mut self.unknown_fields)?
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.TimeReceived = tmp;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.SequenceNum = tmp;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.SamplingRate = tmp;
                },
                42 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.FlowDirection = tmp;
                },
                11 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.SamplerAddress)?;
                },
                38 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.TimeFlowStart = tmp;
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.TimeFlowEnd = tmp;
                },
                9 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.Bytes = tmp;
                },
                10 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.Packets = tmp;
                },
                6 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.SrcAddr)?;
                },
                7 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.DstAddr)?;
                },
                30 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.Etype = tmp;
                },
                20 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.Proto = tmp;
                },
                21 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.SrcPort = tmp;
                },
                22 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.DstPort = tmp;
                },
                18 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.SrcIf = tmp;
                },
                19 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.DstIf = tmp;
                },
                27 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.SrcMac = tmp;
                },
                28 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.DstMac = tmp;
                },
                33 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.SrcVlan = tmp;
                },
                34 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.DstVlan = tmp;
                },
                29 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.VlanId = tmp;
                },
                39 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.IngressVrfID = tmp;
                },
                40 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.EgressVrfID = tmp;
                },
                23 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.IPTos = tmp;
                },
                24 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.ForwardingStatus = tmp;
                },
                25 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.IPTTL = tmp;
                },
                26 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.TCPFlags = tmp;
                },
                31 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.IcmpType = tmp;
                },
                32 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.IcmpCode = tmp;
                },
                37 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.IPv6FlowLabel = tmp;
                },
                43 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.IPv6ExtensionHeaders = tmp;
                },
                35 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.FragmentId = tmp;
                },
                36 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.FragmentOffset = tmp;
                },
                41 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.BiFlowDirection = tmp;
                },
                14 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.SrcAS = tmp;
                },
                15 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.DstAS = tmp;
                },
                12 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.NextHop)?;
                },
                13 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.NextHopAS = tmp;
                },
                16 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.SrcNet = tmp;
                },
                17 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.DstNet = tmp;
                },
                1000 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.Cid = tmp;
                },
                1001 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.CidString)?;
                },
                1002 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.Normalized, 1002, &mut self.unknown_fields)?
                },
                1003 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.SrcIfName)?;
                },
                1004 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.SrcIfDesc)?;
                },
                1005 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.SrcIfSpeed = tmp;
                },
                1006 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.DstIfName)?;
                },
                1007 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.DstIfDesc)?;
                },
                1008 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.DstIfSpeed = tmp;
                },
                1009 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.ProtoName)?;
                },
                1010 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.RemoteCountry)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.Type != FlowMessage_FlowType::FLOWUNKNOWN {
            my_size += ::protobuf::rt::enum_size(1, self.Type);
        }
        if self.TimeReceived != 0 {
            my_size += ::protobuf::rt::value_size(2, self.TimeReceived, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.SequenceNum != 0 {
            my_size += ::protobuf::rt::value_size(4, self.SequenceNum, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.SamplingRate != 0 {
            my_size += ::protobuf::rt::value_size(3, self.SamplingRate, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.FlowDirection != 0 {
            my_size += ::protobuf::rt::value_size(42, self.FlowDirection, ::protobuf::wire_format::WireTypeVarint);
        }
        if !self.SamplerAddress.is_empty() {
            my_size += ::protobuf::rt::bytes_size(11, &self.SamplerAddress);
        }
        if self.TimeFlowStart != 0 {
            my_size += ::protobuf::rt::value_size(38, self.TimeFlowStart, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.TimeFlowEnd != 0 {
            my_size += ::protobuf::rt::value_size(5, self.TimeFlowEnd, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.Bytes != 0 {
            my_size += ::protobuf::rt::value_size(9, self.Bytes, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.Packets != 0 {
            my_size += ::protobuf::rt::value_size(10, self.Packets, ::protobuf::wire_format::WireTypeVarint);
        }
        if !self.SrcAddr.is_empty() {
            my_size += ::protobuf::rt::bytes_size(6, &self.SrcAddr);
        }
        if !self.DstAddr.is_empty() {
            my_size += ::protobuf::rt::bytes_size(7, &self.DstAddr);
        }
        if self.Etype != 0 {
            my_size += ::protobuf::rt::value_size(30, self.Etype, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.Proto != 0 {
            my_size += ::protobuf::rt::value_size(20, self.Proto, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.SrcPort != 0 {
            my_size += ::protobuf::rt::value_size(21, self.SrcPort, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.DstPort != 0 {
            my_size += ::protobuf::rt::value_size(22, self.DstPort, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.SrcIf != 0 {
            my_size += ::protobuf::rt::value_size(18, self.SrcIf, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.DstIf != 0 {
            my_size += ::protobuf::rt::value_size(19, self.DstIf, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.SrcMac != 0 {
            my_size += ::protobuf::rt::value_size(27, self.SrcMac, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.DstMac != 0 {
            my_size += ::protobuf::rt::value_size(28, self.DstMac, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.SrcVlan != 0 {
            my_size += ::protobuf::rt::value_size(33, self.SrcVlan, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.DstVlan != 0 {
            my_size += ::protobuf::rt::value_size(34, self.DstVlan, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.VlanId != 0 {
            my_size += ::protobuf::rt::value_size(29, self.VlanId, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.IngressVrfID != 0 {
            my_size += ::protobuf::rt::value_size(39, self.IngressVrfID, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.EgressVrfID != 0 {
            my_size += ::protobuf::rt::value_size(40, self.EgressVrfID, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.IPTos != 0 {
            my_size += ::protobuf::rt::value_size(23, self.IPTos, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.ForwardingStatus != 0 {
            my_size += ::protobuf::rt::value_size(24, self.ForwardingStatus, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.IPTTL != 0 {
            my_size += ::protobuf::rt::value_size(25, self.IPTTL, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.TCPFlags != 0 {
            my_size += ::protobuf::rt::value_size(26, self.TCPFlags, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.IcmpType != 0 {
            my_size += ::protobuf::rt::value_size(31, self.IcmpType, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.IcmpCode != 0 {
            my_size += ::protobuf::rt::value_size(32, self.IcmpCode, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.IPv6FlowLabel != 0 {
            my_size += ::protobuf::rt::value_size(37, self.IPv6FlowLabel, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.IPv6ExtensionHeaders != 0 {
            my_size += ::protobuf::rt::value_size(43, self.IPv6ExtensionHeaders, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.FragmentId != 0 {
            my_size += ::protobuf::rt::value_size(35, self.FragmentId, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.FragmentOffset != 0 {
            my_size += ::protobuf::rt::value_size(36, self.FragmentOffset, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.BiFlowDirection != 0 {
            my_size += ::protobuf::rt::value_size(41, self.BiFlowDirection, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.SrcAS != 0 {
            my_size += ::protobuf::rt::value_size(14, self.SrcAS, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.DstAS != 0 {
            my_size += ::protobuf::rt::value_size(15, self.DstAS, ::protobuf::wire_format::WireTypeVarint);
        }
        if !self.NextHop.is_empty() {
            my_size += ::protobuf::rt::bytes_size(12, &self.NextHop);
        }
        if self.NextHopAS != 0 {
            my_size += ::protobuf::rt::value_size(13, self.NextHopAS, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.SrcNet != 0 {
            my_size += ::protobuf::rt::value_size(16, self.SrcNet, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.DstNet != 0 {
            my_size += ::protobuf::rt::value_size(17, self.DstNet, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.Cid != 0 {
            my_size += ::protobuf::rt::value_size(1000, self.Cid, ::protobuf::wire_format::WireTypeVarint);
        }
        if !self.CidString.is_empty() {
            my_size += ::protobuf::rt::string_size(1001, &self.CidString);
        }
        if self.Normalized != FlowMessage_NormalizedType::No {
            my_size += ::protobuf::rt::enum_size(1002, self.Normalized);
        }
        if !self.SrcIfName.is_empty() {
            my_size += ::protobuf::rt::string_size(1003, &self.SrcIfName);
        }
        if !self.SrcIfDesc.is_empty() {
            my_size += ::protobuf::rt::string_size(1004, &self.SrcIfDesc);
        }
        if self.SrcIfSpeed != 0 {
            my_size += ::protobuf::rt::value_size(1005, self.SrcIfSpeed, ::protobuf::wire_format::WireTypeVarint);
        }
        if !self.DstIfName.is_empty() {
            my_size += ::protobuf::rt::string_size(1006, &self.DstIfName);
        }
        if !self.DstIfDesc.is_empty() {
            my_size += ::protobuf::rt::string_size(1007, &self.DstIfDesc);
        }
        if self.DstIfSpeed != 0 {
            my_size += ::protobuf::rt::value_size(1008, self.DstIfSpeed, ::protobuf::wire_format::WireTypeVarint);
        }
        if !self.ProtoName.is_empty() {
            my_size += ::protobuf::rt::string_size(1009, &self.ProtoName);
        }
        if !self.RemoteCountry.is_empty() {
            my_size += ::protobuf::rt::string_size(1010, &self.RemoteCountry);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if self.Type != FlowMessage_FlowType::FLOWUNKNOWN {
            os.write_enum(1, self.Type.value())?;
        }
        if self.TimeReceived != 0 {
            os.write_uint64(2, self.TimeReceived)?;
        }
        if self.SequenceNum != 0 {
            os.write_uint32(4, self.SequenceNum)?;
        }
        if self.SamplingRate != 0 {
            os.write_uint64(3, self.SamplingRate)?;
        }
        if self.FlowDirection != 0 {
            os.write_uint32(42, self.FlowDirection)?;
        }
        if !self.SamplerAddress.is_empty() {
            os.write_bytes(11, &self.SamplerAddress)?;
        }
        if self.TimeFlowStart != 0 {
            os.write_uint64(38, self.TimeFlowStart)?;
        }
        if self.TimeFlowEnd != 0 {
            os.write_uint64(5, self.TimeFlowEnd)?;
        }
        if self.Bytes != 0 {
            os.write_uint64(9, self.Bytes)?;
        }
        if self.Packets != 0 {
            os.write_uint64(10, self.Packets)?;
        }
        if !self.SrcAddr.is_empty() {
            os.write_bytes(6, &self.SrcAddr)?;
        }
        if !self.DstAddr.is_empty() {
            os.write_bytes(7, &self.DstAddr)?;
        }
        if self.Etype != 0 {
            os.write_uint32(30, self.Etype)?;
        }
        if self.Proto != 0 {
            os.write_uint32(20, self.Proto)?;
        }
        if self.SrcPort != 0 {
            os.write_uint32(21, self.SrcPort)?;
        }
        if self.DstPort != 0 {
            os.write_uint32(22, self.DstPort)?;
        }
        if self.SrcIf != 0 {
            os.write_uint32(18, self.SrcIf)?;
        }
        if self.DstIf != 0 {
            os.write_uint32(19, self.DstIf)?;
        }
        if self.SrcMac != 0 {
            os.write_uint64(27, self.SrcMac)?;
        }
        if self.DstMac != 0 {
            os.write_uint64(28, self.DstMac)?;
        }
        if self.SrcVlan != 0 {
            os.write_uint32(33, self.SrcVlan)?;
        }
        if self.DstVlan != 0 {
            os.write_uint32(34, self.DstVlan)?;
        }
        if self.VlanId != 0 {
            os.write_uint32(29, self.VlanId)?;
        }
        if self.IngressVrfID != 0 {
            os.write_uint32(39, self.IngressVrfID)?;
        }
        if self.EgressVrfID != 0 {
            os.write_uint32(40, self.EgressVrfID)?;
        }
        if self.IPTos != 0 {
            os.write_uint32(23, self.IPTos)?;
        }
        if self.ForwardingStatus != 0 {
            os.write_uint32(24, self.ForwardingStatus)?;
        }
        if self.IPTTL != 0 {
            os.write_uint32(25, self.IPTTL)?;
        }
        if self.TCPFlags != 0 {
            os.write_uint32(26, self.TCPFlags)?;
        }
        if self.IcmpType != 0 {
            os.write_uint32(31, self.IcmpType)?;
        }
        if self.IcmpCode != 0 {
            os.write_uint32(32, self.IcmpCode)?;
        }
        if self.IPv6FlowLabel != 0 {
            os.write_uint32(37, self.IPv6FlowLabel)?;
        }
        if self.IPv6ExtensionHeaders != 0 {
            os.write_uint32(43, self.IPv6ExtensionHeaders)?;
        }
        if self.FragmentId != 0 {
            os.write_uint32(35, self.FragmentId)?;
        }
        if self.FragmentOffset != 0 {
            os.write_uint32(36, self.FragmentOffset)?;
        }
        if self.BiFlowDirection != 0 {
            os.write_uint32(41, self.BiFlowDirection)?;
        }
        if self.SrcAS != 0 {
            os.write_uint32(14, self.SrcAS)?;
        }
        if self.DstAS != 0 {
            os.write_uint32(15, self.DstAS)?;
        }
        if !self.NextHop.is_empty() {
            os.write_bytes(12, &self.NextHop)?;
        }
        if self.NextHopAS != 0 {
            os.write_uint32(13, self.NextHopAS)?;
        }
        if self.SrcNet != 0 {
            os.write_uint32(16, self.SrcNet)?;
        }
        if self.DstNet != 0 {
            os.write_uint32(17, self.DstNet)?;
        }
        if self.Cid != 0 {
            os.write_uint32(1000, self.Cid)?;
        }
        if !self.CidString.is_empty() {
            os.write_string(1001, &self.CidString)?;
        }
        if self.Normalized != FlowMessage_NormalizedType::No {
            os.write_enum(1002, self.Normalized.value())?;
        }
        if !self.SrcIfName.is_empty() {
            os.write_string(1003, &self.SrcIfName)?;
        }
        if !self.SrcIfDesc.is_empty() {
            os.write_string(1004, &self.SrcIfDesc)?;
        }
        if self.SrcIfSpeed != 0 {
            os.write_uint32(1005, self.SrcIfSpeed)?;
        }
        if !self.DstIfName.is_empty() {
            os.write_string(1006, &self.DstIfName)?;
        }
        if !self.DstIfDesc.is_empty() {
            os.write_string(1007, &self.DstIfDesc)?;
        }
        if self.DstIfSpeed != 0 {
            os.write_uint32(1008, self.DstIfSpeed)?;
        }
        if !self.ProtoName.is_empty() {
            os.write_string(1009, &self.ProtoName)?;
        }
        if !self.RemoteCountry.is_empty() {
            os.write_string(1010, &self.RemoteCountry)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> FlowMessage {
        FlowMessage::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<FlowMessage_FlowType>>(
                    "Type",
                    |m: &FlowMessage| { &m.Type },
                    |m: &mut FlowMessage| { &mut m.Type },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "TimeReceived",
                    |m: &FlowMessage| { &m.TimeReceived },
                    |m: &mut FlowMessage| { &mut m.TimeReceived },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "SequenceNum",
                    |m: &FlowMessage| { &m.SequenceNum },
                    |m: &mut FlowMessage| { &mut m.SequenceNum },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "SamplingRate",
                    |m: &FlowMessage| { &m.SamplingRate },
                    |m: &mut FlowMessage| { &mut m.SamplingRate },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "FlowDirection",
                    |m: &FlowMessage| { &m.FlowDirection },
                    |m: &mut FlowMessage| { &mut m.FlowDirection },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "SamplerAddress",
                    |m: &FlowMessage| { &m.SamplerAddress },
                    |m: &mut FlowMessage| { &mut m.SamplerAddress },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "TimeFlowStart",
                    |m: &FlowMessage| { &m.TimeFlowStart },
                    |m: &mut FlowMessage| { &mut m.TimeFlowStart },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "TimeFlowEnd",
                    |m: &FlowMessage| { &m.TimeFlowEnd },
                    |m: &mut FlowMessage| { &mut m.TimeFlowEnd },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "Bytes",
                    |m: &FlowMessage| { &m.Bytes },
                    |m: &mut FlowMessage| { &mut m.Bytes },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "Packets",
                    |m: &FlowMessage| { &m.Packets },
                    |m: &mut FlowMessage| { &mut m.Packets },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "SrcAddr",
                    |m: &FlowMessage| { &m.SrcAddr },
                    |m: &mut FlowMessage| { &mut m.SrcAddr },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "DstAddr",
                    |m: &FlowMessage| { &m.DstAddr },
                    |m: &mut FlowMessage| { &mut m.DstAddr },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "Etype",
                    |m: &FlowMessage| { &m.Etype },
                    |m: &mut FlowMessage| { &mut m.Etype },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "Proto",
                    |m: &FlowMessage| { &m.Proto },
                    |m: &mut FlowMessage| { &mut m.Proto },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "SrcPort",
                    |m: &FlowMessage| { &m.SrcPort },
                    |m: &mut FlowMessage| { &mut m.SrcPort },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "DstPort",
                    |m: &FlowMessage| { &m.DstPort },
                    |m: &mut FlowMessage| { &mut m.DstPort },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "SrcIf",
                    |m: &FlowMessage| { &m.SrcIf },
                    |m: &mut FlowMessage| { &mut m.SrcIf },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "DstIf",
                    |m: &FlowMessage| { &m.DstIf },
                    |m: &mut FlowMessage| { &mut m.DstIf },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "SrcMac",
                    |m: &FlowMessage| { &m.SrcMac },
                    |m: &mut FlowMessage| { &mut m.SrcMac },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "DstMac",
                    |m: &FlowMessage| { &m.DstMac },
                    |m: &mut FlowMessage| { &mut m.DstMac },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "SrcVlan",
                    |m: &FlowMessage| { &m.SrcVlan },
                    |m: &mut FlowMessage| { &mut m.SrcVlan },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "DstVlan",
                    |m: &FlowMessage| { &m.DstVlan },
                    |m: &mut FlowMessage| { &mut m.DstVlan },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "VlanId",
                    |m: &FlowMessage| { &m.VlanId },
                    |m: &mut FlowMessage| { &mut m.VlanId },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "IngressVrfID",
                    |m: &FlowMessage| { &m.IngressVrfID },
                    |m: &mut FlowMessage| { &mut m.IngressVrfID },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "EgressVrfID",
                    |m: &FlowMessage| { &m.EgressVrfID },
                    |m: &mut FlowMessage| { &mut m.EgressVrfID },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "IPTos",
                    |m: &FlowMessage| { &m.IPTos },
                    |m: &mut FlowMessage| { &mut m.IPTos },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "ForwardingStatus",
                    |m: &FlowMessage| { &m.ForwardingStatus },
                    |m: &mut FlowMessage| { &mut m.ForwardingStatus },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "IPTTL",
                    |m: &FlowMessage| { &m.IPTTL },
                    |m: &mut FlowMessage| { &mut m.IPTTL },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "TCPFlags",
                    |m: &FlowMessage| { &m.TCPFlags },
                    |m: &mut FlowMessage| { &mut m.TCPFlags },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "IcmpType",
                    |m: &FlowMessage| { &m.IcmpType },
                    |m: &mut FlowMessage| { &mut m.IcmpType },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "IcmpCode",
                    |m: &FlowMessage| { &m.IcmpCode },
                    |m: &mut FlowMessage| { &mut m.IcmpCode },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "IPv6FlowLabel",
                    |m: &FlowMessage| { &m.IPv6FlowLabel },
                    |m: &mut FlowMessage| { &mut m.IPv6FlowLabel },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "IPv6ExtensionHeaders",
                    |m: &FlowMessage| { &m.IPv6ExtensionHeaders },
                    |m: &mut FlowMessage| { &mut m.IPv6ExtensionHeaders },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "FragmentId",
                    |m: &FlowMessage| { &m.FragmentId },
                    |m: &mut FlowMessage| { &mut m.FragmentId },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "FragmentOffset",
                    |m: &FlowMessage| { &m.FragmentOffset },
                    |m: &mut FlowMessage| { &mut m.FragmentOffset },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "BiFlowDirection",
                    |m: &FlowMessage| { &m.BiFlowDirection },
                    |m: &mut FlowMessage| { &mut m.BiFlowDirection },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "SrcAS",
                    |m: &FlowMessage| { &m.SrcAS },
                    |m: &mut FlowMessage| { &mut m.SrcAS },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "DstAS",
                    |m: &FlowMessage| { &m.DstAS },
                    |m: &mut FlowMessage| { &mut m.DstAS },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "NextHop",
                    |m: &FlowMessage| { &m.NextHop },
                    |m: &mut FlowMessage| { &mut m.NextHop },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "NextHopAS",
                    |m: &FlowMessage| { &m.NextHopAS },
                    |m: &mut FlowMessage| { &mut m.NextHopAS },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "SrcNet",
                    |m: &FlowMessage| { &m.SrcNet },
                    |m: &mut FlowMessage| { &mut m.SrcNet },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "DstNet",
                    |m: &FlowMessage| { &m.DstNet },
                    |m: &mut FlowMessage| { &mut m.DstNet },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "Cid",
                    |m: &FlowMessage| { &m.Cid },
                    |m: &mut FlowMessage| { &mut m.Cid },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "CidString",
                    |m: &FlowMessage| { &m.CidString },
                    |m: &mut FlowMessage| { &mut m.CidString },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<FlowMessage_NormalizedType>>(
                    "Normalized",
                    |m: &FlowMessage| { &m.Normalized },
                    |m: &mut FlowMessage| { &mut m.Normalized },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "SrcIfName",
                    |m: &FlowMessage| { &m.SrcIfName },
                    |m: &mut FlowMessage| { &mut m.SrcIfName },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "SrcIfDesc",
                    |m: &FlowMessage| { &m.SrcIfDesc },
                    |m: &mut FlowMessage| { &mut m.SrcIfDesc },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "SrcIfSpeed",
                    |m: &FlowMessage| { &m.SrcIfSpeed },
                    |m: &mut FlowMessage| { &mut m.SrcIfSpeed },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "DstIfName",
                    |m: &FlowMessage| { &m.DstIfName },
                    |m: &mut FlowMessage| { &mut m.DstIfName },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "DstIfDesc",
                    |m: &FlowMessage| { &m.DstIfDesc },
                    |m: &mut FlowMessage| { &mut m.DstIfDesc },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "DstIfSpeed",
                    |m: &FlowMessage| { &m.DstIfSpeed },
                    |m: &mut FlowMessage| { &mut m.DstIfSpeed },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "ProtoName",
                    |m: &FlowMessage| { &m.ProtoName },
                    |m: &mut FlowMessage| { &mut m.ProtoName },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "RemoteCountry",
                    |m: &FlowMessage| { &m.RemoteCountry },
                    |m: &mut FlowMessage| { &mut m.RemoteCountry },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<FlowMessage>(
                    "FlowMessage",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static FlowMessage {
        static mut instance: ::protobuf::lazy::Lazy<FlowMessage> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const FlowMessage,
        };
        unsafe {
            instance.get(FlowMessage::new)
        }
    }
}

impl ::protobuf::Clear for FlowMessage {
    fn clear(&mut self) {
        self.clear_Type();
        self.clear_TimeReceived();
        self.clear_SequenceNum();
        self.clear_SamplingRate();
        self.clear_FlowDirection();
        self.clear_SamplerAddress();
        self.clear_TimeFlowStart();
        self.clear_TimeFlowEnd();
        self.clear_Bytes();
        self.clear_Packets();
        self.clear_SrcAddr();
        self.clear_DstAddr();
        self.clear_Etype();
        self.clear_Proto();
        self.clear_SrcPort();
        self.clear_DstPort();
        self.clear_SrcIf();
        self.clear_DstIf();
        self.clear_SrcMac();
        self.clear_DstMac();
        self.clear_SrcVlan();
        self.clear_DstVlan();
        self.clear_VlanId();
        self.clear_IngressVrfID();
        self.clear_EgressVrfID();
        self.clear_IPTos();
        self.clear_ForwardingStatus();
        self.clear_IPTTL();
        self.clear_TCPFlags();
        self.clear_IcmpType();
        self.clear_IcmpCode();
        self.clear_IPv6FlowLabel();
        self.clear_IPv6ExtensionHeaders();
        self.clear_FragmentId();
        self.clear_FragmentOffset();
        self.clear_BiFlowDirection();
        self.clear_SrcAS();
        self.clear_DstAS();
        self.clear_NextHop();
        self.clear_NextHopAS();
        self.clear_SrcNet();
        self.clear_DstNet();
        self.clear_Cid();
        self.clear_CidString();
        self.clear_Normalized();
        self.clear_SrcIfName();
        self.clear_SrcIfDesc();
        self.clear_SrcIfSpeed();
        self.clear_DstIfName();
        self.clear_DstIfDesc();
        self.clear_DstIfSpeed();
        self.clear_ProtoName();
        self.clear_RemoteCountry();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for FlowMessage {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for FlowMessage {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum FlowMessage_FlowType {
    FLOWUNKNOWN = 0,
    SFLOW_5 = 1,
    NETFLOW_V5 = 2,
    NETFLOW_V9 = 3,
    IPFIX = 4,
}

impl ::protobuf::ProtobufEnum for FlowMessage_FlowType {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<FlowMessage_FlowType> {
        match value {
            0 => ::std::option::Option::Some(FlowMessage_FlowType::FLOWUNKNOWN),
            1 => ::std::option::Option::Some(FlowMessage_FlowType::SFLOW_5),
            2 => ::std::option::Option::Some(FlowMessage_FlowType::NETFLOW_V5),
            3 => ::std::option::Option::Some(FlowMessage_FlowType::NETFLOW_V9),
            4 => ::std::option::Option::Some(FlowMessage_FlowType::IPFIX),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [FlowMessage_FlowType] = &[
            FlowMessage_FlowType::FLOWUNKNOWN,
            FlowMessage_FlowType::SFLOW_5,
            FlowMessage_FlowType::NETFLOW_V5,
            FlowMessage_FlowType::NETFLOW_V9,
            FlowMessage_FlowType::IPFIX,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::EnumDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                ::protobuf::reflect::EnumDescriptor::new("FlowMessage_FlowType", file_descriptor_proto())
            })
        }
    }
}

impl ::std::marker::Copy for FlowMessage_FlowType {
}

impl ::std::default::Default for FlowMessage_FlowType {
    fn default() -> Self {
        FlowMessage_FlowType::FLOWUNKNOWN
    }
}

impl ::protobuf::reflect::ProtobufValue for FlowMessage_FlowType {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Enum(self.descriptor())
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum FlowMessage_NormalizedType {
    No = 0,
    Yes = 1,
}

impl ::protobuf::ProtobufEnum for FlowMessage_NormalizedType {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<FlowMessage_NormalizedType> {
        match value {
            0 => ::std::option::Option::Some(FlowMessage_NormalizedType::No),
            1 => ::std::option::Option::Some(FlowMessage_NormalizedType::Yes),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [FlowMessage_NormalizedType] = &[
            FlowMessage_NormalizedType::No,
            FlowMessage_NormalizedType::Yes,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::EnumDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                ::protobuf::reflect::EnumDescriptor::new("FlowMessage_NormalizedType", file_descriptor_proto())
            })
        }
    }
}

impl ::std::marker::Copy for FlowMessage_NormalizedType {
}

impl ::std::default::Default for FlowMessage_NormalizedType {
    fn default() -> Self {
        FlowMessage_NormalizedType::No
    }
}

impl ::protobuf::reflect::ProtobufValue for FlowMessage_NormalizedType {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Enum(self.descriptor())
    }
}

static file_descriptor_proto_data: &'static [u8] = b"\
    \n\x1cflow-messages-enriched.proto\x12\x13flowmessageenriched\"\x8a\x0e\
    \n\x0bFlowMessage\x12=\n\x04Type\x18\x01\x20\x01(\x0e2).flowmessageenric\
    hed.FlowMessage.FlowTypeR\x04Type\x12\"\n\x0cTimeReceived\x18\x02\x20\
    \x01(\x04R\x0cTimeReceived\x12\x20\n\x0bSequenceNum\x18\x04\x20\x01(\rR\
    \x0bSequenceNum\x12\"\n\x0cSamplingRate\x18\x03\x20\x01(\x04R\x0cSamplin\
    gRate\x12$\n\rFlowDirection\x18*\x20\x01(\rR\rFlowDirection\x12&\n\x0eSa\
    mplerAddress\x18\x0b\x20\x01(\x0cR\x0eSamplerAddress\x12$\n\rTimeFlowSta\
    rt\x18&\x20\x01(\x04R\rTimeFlowStart\x12\x20\n\x0bTimeFlowEnd\x18\x05\
    \x20\x01(\x04R\x0bTimeFlowEnd\x12\x14\n\x05Bytes\x18\t\x20\x01(\x04R\x05\
    Bytes\x12\x18\n\x07Packets\x18\n\x20\x01(\x04R\x07Packets\x12\x18\n\x07S\
    rcAddr\x18\x06\x20\x01(\x0cR\x07SrcAddr\x12\x18\n\x07DstAddr\x18\x07\x20\
    \x01(\x0cR\x07DstAddr\x12\x14\n\x05Etype\x18\x1e\x20\x01(\rR\x05Etype\
    \x12\x14\n\x05Proto\x18\x14\x20\x01(\rR\x05Proto\x12\x18\n\x07SrcPort\
    \x18\x15\x20\x01(\rR\x07SrcPort\x12\x18\n\x07DstPort\x18\x16\x20\x01(\rR\
    \x07DstPort\x12\x14\n\x05SrcIf\x18\x12\x20\x01(\rR\x05SrcIf\x12\x14\n\
    \x05DstIf\x18\x13\x20\x01(\rR\x05DstIf\x12\x16\n\x06SrcMac\x18\x1b\x20\
    \x01(\x04R\x06SrcMac\x12\x16\n\x06DstMac\x18\x1c\x20\x01(\x04R\x06DstMac\
    \x12\x18\n\x07SrcVlan\x18!\x20\x01(\rR\x07SrcVlan\x12\x18\n\x07DstVlan\
    \x18\"\x20\x01(\rR\x07DstVlan\x12\x16\n\x06VlanId\x18\x1d\x20\x01(\rR\
    \x06VlanId\x12\"\n\x0cIngressVrfID\x18'\x20\x01(\rR\x0cIngressVrfID\x12\
    \x20\n\x0bEgressVrfID\x18(\x20\x01(\rR\x0bEgressVrfID\x12\x14\n\x05IPTos\
    \x18\x17\x20\x01(\rR\x05IPTos\x12*\n\x10ForwardingStatus\x18\x18\x20\x01\
    (\rR\x10ForwardingStatus\x12\x14\n\x05IPTTL\x18\x19\x20\x01(\rR\x05IPTTL\
    \x12\x1a\n\x08TCPFlags\x18\x1a\x20\x01(\rR\x08TCPFlags\x12\x1a\n\x08Icmp\
    Type\x18\x1f\x20\x01(\rR\x08IcmpType\x12\x1a\n\x08IcmpCode\x18\x20\x20\
    \x01(\rR\x08IcmpCode\x12$\n\rIPv6FlowLabel\x18%\x20\x01(\rR\rIPv6FlowLab\
    el\x122\n\x14IPv6ExtensionHeaders\x18+\x20\x01(\rR\x14IPv6ExtensionHeade\
    rs\x12\x1e\n\nFragmentId\x18#\x20\x01(\rR\nFragmentId\x12&\n\x0eFragment\
    Offset\x18$\x20\x01(\rR\x0eFragmentOffset\x12(\n\x0fBiFlowDirection\x18)\
    \x20\x01(\rR\x0fBiFlowDirection\x12\x14\n\x05SrcAS\x18\x0e\x20\x01(\rR\
    \x05SrcAS\x12\x14\n\x05DstAS\x18\x0f\x20\x01(\rR\x05DstAS\x12\x18\n\x07N\
    extHop\x18\x0c\x20\x01(\x0cR\x07NextHop\x12\x1c\n\tNextHopAS\x18\r\x20\
    \x01(\rR\tNextHopAS\x12\x16\n\x06SrcNet\x18\x10\x20\x01(\rR\x06SrcNet\
    \x12\x16\n\x06DstNet\x18\x11\x20\x01(\rR\x06DstNet\x12\x11\n\x03Cid\x18\
    \xe8\x07\x20\x01(\rR\x03Cid\x12\x1d\n\tCidString\x18\xe9\x07\x20\x01(\tR\
    \tCidString\x12P\n\nNormalized\x18\xea\x07\x20\x01(\x0e2/.flowmessageenr\
    iched.FlowMessage.NormalizedTypeR\nNormalized\x12\x1d\n\tSrcIfName\x18\
    \xeb\x07\x20\x01(\tR\tSrcIfName\x12\x1d\n\tSrcIfDesc\x18\xec\x07\x20\x01\
    (\tR\tSrcIfDesc\x12\x1f\n\nSrcIfSpeed\x18\xed\x07\x20\x01(\rR\nSrcIfSpee\
    d\x12\x1d\n\tDstIfName\x18\xee\x07\x20\x01(\tR\tDstIfName\x12\x1d\n\tDst\
    IfDesc\x18\xef\x07\x20\x01(\tR\tDstIfDesc\x12\x1f\n\nDstIfSpeed\x18\xf0\
    \x07\x20\x01(\rR\nDstIfSpeed\x12\x1d\n\tProtoName\x18\xf1\x07\x20\x01(\t\
    R\tProtoName\x12%\n\rRemoteCountry\x18\xf2\x07\x20\x01(\tR\rRemoteCountr\
    y\"S\n\x08FlowType\x12\x0f\n\x0bFLOWUNKNOWN\x10\0\x12\x0b\n\x07SFLOW_5\
    \x10\x01\x12\x0e\n\nNETFLOW_V5\x10\x02\x12\x0e\n\nNETFLOW_V9\x10\x03\x12\
    \t\n\x05IPFIX\x10\x04\"!\n\x0eNormalizedType\x12\x06\n\x02No\x10\0\x12\
    \x07\n\x03Yes\x10\x01B\"\n\tbwnetflowB\x15FlowMessageEnrichedPbJ\x8a(\n\
    \x06\x12\x04\0\0s\x01\n\x08\n\x01\x0c\x12\x03\0\0\x12\n\x08\n\x01\x02\
    \x12\x03\x01\0\x1c\n\x08\n\x01\x08\x12\x03\x03\0\"\n\t\n\x02\x08\x01\x12\
    \x03\x03\0\"\n\x08\n\x01\x08\x12\x03\x04\06\n\t\n\x02\x08\x08\x12\x03\
    \x04\06\n\n\n\x02\x04\0\x12\x04\x06\0s\x01\n\n\n\x03\x04\0\x01\x12\x03\
    \x06\x08\x13\n\x0c\n\x04\x04\0\x04\0\x12\x04\x08\x02\x0e\x03\n\x0c\n\x05\
    \x04\0\x04\0\x01\x12\x03\x08\x07\x0f\n\r\n\x06\x04\0\x04\0\x02\0\x12\x03\
    \t\x04\x14\n\x0e\n\x07\x04\0\x04\0\x02\0\x01\x12\x03\t\x04\x0f\n\x0e\n\
    \x07\x04\0\x04\0\x02\0\x02\x12\x03\t\x12\x13\n\r\n\x06\x04\0\x04\0\x02\
    \x01\x12\x03\n\x04\x10\n\x0e\n\x07\x04\0\x04\0\x02\x01\x01\x12\x03\n\x04\
    \x0b\n\x0e\n\x07\x04\0\x04\0\x02\x01\x02\x12\x03\n\x0e\x0f\n\r\n\x06\x04\
    \0\x04\0\x02\x02\x12\x03\x0b\x04\x13\n\x0e\n\x07\x04\0\x04\0\x02\x02\x01\
    \x12\x03\x0b\x04\x0e\n\x0e\n\x07\x04\0\x04\0\x02\x02\x02\x12\x03\x0b\x11\
    \x12\n\r\n\x06\x04\0\x04\0\x02\x03\x12\x03\x0c\x04\x13\n\x0e\n\x07\x04\0\
    \x04\0\x02\x03\x01\x12\x03\x0c\x04\x0e\n\x0e\n\x07\x04\0\x04\0\x02\x03\
    \x02\x12\x03\x0c\x11\x12\n\r\n\x06\x04\0\x04\0\x02\x04\x12\x03\r\x04\x0e\
    \n\x0e\n\x07\x04\0\x04\0\x02\x04\x01\x12\x03\r\x04\t\n\x0e\n\x07\x04\0\
    \x04\0\x02\x04\x02\x12\x03\r\x0c\r\n\x0b\n\x04\x04\0\x02\0\x12\x03\x0f\
    \x02\x14\n\r\n\x05\x04\0\x02\0\x04\x12\x04\x0f\x02\x0e\x03\n\x0c\n\x05\
    \x04\0\x02\0\x06\x12\x03\x0f\x02\n\n\x0c\n\x05\x04\0\x02\0\x01\x12\x03\
    \x0f\x0b\x0f\n\x0c\n\x05\x04\0\x02\0\x03\x12\x03\x0f\x12\x13\n\x0b\n\x04\
    \x04\0\x02\x01\x12\x03\x11\x02\x1a\n\r\n\x05\x04\0\x02\x01\x04\x12\x04\
    \x11\x02\x0f\x14\n\x0c\n\x05\x04\0\x02\x01\x05\x12\x03\x11\x02\x08\n\x0c\
    \n\x05\x04\0\x02\x01\x01\x12\x03\x11\t\x15\n\x0c\n\x05\x04\0\x02\x01\x03\
    \x12\x03\x11\x18\x19\n\x0b\n\x04\x04\0\x02\x02\x12\x03\x12\x02\x19\n\r\n\
    \x05\x04\0\x02\x02\x04\x12\x04\x12\x02\x11\x1a\n\x0c\n\x05\x04\0\x02\x02\
    \x05\x12\x03\x12\x02\x08\n\x0c\n\x05\x04\0\x02\x02\x01\x12\x03\x12\t\x14\
    \n\x0c\n\x05\x04\0\x02\x02\x03\x12\x03\x12\x17\x18\n\x0b\n\x04\x04\0\x02\
    \x03\x12\x03\x13\x02\x1a\n\r\n\x05\x04\0\x02\x03\x04\x12\x04\x13\x02\x12\
    \x19\n\x0c\n\x05\x04\0\x02\x03\x05\x12\x03\x13\x02\x08\n\x0c\n\x05\x04\0\
    \x02\x03\x01\x12\x03\x13\t\x15\n\x0c\n\x05\x04\0\x02\x03\x03\x12\x03\x13\
    \x18\x19\n\x0b\n\x04\x04\0\x02\x04\x12\x03\x15\x02\x1c\n\r\n\x05\x04\0\
    \x02\x04\x04\x12\x04\x15\x02\x13\x1a\n\x0c\n\x05\x04\0\x02\x04\x05\x12\
    \x03\x15\x02\x08\n\x0c\n\x05\x04\0\x02\x04\x01\x12\x03\x15\t\x16\n\x0c\n\
    \x05\x04\0\x02\x04\x03\x12\x03\x15\x19\x1b\n\"\n\x04\x04\0\x02\x05\x12\
    \x03\x18\x02\x1c\x1a\x15\x20Sampler\x20information\n\n\r\n\x05\x04\0\x02\
    \x05\x04\x12\x04\x18\x02\x15\x1c\n\x0c\n\x05\x04\0\x02\x05\x05\x12\x03\
    \x18\x02\x07\n\x0c\n\x05\x04\0\x02\x05\x01\x12\x03\x18\x08\x16\n\x0c\n\
    \x05\x04\0\x02\x05\x03\x12\x03\x18\x19\x1b\n\"\n\x04\x04\0\x02\x06\x12\
    \x03\x1b\x02\x1c\x1a\x15\x20Found\x20inside\x20packet\n\n\r\n\x05\x04\0\
    \x02\x06\x04\x12\x04\x1b\x02\x18\x1c\n\x0c\n\x05\x04\0\x02\x06\x05\x12\
    \x03\x1b\x02\x08\n\x0c\n\x05\x04\0\x02\x06\x01\x12\x03\x1b\t\x16\n\x0c\n\
    \x05\x04\0\x02\x06\x03\x12\x03\x1b\x19\x1b\n\x0b\n\x04\x04\0\x02\x07\x12\
    \x03\x1c\x02\x19\n\r\n\x05\x04\0\x02\x07\x04\x12\x04\x1c\x02\x1b\x1c\n\
    \x0c\n\x05\x04\0\x02\x07\x05\x12\x03\x1c\x02\x08\n\x0c\n\x05\x04\0\x02\
    \x07\x01\x12\x03\x1c\t\x14\n\x0c\n\x05\x04\0\x02\x07\x03\x12\x03\x1c\x17\
    \x18\n)\n\x04\x04\0\x02\x08\x12\x03\x1f\x02\x13\x1a\x1c\x20Size\x20of\
    \x20the\x20sampled\x20packet\n\n\r\n\x05\x04\0\x02\x08\x04\x12\x04\x1f\
    \x02\x1c\x19\n\x0c\n\x05\x04\0\x02\x08\x05\x12\x03\x1f\x02\x08\n\x0c\n\
    \x05\x04\0\x02\x08\x01\x12\x03\x1f\t\x0e\n\x0c\n\x05\x04\0\x02\x08\x03\
    \x12\x03\x1f\x11\x12\n\x0b\n\x04\x04\0\x02\t\x12\x03\x20\x02\x16\n\r\n\
    \x05\x04\0\x02\t\x04\x12\x04\x20\x02\x1f\x13\n\x0c\n\x05\x04\0\x02\t\x05\
    \x12\x03\x20\x02\x08\n\x0c\n\x05\x04\0\x02\t\x01\x12\x03\x20\t\x10\n\x0c\
    \n\x05\x04\0\x02\t\x03\x12\x03\x20\x13\x15\n+\n\x04\x04\0\x02\n\x12\x03#\
    \x02\x14\x1a\x1e\x20Source/destination\x20addresses\n\n\r\n\x05\x04\0\
    \x02\n\x04\x12\x04#\x02\x20\x16\n\x0c\n\x05\x04\0\x02\n\x05\x12\x03#\x02\
    \x07\n\x0c\n\x05\x04\0\x02\n\x01\x12\x03#\x08\x0f\n\x0c\n\x05\x04\0\x02\
    \n\x03\x12\x03#\x12\x13\n\x0b\n\x04\x04\0\x02\x0b\x12\x03$\x02\x14\n\r\n\
    \x05\x04\0\x02\x0b\x04\x12\x04$\x02#\x14\n\x0c\n\x05\x04\0\x02\x0b\x05\
    \x12\x03$\x02\x07\n\x0c\n\x05\x04\0\x02\x0b\x01\x12\x03$\x08\x0f\n\x0c\n\
    \x05\x04\0\x02\x0b\x03\x12\x03$\x12\x13\n3\n\x04\x04\0\x02\x0c\x12\x03'\
    \x02\x14\x1a&\x20Layer\x203\x20protocol\x20(IPv4/IPv6/ARP/...)\n\n\r\n\
    \x05\x04\0\x02\x0c\x04\x12\x04'\x02$\x14\n\x0c\n\x05\x04\0\x02\x0c\x05\
    \x12\x03'\x02\x08\n\x0c\n\x05\x04\0\x02\x0c\x01\x12\x03'\t\x0e\n\x0c\n\
    \x05\x04\0\x02\x0c\x03\x12\x03'\x11\x13\n\x1f\n\x04\x04\0\x02\r\x12\x03*\
    \x02\x14\x1a\x12\x20Layer\x204\x20protocol\n\n\r\n\x05\x04\0\x02\r\x04\
    \x12\x04*\x02'\x14\n\x0c\n\x05\x04\0\x02\r\x05\x12\x03*\x02\x08\n\x0c\n\
    \x05\x04\0\x02\r\x01\x12\x03*\t\x0e\n\x0c\n\x05\x04\0\x02\r\x03\x12\x03*\
    \x11\x13\n$\n\x04\x04\0\x02\x0e\x12\x03-\x02\x16\x1a\x17\x20Ports\x20for\
    \x20UDP\x20and\x20TCP\n\n\r\n\x05\x04\0\x02\x0e\x04\x12\x04-\x02*\x14\n\
    \x0c\n\x05\x04\0\x02\x0e\x05\x12\x03-\x02\x08\n\x0c\n\x05\x04\0\x02\x0e\
    \x01\x12\x03-\t\x10\n\x0c\n\x05\x04\0\x02\x0e\x03\x12\x03-\x13\x15\n\x0b\
    \n\x04\x04\0\x02\x0f\x12\x03.\x02\x16\n\r\n\x05\x04\0\x02\x0f\x04\x12\
    \x04.\x02-\x16\n\x0c\n\x05\x04\0\x02\x0f\x05\x12\x03.\x02\x08\n\x0c\n\
    \x05\x04\0\x02\x0f\x01\x12\x03.\t\x10\n\x0c\n\x05\x04\0\x02\x0f\x03\x12\
    \x03.\x13\x15\n\x19\n\x04\x04\0\x02\x10\x12\x031\x02\x14\x1a\x0c\x20Inte\
    rfaces\n\n\r\n\x05\x04\0\x02\x10\x04\x12\x041\x02.\x16\n\x0c\n\x05\x04\0\
    \x02\x10\x05\x12\x031\x02\x08\n\x0c\n\x05\x04\0\x02\x10\x01\x12\x031\t\
    \x0e\n\x0c\n\x05\x04\0\x02\x10\x03\x12\x031\x11\x13\n\x0b\n\x04\x04\0\
    \x02\x11\x12\x032\x02\x14\n\r\n\x05\x04\0\x02\x11\x04\x12\x042\x021\x14\
    \n\x0c\n\x05\x04\0\x02\x11\x05\x12\x032\x02\x08\n\x0c\n\x05\x04\0\x02\
    \x11\x01\x12\x032\t\x0e\n\x0c\n\x05\x04\0\x02\x11\x03\x12\x032\x11\x13\n\
    #\n\x04\x04\0\x02\x12\x12\x035\x02\x15\x1a\x16\x20Ethernet\x20informatio\
    n\n\n\r\n\x05\x04\0\x02\x12\x04\x12\x045\x022\x14\n\x0c\n\x05\x04\0\x02\
    \x12\x05\x12\x035\x02\x08\n\x0c\n\x05\x04\0\x02\x12\x01\x12\x035\t\x0f\n\
    \x0c\n\x05\x04\0\x02\x12\x03\x12\x035\x12\x14\n\x0b\n\x04\x04\0\x02\x13\
    \x12\x036\x02\x15\n\r\n\x05\x04\0\x02\x13\x04\x12\x046\x025\x15\n\x0c\n\
    \x05\x04\0\x02\x13\x05\x12\x036\x02\x08\n\x0c\n\x05\x04\0\x02\x13\x01\
    \x12\x036\t\x0f\n\x0c\n\x05\x04\0\x02\x13\x03\x12\x036\x12\x14\n\x13\n\
    \x04\x04\0\x02\x14\x12\x039\x02\x16\x1a\x06\x20Vlan\n\n\r\n\x05\x04\0\
    \x02\x14\x04\x12\x049\x026\x15\n\x0c\n\x05\x04\0\x02\x14\x05\x12\x039\
    \x02\x08\n\x0c\n\x05\x04\0\x02\x14\x01\x12\x039\t\x10\n\x0c\n\x05\x04\0\
    \x02\x14\x03\x12\x039\x13\x15\n\x0b\n\x04\x04\0\x02\x15\x12\x03:\x02\x16\
    \n\r\n\x05\x04\0\x02\x15\x04\x12\x04:\x029\x16\n\x0c\n\x05\x04\0\x02\x15\
    \x05\x12\x03:\x02\x08\n\x0c\n\x05\x04\0\x02\x15\x01\x12\x03:\t\x10\n\x0c\
    \n\x05\x04\0\x02\x15\x03\x12\x03:\x13\x15\n,\n\x04\x04\0\x02\x16\x12\x03\
    <\x02\x15\x1a\x1f\x20802.1q\x20VLAN\x20in\x20sampled\x20packet\n\n\r\n\
    \x05\x04\0\x02\x16\x04\x12\x04<\x02:\x16\n\x0c\n\x05\x04\0\x02\x16\x05\
    \x12\x03<\x02\x08\n\x0c\n\x05\x04\0\x02\x16\x01\x12\x03<\t\x0f\n\x0c\n\
    \x05\x04\0\x02\x16\x03\x12\x03<\x12\x14\n\x12\n\x04\x04\0\x02\x17\x12\
    \x03?\x02\x1b\x1a\x05\x20VRF\n\n\r\n\x05\x04\0\x02\x17\x04\x12\x04?\x02<\
    \x15\n\x0c\n\x05\x04\0\x02\x17\x05\x12\x03?\x02\x08\n\x0c\n\x05\x04\0\
    \x02\x17\x01\x12\x03?\t\x15\n\x0c\n\x05\x04\0\x02\x17\x03\x12\x03?\x18\
    \x1a\n\x0b\n\x04\x04\0\x02\x18\x12\x03@\x02\x1a\n\r\n\x05\x04\0\x02\x18\
    \x04\x12\x04@\x02?\x1b\n\x0c\n\x05\x04\0\x02\x18\x05\x12\x03@\x02\x08\n\
    \x0c\n\x05\x04\0\x02\x18\x01\x12\x03@\t\x14\n\x0c\n\x05\x04\0\x02\x18\
    \x03\x12\x03@\x17\x19\n'\n\x04\x04\0\x02\x19\x12\x03C\x02\x14\x1a\x1a\
    \x20IP\x20and\x20TCP\x20special\x20flags\n\n\r\n\x05\x04\0\x02\x19\x04\
    \x12\x04C\x02@\x1a\n\x0c\n\x05\x04\0\x02\x19\x05\x12\x03C\x02\x08\n\x0c\
    \n\x05\x04\0\x02\x19\x01\x12\x03C\t\x0e\n\x0c\n\x05\x04\0\x02\x19\x03\
    \x12\x03C\x11\x13\n\x0b\n\x04\x04\0\x02\x1a\x12\x03D\x02\x1f\n\r\n\x05\
    \x04\0\x02\x1a\x04\x12\x04D\x02C\x14\n\x0c\n\x05\x04\0\x02\x1a\x05\x12\
    \x03D\x02\x08\n\x0c\n\x05\x04\0\x02\x1a\x01\x12\x03D\t\x19\n\x0c\n\x05\
    \x04\0\x02\x1a\x03\x12\x03D\x1c\x1e\n\x0b\n\x04\x04\0\x02\x1b\x12\x03E\
    \x02\x14\n\r\n\x05\x04\0\x02\x1b\x04\x12\x04E\x02D\x1f\n\x0c\n\x05\x04\0\
    \x02\x1b\x05\x12\x03E\x02\x08\n\x0c\n\x05\x04\0\x02\x1b\x01\x12\x03E\t\
    \x0e\n\x0c\n\x05\x04\0\x02\x1b\x03\x12\x03E\x11\x13\n\x0b\n\x04\x04\0\
    \x02\x1c\x12\x03F\x02\x17\n\r\n\x05\x04\0\x02\x1c\x04\x12\x04F\x02E\x14\
    \n\x0c\n\x05\x04\0\x02\x1c\x05\x12\x03F\x02\x08\n\x0c\n\x05\x04\0\x02\
    \x1c\x01\x12\x03F\t\x11\n\x0c\n\x05\x04\0\x02\x1c\x03\x12\x03F\x14\x16\n\
    \x0b\n\x04\x04\0\x02\x1d\x12\x03G\x02\x17\n\r\n\x05\x04\0\x02\x1d\x04\
    \x12\x04G\x02F\x17\n\x0c\n\x05\x04\0\x02\x1d\x05\x12\x03G\x02\x08\n\x0c\
    \n\x05\x04\0\x02\x1d\x01\x12\x03G\t\x11\n\x0c\n\x05\x04\0\x02\x1d\x03\
    \x12\x03G\x14\x16\n\x0b\n\x04\x04\0\x02\x1e\x12\x03H\x02\x17\n\r\n\x05\
    \x04\0\x02\x1e\x04\x12\x04H\x02G\x17\n\x0c\n\x05\x04\0\x02\x1e\x05\x12\
    \x03H\x02\x08\n\x0c\n\x05\x04\0\x02\x1e\x01\x12\x03H\t\x11\n\x0c\n\x05\
    \x04\0\x02\x1e\x03\x12\x03H\x14\x16\n\x0b\n\x04\x04\0\x02\x1f\x12\x03I\
    \x02\x1c\n\r\n\x05\x04\0\x02\x1f\x04\x12\x04I\x02H\x17\n\x0c\n\x05\x04\0\
    \x02\x1f\x05\x12\x03I\x02\x08\n\x0c\n\x05\x04\0\x02\x1f\x01\x12\x03I\t\
    \x16\n\x0c\n\x05\x04\0\x02\x1f\x03\x12\x03I\x19\x1b\n\x0b\n\x04\x04\0\
    \x02\x20\x12\x03J\x02#\n\r\n\x05\x04\0\x02\x20\x04\x12\x04J\x02I\x1c\n\
    \x0c\n\x05\x04\0\x02\x20\x05\x12\x03J\x02\x08\n\x0c\n\x05\x04\0\x02\x20\
    \x01\x12\x03J\t\x1d\n\x0c\n\x05\x04\0\x02\x20\x03\x12\x03J\x20\"\n$\n\
    \x04\x04\0\x02!\x12\x03L\x02\x19\x1a\x17\x20Fragments\x20(IPv4/IPv6)\n\n\
    \r\n\x05\x04\0\x02!\x04\x12\x04L\x02J#\n\x0c\n\x05\x04\0\x02!\x05\x12\
    \x03L\x02\x08\n\x0c\n\x05\x04\0\x02!\x01\x12\x03L\t\x13\n\x0c\n\x05\x04\
    \0\x02!\x03\x12\x03L\x16\x18\n\x0b\n\x04\x04\0\x02\"\x12\x03M\x02\x1d\n\
    \r\n\x05\x04\0\x02\"\x04\x12\x04M\x02L\x19\n\x0c\n\x05\x04\0\x02\"\x05\
    \x12\x03M\x02\x08\n\x0c\n\x05\x04\0\x02\"\x01\x12\x03M\t\x17\n\x0c\n\x05\
    \x04\0\x02\"\x03\x12\x03M\x1a\x1c\n\x0b\n\x04\x04\0\x02#\x12\x03N\x02\
    \x1e\n\r\n\x05\x04\0\x02#\x04\x12\x04N\x02M\x1d\n\x0c\n\x05\x04\0\x02#\
    \x05\x12\x03N\x02\x08\n\x0c\n\x05\x04\0\x02#\x01\x12\x03N\t\x18\n\x0c\n\
    \x05\x04\0\x02#\x03\x12\x03N\x1b\x1d\n,\n\x04\x04\0\x02$\x12\x03Q\x02\
    \x14\x1a\x1f\x20Autonomous\x20system\x20information\n\n\r\n\x05\x04\0\
    \x02$\x04\x12\x04Q\x02N\x1e\n\x0c\n\x05\x04\0\x02$\x05\x12\x03Q\x02\x08\
    \n\x0c\n\x05\x04\0\x02$\x01\x12\x03Q\t\x0e\n\x0c\n\x05\x04\0\x02$\x03\
    \x12\x03Q\x11\x13\n\x0b\n\x04\x04\0\x02%\x12\x03R\x02\x14\n\r\n\x05\x04\
    \0\x02%\x04\x12\x04R\x02Q\x14\n\x0c\n\x05\x04\0\x02%\x05\x12\x03R\x02\
    \x08\n\x0c\n\x05\x04\0\x02%\x01\x12\x03R\t\x0e\n\x0c\n\x05\x04\0\x02%\
    \x03\x12\x03R\x11\x13\n\x0b\n\x04\x04\0\x02&\x12\x03T\x02\x15\n\r\n\x05\
    \x04\0\x02&\x04\x12\x04T\x02R\x14\n\x0c\n\x05\x04\0\x02&\x05\x12\x03T\
    \x02\x07\n\x0c\n\x05\x04\0\x02&\x01\x12\x03T\x08\x0f\n\x0c\n\x05\x04\0\
    \x02&\x03\x12\x03T\x12\x14\n\x0b\n\x04\x04\0\x02'\x12\x03U\x02\x18\n\r\n\
    \x05\x04\0\x02'\x04\x12\x04U\x02T\x15\n\x0c\n\x05\x04\0\x02'\x05\x12\x03\
    U\x02\x08\n\x0c\n\x05\x04\0\x02'\x01\x12\x03U\t\x12\n\x0c\n\x05\x04\0\
    \x02'\x03\x12\x03U\x15\x17\n\x1a\n\x04\x04\0\x02(\x12\x03X\x02\x15\x1a\r\
    \x20Prefix\x20size\n\n\r\n\x05\x04\0\x02(\x04\x12\x04X\x02U\x18\n\x0c\n\
    \x05\x04\0\x02(\x05\x12\x03X\x02\x08\n\x0c\n\x05\x04\0\x02(\x01\x12\x03X\
    \t\x0f\n\x0c\n\x05\x04\0\x02(\x03\x12\x03X\x12\x14\n\x0b\n\x04\x04\0\x02\
    )\x12\x03Y\x02\x15\n\r\n\x05\x04\0\x02)\x04\x12\x04Y\x02X\x15\n\x0c\n\
    \x05\x04\0\x02)\x05\x12\x03Y\x02\x08\n\x0c\n\x05\x04\0\x02)\x01\x12\x03Y\
    \t\x0f\n\x0c\n\x05\x04\0\x02)\x03\x12\x03Y\x12\x14\n\x9f\x01\n\x04\x04\0\
    \x02*\x12\x03`\x02\x14\x1a\x1b\x20bwNetFlow\x20enricher\x20fields\n\"0\
    \x20Customer\x20ID\x20-\x20numerical\x20ID,\x20assigned\x20by\x20prefix\
    \n2C\x20Custom\x20fields:\x20start\x20after\x20ID\x201000:\n\x20uint32\
    \x20MyCustomField\x20=\x201000;\n\n\r\n\x05\x04\0\x02*\x04\x12\x04`\x02Y\
    \x15\n\x0c\n\x05\x04\0\x02*\x05\x12\x03`\x02\x08\n\x0c\n\x05\x04\0\x02*\
    \x01\x12\x03`\t\x0c\n\x0c\n\x05\x04\0\x02*\x03\x12\x03`\x0f\x13\nF\n\x04\
    \x04\0\x02+\x12\x03a\x02\x1a\"9\x20Customer\x20ID\x20-\x20a\x20more\x20g\
    eneralized\x20ID,\x20assigned\x20by\x20prefix\n\n\r\n\x05\x04\0\x02+\x04\
    \x12\x04a\x02`\x14\n\x0c\n\x05\x04\0\x02+\x05\x12\x03a\x02\x08\n\x0c\n\
    \x05\x04\0\x02+\x01\x12\x03a\t\x12\n\x0c\n\x05\x04\0\x02+\x03\x12\x03a\
    \x15\x19\n\x0c\n\x04\x04\0\x04\x01\x12\x04c\x02f\x03\n\x0c\n\x05\x04\0\
    \x04\x01\x01\x12\x03c\x07\x15\n\r\n\x06\x04\0\x04\x01\x02\0\x12\x03d\x04\
    \x0b\n\x0e\n\x07\x04\0\x04\x01\x02\0\x01\x12\x03d\x04\x06\n\x0e\n\x07\
    \x04\0\x04\x01\x02\0\x02\x12\x03d\t\n\n\r\n\x06\x04\0\x04\x01\x02\x01\
    \x12\x03e\x04\x0c\n\x0e\n\x07\x04\0\x04\x01\x02\x01\x01\x12\x03e\x04\x07\
    \n\x0e\n\x07\x04\0\x04\x01\x02\x01\x02\x12\x03e\n\x0b\nI\n\x04\x04\0\x02\
    ,\x12\x03g\x02#\"<\x20Normalization\x20-\x20whether\x20the\x20sampling\
    \x20rate\x20is\x20accounted\x20for\n\n\r\n\x05\x04\0\x02,\x04\x12\x04g\
    \x02f\x03\n\x0c\n\x05\x04\0\x02,\x06\x12\x03g\x02\x10\n\x0c\n\x05\x04\0\
    \x02,\x01\x12\x03g\x11\x1b\n\x0c\n\x05\x04\0\x02,\x03\x12\x03g\x1e\"\ni\
    \n\x04\x04\0\x02-\x12\x03j\x02\x1a\x1a7\x20Fields\x20for\x20Interface\
    \x20Usability\x20--\x20enriched\x20using\x20SNMP\n\"#\x20set\x20to\x20th\
    e\x20name,\x20unset\x20by\x20default\n\n\r\n\x05\x04\0\x02-\x04\x12\x04j\
    \x02g#\n\x0c\n\x05\x04\0\x02-\x05\x12\x03j\x02\x08\n\x0c\n\x05\x04\0\x02\
    -\x01\x12\x03j\t\x12\n\x0c\n\x05\x04\0\x02-\x03\x12\x03j\x15\x19\nI\n\
    \x04\x04\0\x02.\x12\x03k\x02\x1a\"<\x20set\x20to\x20the\x20descrition,\
    \x20filtered\x20by\x20a\x20regex\x20in\x20the\x20enricher\n\n\r\n\x05\
    \x04\0\x02.\x04\x12\x04k\x02j\x1a\n\x0c\n\x05\x04\0\x02.\x05\x12\x03k\
    \x02\x08\n\x0c\n\x05\x04\0\x02.\x01\x12\x03k\t\x12\n\x0c\n\x05\x04\0\x02\
    .\x03\x12\x03k\x15\x19\n\x1a\n\x04\x04\0\x02/\x12\x03l\x02\x1b\"\r\x20if\
    ace\x20speed\n\n\r\n\x05\x04\0\x02/\x04\x12\x04l\x02k\x1a\n\x0c\n\x05\
    \x04\0\x02/\x05\x12\x03l\x02\x08\n\x0c\n\x05\x04\0\x02/\x01\x12\x03l\t\
    \x13\n\x0c\n\x05\x04\0\x02/\x03\x12\x03l\x16\x1a\n\x0b\n\x04\x04\0\x020\
    \x12\x03m\x02\x1a\n\r\n\x05\x04\0\x020\x04\x12\x04m\x02l\x1b\n\x0c\n\x05\
    \x04\0\x020\x05\x12\x03m\x02\x08\n\x0c\n\x05\x04\0\x020\x01\x12\x03m\t\
    \x12\n\x0c\n\x05\x04\0\x020\x03\x12\x03m\x15\x19\n\x0b\n\x04\x04\0\x021\
    \x12\x03n\x02\x1a\n\r\n\x05\x04\0\x021\x04\x12\x04n\x02m\x1a\n\x0c\n\x05\
    \x04\0\x021\x05\x12\x03n\x02\x08\n\x0c\n\x05\x04\0\x021\x01\x12\x03n\t\
    \x12\n\x0c\n\x05\x04\0\x021\x03\x12\x03n\x15\x19\n\x0b\n\x04\x04\0\x022\
    \x12\x03o\x02\x1b\n\r\n\x05\x04\0\x022\x04\x12\x04o\x02n\x1a\n\x0c\n\x05\
    \x04\0\x022\x05\x12\x03o\x02\x08\n\x0c\n\x05\x04\0\x022\x01\x12\x03o\t\
    \x13\n\x0c\n\x05\x04\0\x022\x03\x12\x03o\x16\x1a\nQ\n\x04\x04\0\x023\x12\
    \x03q\x02\x1a\"D\x20Protocol\x20Name\x20--\x20set\x20for\x20some\x20well\
    \x20known\x20protocols,\x20based\x20on\x20Proto\n\n\r\n\x05\x04\0\x023\
    \x04\x12\x04q\x02o\x1b\n\x0c\n\x05\x04\0\x023\x05\x12\x03q\x02\x08\n\x0c\
    \n\x05\x04\0\x023\x01\x12\x03q\t\x12\n\x0c\n\x05\x04\0\x023\x03\x12\x03q\
    \x15\x19\n=\n\x04\x04\0\x024\x12\x03r\x02\x1e\"0\x20Geolocation\x20--\
    \x20set\x20using\x20the\x20provided\x20database\n\n\r\n\x05\x04\0\x024\
    \x04\x12\x04r\x02q\x1a\n\x0c\n\x05\x04\0\x024\x05\x12\x03r\x02\x08\n\x0c\
    \n\x05\x04\0\x024\x01\x12\x03r\t\x16\n\x0c\n\x05\x04\0\x024\x03\x12\x03r\
    \x19\x1db\x06proto3\
";

static mut file_descriptor_proto_lazy: ::protobuf::lazy::Lazy<::protobuf::descriptor::FileDescriptorProto> = ::protobuf::lazy::Lazy {
    lock: ::protobuf::lazy::ONCE_INIT,
    ptr: 0 as *const ::protobuf::descriptor::FileDescriptorProto,
};

fn parse_descriptor_proto() -> ::protobuf::descriptor::FileDescriptorProto {
    ::protobuf::parse_from_bytes(file_descriptor_proto_data).unwrap()
}

pub fn file_descriptor_proto() -> &'static ::protobuf::descriptor::FileDescriptorProto {
    unsafe {
        file_descriptor_proto_lazy.get(|| {
            parse_descriptor_proto()
        })
    }
}
