// This file is generated by rust-protobuf 3.0.0-pre. Do not edit
// .proto file is parsed by protoc --rust-out=...
// @generated

// https://github.com/rust-lang/rust-clippy/issues/702
#![allow(unknown_lints)]
#![allow(clippy::all)]

#![allow(unused_attributes)]
#![cfg_attr(rustfmt, rustfmt::skip)]

#![allow(box_pointers)]
#![allow(dead_code)]
#![allow(missing_docs)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(non_upper_case_globals)]
#![allow(trivial_casts)]
#![allow(unused_results)]
#![allow(unused_mut)]

//! Generated file from `flow-messages-enriched.proto`

/// Generated files are compatible only with the same version
/// of protobuf runtime.
const _PROTOBUF_VERSION_CHECK: () = ::protobuf::VERSION_3_0_0_PRE;

#[derive(PartialEq,Clone,Default)]
pub struct FlowMessage {
    // message fields
    pub Type: ::protobuf::ProtobufEnumOrUnknown<flow_message::FlowType>,
    pub TimeReceived: u64,
    pub SequenceNum: u32,
    pub SamplingRate: u64,
    pub FlowDirection: u32,
    ///  Sampler information
    pub SamplerAddress: ::std::vec::Vec<u8>,
    ///  Found inside packet
    pub TimeFlowStart: u64,
    pub TimeFlowEnd: u64,
    ///  Size of the sampled packet
    pub Bytes: u64,
    pub Packets: u64,
    ///  Source/destination addresses
    pub SrcAddr: ::std::vec::Vec<u8>,
    pub DstAddr: ::std::vec::Vec<u8>,
    ///  Layer 3 protocol (IPv4/IPv6/ARP/MPLS...)
    pub Etype: u32,
    ///  Layer 4 protocol
    pub Proto: u32,
    ///  Ports for UDP and TCP
    pub SrcPort: u32,
    pub DstPort: u32,
    ///  Interfaces
    pub InIf: u32,
    pub OutIf: u32,
    ///  Ethernet information
    pub SrcMac: u64,
    pub DstMac: u64,
    ///  Vlan
    pub SrcVlan: u32,
    pub DstVlan: u32,
    ///  802.1q VLAN in sampled packet
    pub VlanId: u32,
    ///  VRF
    pub IngressVrfID: u32,
    pub EgressVrfID: u32,
    ///  IP and TCP special flags
    pub IPTos: u32,
    pub ForwardingStatus: u32,
    pub IPTTL: u32,
    pub TCPFlags: u32,
    pub IcmpType: u32,
    pub IcmpCode: u32,
    pub IPv6FlowLabel: u32,
    ///  Fragments (IPv4/IPv6)
    pub FragmentId: u32,
    pub FragmentOffset: u32,
    pub BiFlowDirection: u32,
    ///  Autonomous system information
    pub SrcAS: u32,
    pub DstAS: u32,
    pub NextHop: ::std::vec::Vec<u8>,
    pub NextHopAS: u32,
    ///  Prefix size
    pub SrcNet: u32,
    pub DstNet: u32,
    ///  MPLS information
    pub HasMPLS: bool,
    pub MPLSCount: u32,
    pub MPLS1TTL: u32,
    pub MPLS1Label: u32,
    pub MPLS2TTL: u32,
    pub MPLS2Label: u32,
    pub MPLS3TTL: u32,
    pub MPLS3Label: u32,
    pub MPLSLastTTL: u32,
    pub MPLSLastLabel: u32,
    ///  bwNetFlow enricher fields
    pub Cid: u32,
    pub CidString: ::std::string::String,
    pub SrcCid: u32,
    pub DstCid: u32,
    pub Normalized: ::protobuf::ProtobufEnumOrUnknown<flow_message::NormalizedType>,
    ///  Fields for Interface Usability -- enriched using SNMP
    pub SrcIfName: ::std::string::String,
    pub SrcIfDesc: ::std::string::String,
    pub SrcIfSpeed: u32,
    pub DstIfName: ::std::string::String,
    pub DstIfDesc: ::std::string::String,
    pub DstIfSpeed: u32,
    pub ProtoName: ::std::string::String,
    pub RemoteCountry: ::std::string::String,
    pub SrcCountry: ::std::string::String,
    pub DstCountry: ::std::string::String,
    pub RemoteAddr: ::protobuf::ProtobufEnumOrUnknown<flow_message::RemoteAddrType>,
    pub Note: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::rt::CachedSize,
}

impl<'a> ::std::default::Default for &'a FlowMessage {
    fn default() -> &'a FlowMessage {
        <FlowMessage as ::protobuf::Message>::default_instance()
    }
}

impl FlowMessage {
    pub fn new() -> FlowMessage {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::new();
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "Type",
            |m: &FlowMessage| { &m.Type },
            |m: &mut FlowMessage| { &mut m.Type },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "TimeReceived",
            |m: &FlowMessage| { &m.TimeReceived },
            |m: &mut FlowMessage| { &mut m.TimeReceived },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "SequenceNum",
            |m: &FlowMessage| { &m.SequenceNum },
            |m: &mut FlowMessage| { &mut m.SequenceNum },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "SamplingRate",
            |m: &FlowMessage| { &m.SamplingRate },
            |m: &mut FlowMessage| { &mut m.SamplingRate },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "FlowDirection",
            |m: &FlowMessage| { &m.FlowDirection },
            |m: &mut FlowMessage| { &mut m.FlowDirection },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "SamplerAddress",
            |m: &FlowMessage| { &m.SamplerAddress },
            |m: &mut FlowMessage| { &mut m.SamplerAddress },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "TimeFlowStart",
            |m: &FlowMessage| { &m.TimeFlowStart },
            |m: &mut FlowMessage| { &mut m.TimeFlowStart },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "TimeFlowEnd",
            |m: &FlowMessage| { &m.TimeFlowEnd },
            |m: &mut FlowMessage| { &mut m.TimeFlowEnd },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "Bytes",
            |m: &FlowMessage| { &m.Bytes },
            |m: &mut FlowMessage| { &mut m.Bytes },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "Packets",
            |m: &FlowMessage| { &m.Packets },
            |m: &mut FlowMessage| { &mut m.Packets },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "SrcAddr",
            |m: &FlowMessage| { &m.SrcAddr },
            |m: &mut FlowMessage| { &mut m.SrcAddr },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "DstAddr",
            |m: &FlowMessage| { &m.DstAddr },
            |m: &mut FlowMessage| { &mut m.DstAddr },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "Etype",
            |m: &FlowMessage| { &m.Etype },
            |m: &mut FlowMessage| { &mut m.Etype },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "Proto",
            |m: &FlowMessage| { &m.Proto },
            |m: &mut FlowMessage| { &mut m.Proto },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "SrcPort",
            |m: &FlowMessage| { &m.SrcPort },
            |m: &mut FlowMessage| { &mut m.SrcPort },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "DstPort",
            |m: &FlowMessage| { &m.DstPort },
            |m: &mut FlowMessage| { &mut m.DstPort },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "InIf",
            |m: &FlowMessage| { &m.InIf },
            |m: &mut FlowMessage| { &mut m.InIf },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "OutIf",
            |m: &FlowMessage| { &m.OutIf },
            |m: &mut FlowMessage| { &mut m.OutIf },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "SrcMac",
            |m: &FlowMessage| { &m.SrcMac },
            |m: &mut FlowMessage| { &mut m.SrcMac },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "DstMac",
            |m: &FlowMessage| { &m.DstMac },
            |m: &mut FlowMessage| { &mut m.DstMac },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "SrcVlan",
            |m: &FlowMessage| { &m.SrcVlan },
            |m: &mut FlowMessage| { &mut m.SrcVlan },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "DstVlan",
            |m: &FlowMessage| { &m.DstVlan },
            |m: &mut FlowMessage| { &mut m.DstVlan },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "VlanId",
            |m: &FlowMessage| { &m.VlanId },
            |m: &mut FlowMessage| { &mut m.VlanId },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "IngressVrfID",
            |m: &FlowMessage| { &m.IngressVrfID },
            |m: &mut FlowMessage| { &mut m.IngressVrfID },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "EgressVrfID",
            |m: &FlowMessage| { &m.EgressVrfID },
            |m: &mut FlowMessage| { &mut m.EgressVrfID },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "IPTos",
            |m: &FlowMessage| { &m.IPTos },
            |m: &mut FlowMessage| { &mut m.IPTos },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "ForwardingStatus",
            |m: &FlowMessage| { &m.ForwardingStatus },
            |m: &mut FlowMessage| { &mut m.ForwardingStatus },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "IPTTL",
            |m: &FlowMessage| { &m.IPTTL },
            |m: &mut FlowMessage| { &mut m.IPTTL },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "TCPFlags",
            |m: &FlowMessage| { &m.TCPFlags },
            |m: &mut FlowMessage| { &mut m.TCPFlags },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "IcmpType",
            |m: &FlowMessage| { &m.IcmpType },
            |m: &mut FlowMessage| { &mut m.IcmpType },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "IcmpCode",
            |m: &FlowMessage| { &m.IcmpCode },
            |m: &mut FlowMessage| { &mut m.IcmpCode },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "IPv6FlowLabel",
            |m: &FlowMessage| { &m.IPv6FlowLabel },
            |m: &mut FlowMessage| { &mut m.IPv6FlowLabel },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "FragmentId",
            |m: &FlowMessage| { &m.FragmentId },
            |m: &mut FlowMessage| { &mut m.FragmentId },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "FragmentOffset",
            |m: &FlowMessage| { &m.FragmentOffset },
            |m: &mut FlowMessage| { &mut m.FragmentOffset },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "BiFlowDirection",
            |m: &FlowMessage| { &m.BiFlowDirection },
            |m: &mut FlowMessage| { &mut m.BiFlowDirection },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "SrcAS",
            |m: &FlowMessage| { &m.SrcAS },
            |m: &mut FlowMessage| { &mut m.SrcAS },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "DstAS",
            |m: &FlowMessage| { &m.DstAS },
            |m: &mut FlowMessage| { &mut m.DstAS },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "NextHop",
            |m: &FlowMessage| { &m.NextHop },
            |m: &mut FlowMessage| { &mut m.NextHop },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "NextHopAS",
            |m: &FlowMessage| { &m.NextHopAS },
            |m: &mut FlowMessage| { &mut m.NextHopAS },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "SrcNet",
            |m: &FlowMessage| { &m.SrcNet },
            |m: &mut FlowMessage| { &mut m.SrcNet },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "DstNet",
            |m: &FlowMessage| { &m.DstNet },
            |m: &mut FlowMessage| { &mut m.DstNet },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "HasMPLS",
            |m: &FlowMessage| { &m.HasMPLS },
            |m: &mut FlowMessage| { &mut m.HasMPLS },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "MPLSCount",
            |m: &FlowMessage| { &m.MPLSCount },
            |m: &mut FlowMessage| { &mut m.MPLSCount },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "MPLS1TTL",
            |m: &FlowMessage| { &m.MPLS1TTL },
            |m: &mut FlowMessage| { &mut m.MPLS1TTL },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "MPLS1Label",
            |m: &FlowMessage| { &m.MPLS1Label },
            |m: &mut FlowMessage| { &mut m.MPLS1Label },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "MPLS2TTL",
            |m: &FlowMessage| { &m.MPLS2TTL },
            |m: &mut FlowMessage| { &mut m.MPLS2TTL },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "MPLS2Label",
            |m: &FlowMessage| { &m.MPLS2Label },
            |m: &mut FlowMessage| { &mut m.MPLS2Label },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "MPLS3TTL",
            |m: &FlowMessage| { &m.MPLS3TTL },
            |m: &mut FlowMessage| { &mut m.MPLS3TTL },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "MPLS3Label",
            |m: &FlowMessage| { &m.MPLS3Label },
            |m: &mut FlowMessage| { &mut m.MPLS3Label },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "MPLSLastTTL",
            |m: &FlowMessage| { &m.MPLSLastTTL },
            |m: &mut FlowMessage| { &mut m.MPLSLastTTL },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "MPLSLastLabel",
            |m: &FlowMessage| { &m.MPLSLastLabel },
            |m: &mut FlowMessage| { &mut m.MPLSLastLabel },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "Cid",
            |m: &FlowMessage| { &m.Cid },
            |m: &mut FlowMessage| { &mut m.Cid },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "CidString",
            |m: &FlowMessage| { &m.CidString },
            |m: &mut FlowMessage| { &mut m.CidString },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "SrcCid",
            |m: &FlowMessage| { &m.SrcCid },
            |m: &mut FlowMessage| { &mut m.SrcCid },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "DstCid",
            |m: &FlowMessage| { &m.DstCid },
            |m: &mut FlowMessage| { &mut m.DstCid },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "Normalized",
            |m: &FlowMessage| { &m.Normalized },
            |m: &mut FlowMessage| { &mut m.Normalized },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "SrcIfName",
            |m: &FlowMessage| { &m.SrcIfName },
            |m: &mut FlowMessage| { &mut m.SrcIfName },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "SrcIfDesc",
            |m: &FlowMessage| { &m.SrcIfDesc },
            |m: &mut FlowMessage| { &mut m.SrcIfDesc },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "SrcIfSpeed",
            |m: &FlowMessage| { &m.SrcIfSpeed },
            |m: &mut FlowMessage| { &mut m.SrcIfSpeed },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "DstIfName",
            |m: &FlowMessage| { &m.DstIfName },
            |m: &mut FlowMessage| { &mut m.DstIfName },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "DstIfDesc",
            |m: &FlowMessage| { &m.DstIfDesc },
            |m: &mut FlowMessage| { &mut m.DstIfDesc },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "DstIfSpeed",
            |m: &FlowMessage| { &m.DstIfSpeed },
            |m: &mut FlowMessage| { &mut m.DstIfSpeed },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "ProtoName",
            |m: &FlowMessage| { &m.ProtoName },
            |m: &mut FlowMessage| { &mut m.ProtoName },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "RemoteCountry",
            |m: &FlowMessage| { &m.RemoteCountry },
            |m: &mut FlowMessage| { &mut m.RemoteCountry },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "SrcCountry",
            |m: &FlowMessage| { &m.SrcCountry },
            |m: &mut FlowMessage| { &mut m.SrcCountry },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "DstCountry",
            |m: &FlowMessage| { &m.DstCountry },
            |m: &mut FlowMessage| { &mut m.DstCountry },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "RemoteAddr",
            |m: &FlowMessage| { &m.RemoteAddr },
            |m: &mut FlowMessage| { &mut m.RemoteAddr },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "Note",
            |m: &FlowMessage| { &m.Note },
            |m: &mut FlowMessage| { &mut m.Note },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<FlowMessage>(
            "FlowMessage",
            0,
            fields,
        )
    }
}

impl ::protobuf::Message for FlowMessage {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.Type = is.read_enum_or_unknown()?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.TimeReceived = is.read_uint64()?;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.SequenceNum = is.read_uint32()?;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.SamplingRate = is.read_uint64()?;
                },
                42 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.FlowDirection = is.read_uint32()?;
                },
                11 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.SamplerAddress = is.read_bytes()?;
                },
                38 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.TimeFlowStart = is.read_uint64()?;
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.TimeFlowEnd = is.read_uint64()?;
                },
                9 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.Bytes = is.read_uint64()?;
                },
                10 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.Packets = is.read_uint64()?;
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.SrcAddr = is.read_bytes()?;
                },
                7 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.DstAddr = is.read_bytes()?;
                },
                30 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.Etype = is.read_uint32()?;
                },
                20 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.Proto = is.read_uint32()?;
                },
                21 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.SrcPort = is.read_uint32()?;
                },
                22 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.DstPort = is.read_uint32()?;
                },
                18 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.InIf = is.read_uint32()?;
                },
                19 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.OutIf = is.read_uint32()?;
                },
                27 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.SrcMac = is.read_uint64()?;
                },
                28 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.DstMac = is.read_uint64()?;
                },
                33 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.SrcVlan = is.read_uint32()?;
                },
                34 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.DstVlan = is.read_uint32()?;
                },
                29 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.VlanId = is.read_uint32()?;
                },
                39 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.IngressVrfID = is.read_uint32()?;
                },
                40 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.EgressVrfID = is.read_uint32()?;
                },
                23 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.IPTos = is.read_uint32()?;
                },
                24 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.ForwardingStatus = is.read_uint32()?;
                },
                25 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.IPTTL = is.read_uint32()?;
                },
                26 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.TCPFlags = is.read_uint32()?;
                },
                31 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.IcmpType = is.read_uint32()?;
                },
                32 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.IcmpCode = is.read_uint32()?;
                },
                37 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.IPv6FlowLabel = is.read_uint32()?;
                },
                35 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.FragmentId = is.read_uint32()?;
                },
                36 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.FragmentOffset = is.read_uint32()?;
                },
                41 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.BiFlowDirection = is.read_uint32()?;
                },
                14 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.SrcAS = is.read_uint32()?;
                },
                15 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.DstAS = is.read_uint32()?;
                },
                12 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.NextHop = is.read_bytes()?;
                },
                13 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.NextHopAS = is.read_uint32()?;
                },
                16 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.SrcNet = is.read_uint32()?;
                },
                17 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.DstNet = is.read_uint32()?;
                },
                53 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.HasMPLS = is.read_bool()?;
                },
                54 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.MPLSCount = is.read_uint32()?;
                },
                55 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.MPLS1TTL = is.read_uint32()?;
                },
                56 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.MPLS1Label = is.read_uint32()?;
                },
                57 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.MPLS2TTL = is.read_uint32()?;
                },
                58 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.MPLS2Label = is.read_uint32()?;
                },
                59 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.MPLS3TTL = is.read_uint32()?;
                },
                60 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.MPLS3Label = is.read_uint32()?;
                },
                61 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.MPLSLastTTL = is.read_uint32()?;
                },
                62 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.MPLSLastLabel = is.read_uint32()?;
                },
                1000 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.Cid = is.read_uint32()?;
                },
                1001 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.CidString = is.read_string()?;
                },
                1012 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.SrcCid = is.read_uint32()?;
                },
                1013 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.DstCid = is.read_uint32()?;
                },
                1002 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.Normalized = is.read_enum_or_unknown()?;
                },
                1003 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.SrcIfName = is.read_string()?;
                },
                1004 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.SrcIfDesc = is.read_string()?;
                },
                1005 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.SrcIfSpeed = is.read_uint32()?;
                },
                1006 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.DstIfName = is.read_string()?;
                },
                1007 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.DstIfDesc = is.read_string()?;
                },
                1008 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.DstIfSpeed = is.read_uint32()?;
                },
                1009 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.ProtoName = is.read_string()?;
                },
                1010 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.RemoteCountry = is.read_string()?;
                },
                1014 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.SrcCountry = is.read_string()?;
                },
                1015 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.DstCountry = is.read_string()?;
                },
                1011 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.RemoteAddr = is.read_enum_or_unknown()?;
                },
                1016 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.Note = is.read_string()?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.Type != ::protobuf::ProtobufEnumOrUnknown::new(flow_message::FlowType::FLOWUNKNOWN) {
            my_size += ::protobuf::rt::enum_or_unknown_size(1, self.Type);
        }
        if self.TimeReceived != 0 {
            my_size += ::protobuf::rt::value_size(2, self.TimeReceived, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.SequenceNum != 0 {
            my_size += ::protobuf::rt::value_size(4, self.SequenceNum, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.SamplingRate != 0 {
            my_size += ::protobuf::rt::value_size(3, self.SamplingRate, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.FlowDirection != 0 {
            my_size += ::protobuf::rt::value_size(42, self.FlowDirection, ::protobuf::wire_format::WireTypeVarint);
        }
        if !self.SamplerAddress.is_empty() {
            my_size += ::protobuf::rt::bytes_size(11, &self.SamplerAddress);
        }
        if self.TimeFlowStart != 0 {
            my_size += ::protobuf::rt::value_size(38, self.TimeFlowStart, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.TimeFlowEnd != 0 {
            my_size += ::protobuf::rt::value_size(5, self.TimeFlowEnd, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.Bytes != 0 {
            my_size += ::protobuf::rt::value_size(9, self.Bytes, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.Packets != 0 {
            my_size += ::protobuf::rt::value_size(10, self.Packets, ::protobuf::wire_format::WireTypeVarint);
        }
        if !self.SrcAddr.is_empty() {
            my_size += ::protobuf::rt::bytes_size(6, &self.SrcAddr);
        }
        if !self.DstAddr.is_empty() {
            my_size += ::protobuf::rt::bytes_size(7, &self.DstAddr);
        }
        if self.Etype != 0 {
            my_size += ::protobuf::rt::value_size(30, self.Etype, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.Proto != 0 {
            my_size += ::protobuf::rt::value_size(20, self.Proto, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.SrcPort != 0 {
            my_size += ::protobuf::rt::value_size(21, self.SrcPort, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.DstPort != 0 {
            my_size += ::protobuf::rt::value_size(22, self.DstPort, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.InIf != 0 {
            my_size += ::protobuf::rt::value_size(18, self.InIf, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.OutIf != 0 {
            my_size += ::protobuf::rt::value_size(19, self.OutIf, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.SrcMac != 0 {
            my_size += ::protobuf::rt::value_size(27, self.SrcMac, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.DstMac != 0 {
            my_size += ::protobuf::rt::value_size(28, self.DstMac, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.SrcVlan != 0 {
            my_size += ::protobuf::rt::value_size(33, self.SrcVlan, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.DstVlan != 0 {
            my_size += ::protobuf::rt::value_size(34, self.DstVlan, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.VlanId != 0 {
            my_size += ::protobuf::rt::value_size(29, self.VlanId, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.IngressVrfID != 0 {
            my_size += ::protobuf::rt::value_size(39, self.IngressVrfID, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.EgressVrfID != 0 {
            my_size += ::protobuf::rt::value_size(40, self.EgressVrfID, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.IPTos != 0 {
            my_size += ::protobuf::rt::value_size(23, self.IPTos, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.ForwardingStatus != 0 {
            my_size += ::protobuf::rt::value_size(24, self.ForwardingStatus, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.IPTTL != 0 {
            my_size += ::protobuf::rt::value_size(25, self.IPTTL, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.TCPFlags != 0 {
            my_size += ::protobuf::rt::value_size(26, self.TCPFlags, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.IcmpType != 0 {
            my_size += ::protobuf::rt::value_size(31, self.IcmpType, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.IcmpCode != 0 {
            my_size += ::protobuf::rt::value_size(32, self.IcmpCode, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.IPv6FlowLabel != 0 {
            my_size += ::protobuf::rt::value_size(37, self.IPv6FlowLabel, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.FragmentId != 0 {
            my_size += ::protobuf::rt::value_size(35, self.FragmentId, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.FragmentOffset != 0 {
            my_size += ::protobuf::rt::value_size(36, self.FragmentOffset, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.BiFlowDirection != 0 {
            my_size += ::protobuf::rt::value_size(41, self.BiFlowDirection, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.SrcAS != 0 {
            my_size += ::protobuf::rt::value_size(14, self.SrcAS, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.DstAS != 0 {
            my_size += ::protobuf::rt::value_size(15, self.DstAS, ::protobuf::wire_format::WireTypeVarint);
        }
        if !self.NextHop.is_empty() {
            my_size += ::protobuf::rt::bytes_size(12, &self.NextHop);
        }
        if self.NextHopAS != 0 {
            my_size += ::protobuf::rt::value_size(13, self.NextHopAS, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.SrcNet != 0 {
            my_size += ::protobuf::rt::value_size(16, self.SrcNet, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.DstNet != 0 {
            my_size += ::protobuf::rt::value_size(17, self.DstNet, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.HasMPLS != false {
            my_size += 3;
        }
        if self.MPLSCount != 0 {
            my_size += ::protobuf::rt::value_size(54, self.MPLSCount, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.MPLS1TTL != 0 {
            my_size += ::protobuf::rt::value_size(55, self.MPLS1TTL, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.MPLS1Label != 0 {
            my_size += ::protobuf::rt::value_size(56, self.MPLS1Label, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.MPLS2TTL != 0 {
            my_size += ::protobuf::rt::value_size(57, self.MPLS2TTL, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.MPLS2Label != 0 {
            my_size += ::protobuf::rt::value_size(58, self.MPLS2Label, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.MPLS3TTL != 0 {
            my_size += ::protobuf::rt::value_size(59, self.MPLS3TTL, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.MPLS3Label != 0 {
            my_size += ::protobuf::rt::value_size(60, self.MPLS3Label, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.MPLSLastTTL != 0 {
            my_size += ::protobuf::rt::value_size(61, self.MPLSLastTTL, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.MPLSLastLabel != 0 {
            my_size += ::protobuf::rt::value_size(62, self.MPLSLastLabel, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.Cid != 0 {
            my_size += ::protobuf::rt::value_size(1000, self.Cid, ::protobuf::wire_format::WireTypeVarint);
        }
        if !self.CidString.is_empty() {
            my_size += ::protobuf::rt::string_size(1001, &self.CidString);
        }
        if self.SrcCid != 0 {
            my_size += ::protobuf::rt::value_size(1012, self.SrcCid, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.DstCid != 0 {
            my_size += ::protobuf::rt::value_size(1013, self.DstCid, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.Normalized != ::protobuf::ProtobufEnumOrUnknown::new(flow_message::NormalizedType::No) {
            my_size += ::protobuf::rt::enum_or_unknown_size(1002, self.Normalized);
        }
        if !self.SrcIfName.is_empty() {
            my_size += ::protobuf::rt::string_size(1003, &self.SrcIfName);
        }
        if !self.SrcIfDesc.is_empty() {
            my_size += ::protobuf::rt::string_size(1004, &self.SrcIfDesc);
        }
        if self.SrcIfSpeed != 0 {
            my_size += ::protobuf::rt::value_size(1005, self.SrcIfSpeed, ::protobuf::wire_format::WireTypeVarint);
        }
        if !self.DstIfName.is_empty() {
            my_size += ::protobuf::rt::string_size(1006, &self.DstIfName);
        }
        if !self.DstIfDesc.is_empty() {
            my_size += ::protobuf::rt::string_size(1007, &self.DstIfDesc);
        }
        if self.DstIfSpeed != 0 {
            my_size += ::protobuf::rt::value_size(1008, self.DstIfSpeed, ::protobuf::wire_format::WireTypeVarint);
        }
        if !self.ProtoName.is_empty() {
            my_size += ::protobuf::rt::string_size(1009, &self.ProtoName);
        }
        if !self.RemoteCountry.is_empty() {
            my_size += ::protobuf::rt::string_size(1010, &self.RemoteCountry);
        }
        if !self.SrcCountry.is_empty() {
            my_size += ::protobuf::rt::string_size(1014, &self.SrcCountry);
        }
        if !self.DstCountry.is_empty() {
            my_size += ::protobuf::rt::string_size(1015, &self.DstCountry);
        }
        if self.RemoteAddr != ::protobuf::ProtobufEnumOrUnknown::new(flow_message::RemoteAddrType::Neither) {
            my_size += ::protobuf::rt::enum_or_unknown_size(1011, self.RemoteAddr);
        }
        if !self.Note.is_empty() {
            my_size += ::protobuf::rt::string_size(1016, &self.Note);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.Type != ::protobuf::ProtobufEnumOrUnknown::new(flow_message::FlowType::FLOWUNKNOWN) {
            os.write_enum(1, ::protobuf::ProtobufEnumOrUnknown::value(&self.Type))?;
        }
        if self.TimeReceived != 0 {
            os.write_uint64(2, self.TimeReceived)?;
        }
        if self.SequenceNum != 0 {
            os.write_uint32(4, self.SequenceNum)?;
        }
        if self.SamplingRate != 0 {
            os.write_uint64(3, self.SamplingRate)?;
        }
        if self.FlowDirection != 0 {
            os.write_uint32(42, self.FlowDirection)?;
        }
        if !self.SamplerAddress.is_empty() {
            os.write_bytes(11, &self.SamplerAddress)?;
        }
        if self.TimeFlowStart != 0 {
            os.write_uint64(38, self.TimeFlowStart)?;
        }
        if self.TimeFlowEnd != 0 {
            os.write_uint64(5, self.TimeFlowEnd)?;
        }
        if self.Bytes != 0 {
            os.write_uint64(9, self.Bytes)?;
        }
        if self.Packets != 0 {
            os.write_uint64(10, self.Packets)?;
        }
        if !self.SrcAddr.is_empty() {
            os.write_bytes(6, &self.SrcAddr)?;
        }
        if !self.DstAddr.is_empty() {
            os.write_bytes(7, &self.DstAddr)?;
        }
        if self.Etype != 0 {
            os.write_uint32(30, self.Etype)?;
        }
        if self.Proto != 0 {
            os.write_uint32(20, self.Proto)?;
        }
        if self.SrcPort != 0 {
            os.write_uint32(21, self.SrcPort)?;
        }
        if self.DstPort != 0 {
            os.write_uint32(22, self.DstPort)?;
        }
        if self.InIf != 0 {
            os.write_uint32(18, self.InIf)?;
        }
        if self.OutIf != 0 {
            os.write_uint32(19, self.OutIf)?;
        }
        if self.SrcMac != 0 {
            os.write_uint64(27, self.SrcMac)?;
        }
        if self.DstMac != 0 {
            os.write_uint64(28, self.DstMac)?;
        }
        if self.SrcVlan != 0 {
            os.write_uint32(33, self.SrcVlan)?;
        }
        if self.DstVlan != 0 {
            os.write_uint32(34, self.DstVlan)?;
        }
        if self.VlanId != 0 {
            os.write_uint32(29, self.VlanId)?;
        }
        if self.IngressVrfID != 0 {
            os.write_uint32(39, self.IngressVrfID)?;
        }
        if self.EgressVrfID != 0 {
            os.write_uint32(40, self.EgressVrfID)?;
        }
        if self.IPTos != 0 {
            os.write_uint32(23, self.IPTos)?;
        }
        if self.ForwardingStatus != 0 {
            os.write_uint32(24, self.ForwardingStatus)?;
        }
        if self.IPTTL != 0 {
            os.write_uint32(25, self.IPTTL)?;
        }
        if self.TCPFlags != 0 {
            os.write_uint32(26, self.TCPFlags)?;
        }
        if self.IcmpType != 0 {
            os.write_uint32(31, self.IcmpType)?;
        }
        if self.IcmpCode != 0 {
            os.write_uint32(32, self.IcmpCode)?;
        }
        if self.IPv6FlowLabel != 0 {
            os.write_uint32(37, self.IPv6FlowLabel)?;
        }
        if self.FragmentId != 0 {
            os.write_uint32(35, self.FragmentId)?;
        }
        if self.FragmentOffset != 0 {
            os.write_uint32(36, self.FragmentOffset)?;
        }
        if self.BiFlowDirection != 0 {
            os.write_uint32(41, self.BiFlowDirection)?;
        }
        if self.SrcAS != 0 {
            os.write_uint32(14, self.SrcAS)?;
        }
        if self.DstAS != 0 {
            os.write_uint32(15, self.DstAS)?;
        }
        if !self.NextHop.is_empty() {
            os.write_bytes(12, &self.NextHop)?;
        }
        if self.NextHopAS != 0 {
            os.write_uint32(13, self.NextHopAS)?;
        }
        if self.SrcNet != 0 {
            os.write_uint32(16, self.SrcNet)?;
        }
        if self.DstNet != 0 {
            os.write_uint32(17, self.DstNet)?;
        }
        if self.HasMPLS != false {
            os.write_bool(53, self.HasMPLS)?;
        }
        if self.MPLSCount != 0 {
            os.write_uint32(54, self.MPLSCount)?;
        }
        if self.MPLS1TTL != 0 {
            os.write_uint32(55, self.MPLS1TTL)?;
        }
        if self.MPLS1Label != 0 {
            os.write_uint32(56, self.MPLS1Label)?;
        }
        if self.MPLS2TTL != 0 {
            os.write_uint32(57, self.MPLS2TTL)?;
        }
        if self.MPLS2Label != 0 {
            os.write_uint32(58, self.MPLS2Label)?;
        }
        if self.MPLS3TTL != 0 {
            os.write_uint32(59, self.MPLS3TTL)?;
        }
        if self.MPLS3Label != 0 {
            os.write_uint32(60, self.MPLS3Label)?;
        }
        if self.MPLSLastTTL != 0 {
            os.write_uint32(61, self.MPLSLastTTL)?;
        }
        if self.MPLSLastLabel != 0 {
            os.write_uint32(62, self.MPLSLastLabel)?;
        }
        if self.Cid != 0 {
            os.write_uint32(1000, self.Cid)?;
        }
        if !self.CidString.is_empty() {
            os.write_string(1001, &self.CidString)?;
        }
        if self.SrcCid != 0 {
            os.write_uint32(1012, self.SrcCid)?;
        }
        if self.DstCid != 0 {
            os.write_uint32(1013, self.DstCid)?;
        }
        if self.Normalized != ::protobuf::ProtobufEnumOrUnknown::new(flow_message::NormalizedType::No) {
            os.write_enum(1002, ::protobuf::ProtobufEnumOrUnknown::value(&self.Normalized))?;
        }
        if !self.SrcIfName.is_empty() {
            os.write_string(1003, &self.SrcIfName)?;
        }
        if !self.SrcIfDesc.is_empty() {
            os.write_string(1004, &self.SrcIfDesc)?;
        }
        if self.SrcIfSpeed != 0 {
            os.write_uint32(1005, self.SrcIfSpeed)?;
        }
        if !self.DstIfName.is_empty() {
            os.write_string(1006, &self.DstIfName)?;
        }
        if !self.DstIfDesc.is_empty() {
            os.write_string(1007, &self.DstIfDesc)?;
        }
        if self.DstIfSpeed != 0 {
            os.write_uint32(1008, self.DstIfSpeed)?;
        }
        if !self.ProtoName.is_empty() {
            os.write_string(1009, &self.ProtoName)?;
        }
        if !self.RemoteCountry.is_empty() {
            os.write_string(1010, &self.RemoteCountry)?;
        }
        if !self.SrcCountry.is_empty() {
            os.write_string(1014, &self.SrcCountry)?;
        }
        if !self.DstCountry.is_empty() {
            os.write_string(1015, &self.DstCountry)?;
        }
        if self.RemoteAddr != ::protobuf::ProtobufEnumOrUnknown::new(flow_message::RemoteAddrType::Neither) {
            os.write_enum(1011, ::protobuf::ProtobufEnumOrUnknown::value(&self.RemoteAddr))?;
        }
        if !self.Note.is_empty() {
            os.write_string(1016, &self.Note)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn new() -> FlowMessage {
        FlowMessage::new()
    }

    fn descriptor_static() -> ::protobuf::reflect::MessageDescriptor {
        ::protobuf::reflect::MessageDescriptor::new_generated_2(file_descriptor(), 0)
    }

    fn default_instance() -> &'static FlowMessage {
        static instance: FlowMessage = FlowMessage {
            Type: ::protobuf::ProtobufEnumOrUnknown::from_i32(0),
            TimeReceived: 0,
            SequenceNum: 0,
            SamplingRate: 0,
            FlowDirection: 0,
            SamplerAddress: ::std::vec::Vec::new(),
            TimeFlowStart: 0,
            TimeFlowEnd: 0,
            Bytes: 0,
            Packets: 0,
            SrcAddr: ::std::vec::Vec::new(),
            DstAddr: ::std::vec::Vec::new(),
            Etype: 0,
            Proto: 0,
            SrcPort: 0,
            DstPort: 0,
            InIf: 0,
            OutIf: 0,
            SrcMac: 0,
            DstMac: 0,
            SrcVlan: 0,
            DstVlan: 0,
            VlanId: 0,
            IngressVrfID: 0,
            EgressVrfID: 0,
            IPTos: 0,
            ForwardingStatus: 0,
            IPTTL: 0,
            TCPFlags: 0,
            IcmpType: 0,
            IcmpCode: 0,
            IPv6FlowLabel: 0,
            FragmentId: 0,
            FragmentOffset: 0,
            BiFlowDirection: 0,
            SrcAS: 0,
            DstAS: 0,
            NextHop: ::std::vec::Vec::new(),
            NextHopAS: 0,
            SrcNet: 0,
            DstNet: 0,
            HasMPLS: false,
            MPLSCount: 0,
            MPLS1TTL: 0,
            MPLS1Label: 0,
            MPLS2TTL: 0,
            MPLS2Label: 0,
            MPLS3TTL: 0,
            MPLS3Label: 0,
            MPLSLastTTL: 0,
            MPLSLastLabel: 0,
            Cid: 0,
            CidString: ::std::string::String::new(),
            SrcCid: 0,
            DstCid: 0,
            Normalized: ::protobuf::ProtobufEnumOrUnknown::from_i32(0),
            SrcIfName: ::std::string::String::new(),
            SrcIfDesc: ::std::string::String::new(),
            SrcIfSpeed: 0,
            DstIfName: ::std::string::String::new(),
            DstIfDesc: ::std::string::String::new(),
            DstIfSpeed: 0,
            ProtoName: ::std::string::String::new(),
            RemoteCountry: ::std::string::String::new(),
            SrcCountry: ::std::string::String::new(),
            DstCountry: ::std::string::String::new(),
            RemoteAddr: ::protobuf::ProtobufEnumOrUnknown::from_i32(0),
            Note: ::std::string::String::new(),
            unknown_fields: ::protobuf::UnknownFields::new(),
            cached_size: ::protobuf::rt::CachedSize::new(),
        };
        &instance
    }
}

impl ::protobuf::Clear for FlowMessage {
    fn clear(&mut self) {
        self.Type = ::protobuf::ProtobufEnumOrUnknown::new(flow_message::FlowType::FLOWUNKNOWN);
        self.TimeReceived = 0;
        self.SequenceNum = 0;
        self.SamplingRate = 0;
        self.FlowDirection = 0;
        self.SamplerAddress.clear();
        self.TimeFlowStart = 0;
        self.TimeFlowEnd = 0;
        self.Bytes = 0;
        self.Packets = 0;
        self.SrcAddr.clear();
        self.DstAddr.clear();
        self.Etype = 0;
        self.Proto = 0;
        self.SrcPort = 0;
        self.DstPort = 0;
        self.InIf = 0;
        self.OutIf = 0;
        self.SrcMac = 0;
        self.DstMac = 0;
        self.SrcVlan = 0;
        self.DstVlan = 0;
        self.VlanId = 0;
        self.IngressVrfID = 0;
        self.EgressVrfID = 0;
        self.IPTos = 0;
        self.ForwardingStatus = 0;
        self.IPTTL = 0;
        self.TCPFlags = 0;
        self.IcmpType = 0;
        self.IcmpCode = 0;
        self.IPv6FlowLabel = 0;
        self.FragmentId = 0;
        self.FragmentOffset = 0;
        self.BiFlowDirection = 0;
        self.SrcAS = 0;
        self.DstAS = 0;
        self.NextHop.clear();
        self.NextHopAS = 0;
        self.SrcNet = 0;
        self.DstNet = 0;
        self.HasMPLS = false;
        self.MPLSCount = 0;
        self.MPLS1TTL = 0;
        self.MPLS1Label = 0;
        self.MPLS2TTL = 0;
        self.MPLS2Label = 0;
        self.MPLS3TTL = 0;
        self.MPLS3Label = 0;
        self.MPLSLastTTL = 0;
        self.MPLSLastLabel = 0;
        self.Cid = 0;
        self.CidString.clear();
        self.SrcCid = 0;
        self.DstCid = 0;
        self.Normalized = ::protobuf::ProtobufEnumOrUnknown::new(flow_message::NormalizedType::No);
        self.SrcIfName.clear();
        self.SrcIfDesc.clear();
        self.SrcIfSpeed = 0;
        self.DstIfName.clear();
        self.DstIfDesc.clear();
        self.DstIfSpeed = 0;
        self.ProtoName.clear();
        self.RemoteCountry.clear();
        self.SrcCountry.clear();
        self.DstCountry.clear();
        self.RemoteAddr = ::protobuf::ProtobufEnumOrUnknown::new(flow_message::RemoteAddrType::Neither);
        self.Note.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for FlowMessage {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for FlowMessage {
    type RuntimeType = ::protobuf::reflect::runtime_types::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `FlowMessage`
pub mod flow_message {
    #[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
    pub enum FlowType {
        FLOWUNKNOWN = 0,
        SFLOW_5 = 1,
        NETFLOW_V5 = 2,
        NETFLOW_V9 = 3,
        IPFIX = 4,
    }

    impl ::protobuf::ProtobufEnum for FlowType {
        fn value(&self) -> i32 {
            *self as i32
        }

        fn from_i32(value: i32) -> ::std::option::Option<FlowType> {
            match value {
                0 => ::std::option::Option::Some(FlowType::FLOWUNKNOWN),
                1 => ::std::option::Option::Some(FlowType::SFLOW_5),
                2 => ::std::option::Option::Some(FlowType::NETFLOW_V5),
                3 => ::std::option::Option::Some(FlowType::NETFLOW_V9),
                4 => ::std::option::Option::Some(FlowType::IPFIX),
                _ => ::std::option::Option::None
            }
        }

        fn values() -> &'static [Self] {
            static values: &'static [FlowType] = &[
                FlowType::FLOWUNKNOWN,
                FlowType::SFLOW_5,
                FlowType::NETFLOW_V5,
                FlowType::NETFLOW_V9,
                FlowType::IPFIX,
            ];
            values
        }

        fn enum_descriptor_static() -> ::protobuf::reflect::EnumDescriptor {
            ::protobuf::reflect::EnumDescriptor::new_generated_2(super::file_descriptor(), 0)
        }
    }

    impl ::std::default::Default for FlowType {
        fn default() -> Self {
            FlowType::FLOWUNKNOWN
        }
    }

    impl ::protobuf::reflect::ProtobufValue for FlowType {
        type RuntimeType = ::protobuf::reflect::runtime_types::RuntimeTypeEnum<Self>;
    }

    impl FlowType {
        pub(in super) fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
            ::protobuf::reflect::GeneratedEnumDescriptorData::new_2::<FlowType>("FlowMessage.FlowType", 0)
        }
    }

    #[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
    pub enum NormalizedType {
        No = 0,
        Yes = 1,
    }

    impl ::protobuf::ProtobufEnum for NormalizedType {
        fn value(&self) -> i32 {
            *self as i32
        }

        fn from_i32(value: i32) -> ::std::option::Option<NormalizedType> {
            match value {
                0 => ::std::option::Option::Some(NormalizedType::No),
                1 => ::std::option::Option::Some(NormalizedType::Yes),
                _ => ::std::option::Option::None
            }
        }

        fn values() -> &'static [Self] {
            static values: &'static [NormalizedType] = &[
                NormalizedType::No,
                NormalizedType::Yes,
            ];
            values
        }

        fn enum_descriptor_static() -> ::protobuf::reflect::EnumDescriptor {
            ::protobuf::reflect::EnumDescriptor::new_generated_2(super::file_descriptor(), 1)
        }
    }

    impl ::std::default::Default for NormalizedType {
        fn default() -> Self {
            NormalizedType::No
        }
    }

    impl ::protobuf::reflect::ProtobufValue for NormalizedType {
        type RuntimeType = ::protobuf::reflect::runtime_types::RuntimeTypeEnum<Self>;
    }

    impl NormalizedType {
        pub(in super) fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
            ::protobuf::reflect::GeneratedEnumDescriptorData::new_2::<NormalizedType>("FlowMessage.NormalizedType", 1)
        }
    }

    #[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
    pub enum RemoteAddrType {
        Neither = 0,
        Src = 1,
        Dst = 2,
    }

    impl ::protobuf::ProtobufEnum for RemoteAddrType {
        fn value(&self) -> i32 {
            *self as i32
        }

        fn from_i32(value: i32) -> ::std::option::Option<RemoteAddrType> {
            match value {
                0 => ::std::option::Option::Some(RemoteAddrType::Neither),
                1 => ::std::option::Option::Some(RemoteAddrType::Src),
                2 => ::std::option::Option::Some(RemoteAddrType::Dst),
                _ => ::std::option::Option::None
            }
        }

        fn values() -> &'static [Self] {
            static values: &'static [RemoteAddrType] = &[
                RemoteAddrType::Neither,
                RemoteAddrType::Src,
                RemoteAddrType::Dst,
            ];
            values
        }

        fn enum_descriptor_static() -> ::protobuf::reflect::EnumDescriptor {
            ::protobuf::reflect::EnumDescriptor::new_generated_2(super::file_descriptor(), 2)
        }
    }

    impl ::std::default::Default for RemoteAddrType {
        fn default() -> Self {
            RemoteAddrType::Neither
        }
    }

    impl ::protobuf::reflect::ProtobufValue for RemoteAddrType {
        type RuntimeType = ::protobuf::reflect::runtime_types::RuntimeTypeEnum<Self>;
    }

    impl RemoteAddrType {
        pub(in super) fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
            ::protobuf::reflect::GeneratedEnumDescriptorData::new_2::<RemoteAddrType>("FlowMessage.RemoteAddrType", 2)
        }
    }
}

static file_descriptor_proto_data: &'static [u8] = b"\
    \n\x1cflow-messages-enriched.proto\x12\x13flowmessageenriched\"\x94\x12\
    \n\x0bFlowMessage\x12=\n\x04Type\x18\x01\x20\x01(\x0e2).flowmessageenric\
    hed.FlowMessage.FlowTypeR\x04Type\x12\"\n\x0cTimeReceived\x18\x02\x20\
    \x01(\x04R\x0cTimeReceived\x12\x20\n\x0bSequenceNum\x18\x04\x20\x01(\rR\
    \x0bSequenceNum\x12\"\n\x0cSamplingRate\x18\x03\x20\x01(\x04R\x0cSamplin\
    gRate\x12$\n\rFlowDirection\x18*\x20\x01(\rR\rFlowDirection\x12&\n\x0eSa\
    mplerAddress\x18\x0b\x20\x01(\x0cR\x0eSamplerAddress\x12$\n\rTimeFlowSta\
    rt\x18&\x20\x01(\x04R\rTimeFlowStart\x12\x20\n\x0bTimeFlowEnd\x18\x05\
    \x20\x01(\x04R\x0bTimeFlowEnd\x12\x14\n\x05Bytes\x18\t\x20\x01(\x04R\x05\
    Bytes\x12\x18\n\x07Packets\x18\n\x20\x01(\x04R\x07Packets\x12\x18\n\x07S\
    rcAddr\x18\x06\x20\x01(\x0cR\x07SrcAddr\x12\x18\n\x07DstAddr\x18\x07\x20\
    \x01(\x0cR\x07DstAddr\x12\x14\n\x05Etype\x18\x1e\x20\x01(\rR\x05Etype\
    \x12\x14\n\x05Proto\x18\x14\x20\x01(\rR\x05Proto\x12\x18\n\x07SrcPort\
    \x18\x15\x20\x01(\rR\x07SrcPort\x12\x18\n\x07DstPort\x18\x16\x20\x01(\rR\
    \x07DstPort\x12\x12\n\x04InIf\x18\x12\x20\x01(\rR\x04InIf\x12\x14\n\x05O\
    utIf\x18\x13\x20\x01(\rR\x05OutIf\x12\x16\n\x06SrcMac\x18\x1b\x20\x01(\
    \x04R\x06SrcMac\x12\x16\n\x06DstMac\x18\x1c\x20\x01(\x04R\x06DstMac\x12\
    \x18\n\x07SrcVlan\x18!\x20\x01(\rR\x07SrcVlan\x12\x18\n\x07DstVlan\x18\"\
    \x20\x01(\rR\x07DstVlan\x12\x16\n\x06VlanId\x18\x1d\x20\x01(\rR\x06VlanI\
    d\x12\"\n\x0cIngressVrfID\x18'\x20\x01(\rR\x0cIngressVrfID\x12\x20\n\x0b\
    EgressVrfID\x18(\x20\x01(\rR\x0bEgressVrfID\x12\x14\n\x05IPTos\x18\x17\
    \x20\x01(\rR\x05IPTos\x12*\n\x10ForwardingStatus\x18\x18\x20\x01(\rR\x10\
    ForwardingStatus\x12\x14\n\x05IPTTL\x18\x19\x20\x01(\rR\x05IPTTL\x12\x1a\
    \n\x08TCPFlags\x18\x1a\x20\x01(\rR\x08TCPFlags\x12\x1a\n\x08IcmpType\x18\
    \x1f\x20\x01(\rR\x08IcmpType\x12\x1a\n\x08IcmpCode\x18\x20\x20\x01(\rR\
    \x08IcmpCode\x12$\n\rIPv6FlowLabel\x18%\x20\x01(\rR\rIPv6FlowLabel\x12\
    \x1e\n\nFragmentId\x18#\x20\x01(\rR\nFragmentId\x12&\n\x0eFragmentOffset\
    \x18$\x20\x01(\rR\x0eFragmentOffset\x12(\n\x0fBiFlowDirection\x18)\x20\
    \x01(\rR\x0fBiFlowDirection\x12\x14\n\x05SrcAS\x18\x0e\x20\x01(\rR\x05Sr\
    cAS\x12\x14\n\x05DstAS\x18\x0f\x20\x01(\rR\x05DstAS\x12\x18\n\x07NextHop\
    \x18\x0c\x20\x01(\x0cR\x07NextHop\x12\x1c\n\tNextHopAS\x18\r\x20\x01(\rR\
    \tNextHopAS\x12\x16\n\x06SrcNet\x18\x10\x20\x01(\rR\x06SrcNet\x12\x16\n\
    \x06DstNet\x18\x11\x20\x01(\rR\x06DstNet\x12\x18\n\x07HasMPLS\x185\x20\
    \x01(\x08R\x07HasMPLS\x12\x1c\n\tMPLSCount\x186\x20\x01(\rR\tMPLSCount\
    \x12\x1a\n\x08MPLS1TTL\x187\x20\x01(\rR\x08MPLS1TTL\x12\x1e\n\nMPLS1Labe\
    l\x188\x20\x01(\rR\nMPLS1Label\x12\x1a\n\x08MPLS2TTL\x189\x20\x01(\rR\
    \x08MPLS2TTL\x12\x1e\n\nMPLS2Label\x18:\x20\x01(\rR\nMPLS2Label\x12\x1a\
    \n\x08MPLS3TTL\x18;\x20\x01(\rR\x08MPLS3TTL\x12\x1e\n\nMPLS3Label\x18<\
    \x20\x01(\rR\nMPLS3Label\x12\x20\n\x0bMPLSLastTTL\x18=\x20\x01(\rR\x0bMP\
    LSLastTTL\x12$\n\rMPLSLastLabel\x18>\x20\x01(\rR\rMPLSLastLabel\x12\x11\
    \n\x03Cid\x18\xe8\x07\x20\x01(\rR\x03Cid\x12\x1d\n\tCidString\x18\xe9\
    \x07\x20\x01(\tR\tCidString\x12\x17\n\x06SrcCid\x18\xf4\x07\x20\x01(\rR\
    \x06SrcCid\x12\x17\n\x06DstCid\x18\xf5\x07\x20\x01(\rR\x06DstCid\x12P\n\
    \nNormalized\x18\xea\x07\x20\x01(\x0e2/.flowmessageenriched.FlowMessage.\
    NormalizedTypeR\nNormalized\x12\x1d\n\tSrcIfName\x18\xeb\x07\x20\x01(\tR\
    \tSrcIfName\x12\x1d\n\tSrcIfDesc\x18\xec\x07\x20\x01(\tR\tSrcIfDesc\x12\
    \x1f\n\nSrcIfSpeed\x18\xed\x07\x20\x01(\rR\nSrcIfSpeed\x12\x1d\n\tDstIfN\
    ame\x18\xee\x07\x20\x01(\tR\tDstIfName\x12\x1d\n\tDstIfDesc\x18\xef\x07\
    \x20\x01(\tR\tDstIfDesc\x12\x1f\n\nDstIfSpeed\x18\xf0\x07\x20\x01(\rR\nD\
    stIfSpeed\x12\x1d\n\tProtoName\x18\xf1\x07\x20\x01(\tR\tProtoName\x12%\n\
    \rRemoteCountry\x18\xf2\x07\x20\x01(\tR\rRemoteCountry\x12\x1f\n\nSrcCou\
    ntry\x18\xf6\x07\x20\x01(\tR\nSrcCountry\x12\x1f\n\nDstCountry\x18\xf7\
    \x07\x20\x01(\tR\nDstCountry\x12P\n\nRemoteAddr\x18\xf3\x07\x20\x01(\x0e\
    2/.flowmessageenriched.FlowMessage.RemoteAddrTypeR\nRemoteAddr\x12\x13\n\
    \x04Note\x18\xf8\x07\x20\x01(\tR\x04Note\"S\n\x08FlowType\x12\x0f\n\x0bF\
    LOWUNKNOWN\x10\0\x12\x0b\n\x07SFLOW_5\x10\x01\x12\x0e\n\nNETFLOW_V5\x10\
    \x02\x12\x0e\n\nNETFLOW_V9\x10\x03\x12\t\n\x05IPFIX\x10\x04\"!\n\x0eNorm\
    alizedType\x12\x06\n\x02No\x10\0\x12\x07\n\x03Yes\x10\x01\"/\n\x0eRemote\
    AddrType\x12\x0b\n\x07Neither\x10\0\x12\x07\n\x03Src\x10\x01\x12\x07\n\
    \x03Dst\x10\x02BX\n\tbwnetflowB\x15FlowMessageEnrichedPbZ4github.com/bwN\
    etFlow/protobuf/go;flowmessageenrichedJ\xba-\n\x07\x12\x05\0\0\x8a\x01\
    \x01\n\x08\n\x01\x0c\x12\x03\0\0\x12\n\x08\n\x01\x02\x12\x03\x01\0\x1c\n\
    \x08\n\x01\x08\x12\x03\x02\0\"\n\t\n\x02\x08\x01\x12\x03\x02\0\"\n\x08\n\
    \x01\x08\x12\x03\x03\06\n\t\n\x02\x08\x08\x12\x03\x03\06\n\x08\n\x01\x08\
    \x12\x03\x04\0K\n\t\n\x02\x08\x0b\x12\x03\x04\0K\n\x0b\n\x02\x04\0\x12\
    \x05\x06\0\x8a\x01\x01\n\n\n\x03\x04\0\x01\x12\x03\x06\x08\x13\n\x0c\n\
    \x04\x04\0\x04\0\x12\x04\x07\x02\r\x03\n\x0c\n\x05\x04\0\x04\0\x01\x12\
    \x03\x07\x07\x0f\n\r\n\x06\x04\0\x04\0\x02\0\x12\x03\x08\x04\x14\n\x0e\n\
    \x07\x04\0\x04\0\x02\0\x01\x12\x03\x08\x04\x0f\n\x0e\n\x07\x04\0\x04\0\
    \x02\0\x02\x12\x03\x08\x12\x13\n\r\n\x06\x04\0\x04\0\x02\x01\x12\x03\t\
    \x04\x10\n\x0e\n\x07\x04\0\x04\0\x02\x01\x01\x12\x03\t\x04\x0b\n\x0e\n\
    \x07\x04\0\x04\0\x02\x01\x02\x12\x03\t\x0e\x0f\n\r\n\x06\x04\0\x04\0\x02\
    \x02\x12\x03\n\x04\x13\n\x0e\n\x07\x04\0\x04\0\x02\x02\x01\x12\x03\n\x04\
    \x0e\n\x0e\n\x07\x04\0\x04\0\x02\x02\x02\x12\x03\n\x11\x12\n\r\n\x06\x04\
    \0\x04\0\x02\x03\x12\x03\x0b\x04\x13\n\x0e\n\x07\x04\0\x04\0\x02\x03\x01\
    \x12\x03\x0b\x04\x0e\n\x0e\n\x07\x04\0\x04\0\x02\x03\x02\x12\x03\x0b\x11\
    \x12\n\r\n\x06\x04\0\x04\0\x02\x04\x12\x03\x0c\x04\x0e\n\x0e\n\x07\x04\0\
    \x04\0\x02\x04\x01\x12\x03\x0c\x04\t\n\x0e\n\x07\x04\0\x04\0\x02\x04\x02\
    \x12\x03\x0c\x0c\r\n\x0b\n\x04\x04\0\x02\0\x12\x03\x0e\x02\x14\n\x0c\n\
    \x05\x04\0\x02\0\x06\x12\x03\x0e\x02\n\n\x0c\n\x05\x04\0\x02\0\x01\x12\
    \x03\x0e\x0b\x0f\n\x0c\n\x05\x04\0\x02\0\x03\x12\x03\x0e\x12\x13\n\x0b\n\
    \x04\x04\0\x02\x01\x12\x03\x10\x02\x1a\n\x0c\n\x05\x04\0\x02\x01\x05\x12\
    \x03\x10\x02\x08\n\x0c\n\x05\x04\0\x02\x01\x01\x12\x03\x10\t\x15\n\x0c\n\
    \x05\x04\0\x02\x01\x03\x12\x03\x10\x18\x19\n\x0b\n\x04\x04\0\x02\x02\x12\
    \x03\x11\x02\x19\n\x0c\n\x05\x04\0\x02\x02\x05\x12\x03\x11\x02\x08\n\x0c\
    \n\x05\x04\0\x02\x02\x01\x12\x03\x11\t\x14\n\x0c\n\x05\x04\0\x02\x02\x03\
    \x12\x03\x11\x17\x18\n\x0b\n\x04\x04\0\x02\x03\x12\x03\x12\x02\x1a\n\x0c\
    \n\x05\x04\0\x02\x03\x05\x12\x03\x12\x02\x08\n\x0c\n\x05\x04\0\x02\x03\
    \x01\x12\x03\x12\t\x15\n\x0c\n\x05\x04\0\x02\x03\x03\x12\x03\x12\x18\x19\
    \n\x0b\n\x04\x04\0\x02\x04\x12\x03\x14\x02\x1c\n\x0c\n\x05\x04\0\x02\x04\
    \x05\x12\x03\x14\x02\x08\n\x0c\n\x05\x04\0\x02\x04\x01\x12\x03\x14\t\x16\
    \n\x0c\n\x05\x04\0\x02\x04\x03\x12\x03\x14\x19\x1b\n\"\n\x04\x04\0\x02\
    \x05\x12\x03\x17\x02\x1c\x1a\x15\x20Sampler\x20information\n\n\x0c\n\x05\
    \x04\0\x02\x05\x05\x12\x03\x17\x02\x07\n\x0c\n\x05\x04\0\x02\x05\x01\x12\
    \x03\x17\x08\x16\n\x0c\n\x05\x04\0\x02\x05\x03\x12\x03\x17\x19\x1b\n\"\n\
    \x04\x04\0\x02\x06\x12\x03\x1a\x02\x1c\x1a\x15\x20Found\x20inside\x20pac\
    ket\n\n\x0c\n\x05\x04\0\x02\x06\x05\x12\x03\x1a\x02\x08\n\x0c\n\x05\x04\
    \0\x02\x06\x01\x12\x03\x1a\t\x16\n\x0c\n\x05\x04\0\x02\x06\x03\x12\x03\
    \x1a\x19\x1b\n\x0b\n\x04\x04\0\x02\x07\x12\x03\x1b\x02\x19\n\x0c\n\x05\
    \x04\0\x02\x07\x05\x12\x03\x1b\x02\x08\n\x0c\n\x05\x04\0\x02\x07\x01\x12\
    \x03\x1b\t\x14\n\x0c\n\x05\x04\0\x02\x07\x03\x12\x03\x1b\x17\x18\n)\n\
    \x04\x04\0\x02\x08\x12\x03\x1e\x02\x13\x1a\x1c\x20Size\x20of\x20the\x20s\
    ampled\x20packet\n\n\x0c\n\x05\x04\0\x02\x08\x05\x12\x03\x1e\x02\x08\n\
    \x0c\n\x05\x04\0\x02\x08\x01\x12\x03\x1e\t\x0e\n\x0c\n\x05\x04\0\x02\x08\
    \x03\x12\x03\x1e\x11\x12\n\x0b\n\x04\x04\0\x02\t\x12\x03\x1f\x02\x16\n\
    \x0c\n\x05\x04\0\x02\t\x05\x12\x03\x1f\x02\x08\n\x0c\n\x05\x04\0\x02\t\
    \x01\x12\x03\x1f\t\x10\n\x0c\n\x05\x04\0\x02\t\x03\x12\x03\x1f\x13\x15\n\
    +\n\x04\x04\0\x02\n\x12\x03\"\x02\x14\x1a\x1e\x20Source/destination\x20a\
    ddresses\n\n\x0c\n\x05\x04\0\x02\n\x05\x12\x03\"\x02\x07\n\x0c\n\x05\x04\
    \0\x02\n\x01\x12\x03\"\x08\x0f\n\x0c\n\x05\x04\0\x02\n\x03\x12\x03\"\x12\
    \x13\n\x0b\n\x04\x04\0\x02\x0b\x12\x03#\x02\x14\n\x0c\n\x05\x04\0\x02\
    \x0b\x05\x12\x03#\x02\x07\n\x0c\n\x05\x04\0\x02\x0b\x01\x12\x03#\x08\x0f\
    \n\x0c\n\x05\x04\0\x02\x0b\x03\x12\x03#\x12\x13\n7\n\x04\x04\0\x02\x0c\
    \x12\x03&\x02\x14\x1a*\x20Layer\x203\x20protocol\x20(IPv4/IPv6/ARP/MPLS.\
    ..)\n\n\x0c\n\x05\x04\0\x02\x0c\x05\x12\x03&\x02\x08\n\x0c\n\x05\x04\0\
    \x02\x0c\x01\x12\x03&\t\x0e\n\x0c\n\x05\x04\0\x02\x0c\x03\x12\x03&\x11\
    \x13\n\x1f\n\x04\x04\0\x02\r\x12\x03)\x02\x14\x1a\x12\x20Layer\x204\x20p\
    rotocol\n\n\x0c\n\x05\x04\0\x02\r\x05\x12\x03)\x02\x08\n\x0c\n\x05\x04\0\
    \x02\r\x01\x12\x03)\t\x0e\n\x0c\n\x05\x04\0\x02\r\x03\x12\x03)\x11\x13\n\
    $\n\x04\x04\0\x02\x0e\x12\x03,\x02\x16\x1a\x17\x20Ports\x20for\x20UDP\
    \x20and\x20TCP\n\n\x0c\n\x05\x04\0\x02\x0e\x05\x12\x03,\x02\x08\n\x0c\n\
    \x05\x04\0\x02\x0e\x01\x12\x03,\t\x10\n\x0c\n\x05\x04\0\x02\x0e\x03\x12\
    \x03,\x13\x15\n\x0b\n\x04\x04\0\x02\x0f\x12\x03-\x02\x16\n\x0c\n\x05\x04\
    \0\x02\x0f\x05\x12\x03-\x02\x08\n\x0c\n\x05\x04\0\x02\x0f\x01\x12\x03-\t\
    \x10\n\x0c\n\x05\x04\0\x02\x0f\x03\x12\x03-\x13\x15\n\x19\n\x04\x04\0\
    \x02\x10\x12\x030\x02\x13\x1a\x0c\x20Interfaces\n\n\x0c\n\x05\x04\0\x02\
    \x10\x05\x12\x030\x02\x08\n\x0c\n\x05\x04\0\x02\x10\x01\x12\x030\t\r\n\
    \x0c\n\x05\x04\0\x02\x10\x03\x12\x030\x10\x12\n\x0b\n\x04\x04\0\x02\x11\
    \x12\x031\x02\x14\n\x0c\n\x05\x04\0\x02\x11\x05\x12\x031\x02\x08\n\x0c\n\
    \x05\x04\0\x02\x11\x01\x12\x031\t\x0e\n\x0c\n\x05\x04\0\x02\x11\x03\x12\
    \x031\x11\x13\n#\n\x04\x04\0\x02\x12\x12\x034\x02\x15\x1a\x16\x20Etherne\
    t\x20information\n\n\x0c\n\x05\x04\0\x02\x12\x05\x12\x034\x02\x08\n\x0c\
    \n\x05\x04\0\x02\x12\x01\x12\x034\t\x0f\n\x0c\n\x05\x04\0\x02\x12\x03\
    \x12\x034\x12\x14\n\x0b\n\x04\x04\0\x02\x13\x12\x035\x02\x15\n\x0c\n\x05\
    \x04\0\x02\x13\x05\x12\x035\x02\x08\n\x0c\n\x05\x04\0\x02\x13\x01\x12\
    \x035\t\x0f\n\x0c\n\x05\x04\0\x02\x13\x03\x12\x035\x12\x14\n\x13\n\x04\
    \x04\0\x02\x14\x12\x038\x02\x16\x1a\x06\x20Vlan\n\n\x0c\n\x05\x04\0\x02\
    \x14\x05\x12\x038\x02\x08\n\x0c\n\x05\x04\0\x02\x14\x01\x12\x038\t\x10\n\
    \x0c\n\x05\x04\0\x02\x14\x03\x12\x038\x13\x15\n\x0b\n\x04\x04\0\x02\x15\
    \x12\x039\x02\x16\n\x0c\n\x05\x04\0\x02\x15\x05\x12\x039\x02\x08\n\x0c\n\
    \x05\x04\0\x02\x15\x01\x12\x039\t\x10\n\x0c\n\x05\x04\0\x02\x15\x03\x12\
    \x039\x13\x15\n,\n\x04\x04\0\x02\x16\x12\x03;\x02\x15\x1a\x1f\x20802.1q\
    \x20VLAN\x20in\x20sampled\x20packet\n\n\x0c\n\x05\x04\0\x02\x16\x05\x12\
    \x03;\x02\x08\n\x0c\n\x05\x04\0\x02\x16\x01\x12\x03;\t\x0f\n\x0c\n\x05\
    \x04\0\x02\x16\x03\x12\x03;\x12\x14\n\x12\n\x04\x04\0\x02\x17\x12\x03>\
    \x02\x1b\x1a\x05\x20VRF\n\n\x0c\n\x05\x04\0\x02\x17\x05\x12\x03>\x02\x08\
    \n\x0c\n\x05\x04\0\x02\x17\x01\x12\x03>\t\x15\n\x0c\n\x05\x04\0\x02\x17\
    \x03\x12\x03>\x18\x1a\n\x0b\n\x04\x04\0\x02\x18\x12\x03?\x02\x1a\n\x0c\n\
    \x05\x04\0\x02\x18\x05\x12\x03?\x02\x08\n\x0c\n\x05\x04\0\x02\x18\x01\
    \x12\x03?\t\x14\n\x0c\n\x05\x04\0\x02\x18\x03\x12\x03?\x17\x19\n'\n\x04\
    \x04\0\x02\x19\x12\x03B\x02\x14\x1a\x1a\x20IP\x20and\x20TCP\x20special\
    \x20flags\n\n\x0c\n\x05\x04\0\x02\x19\x05\x12\x03B\x02\x08\n\x0c\n\x05\
    \x04\0\x02\x19\x01\x12\x03B\t\x0e\n\x0c\n\x05\x04\0\x02\x19\x03\x12\x03B\
    \x11\x13\n\x0b\n\x04\x04\0\x02\x1a\x12\x03C\x02\x1f\n\x0c\n\x05\x04\0\
    \x02\x1a\x05\x12\x03C\x02\x08\n\x0c\n\x05\x04\0\x02\x1a\x01\x12\x03C\t\
    \x19\n\x0c\n\x05\x04\0\x02\x1a\x03\x12\x03C\x1c\x1e\n\x0b\n\x04\x04\0\
    \x02\x1b\x12\x03D\x02\x14\n\x0c\n\x05\x04\0\x02\x1b\x05\x12\x03D\x02\x08\
    \n\x0c\n\x05\x04\0\x02\x1b\x01\x12\x03D\t\x0e\n\x0c\n\x05\x04\0\x02\x1b\
    \x03\x12\x03D\x11\x13\n\x0b\n\x04\x04\0\x02\x1c\x12\x03E\x02\x17\n\x0c\n\
    \x05\x04\0\x02\x1c\x05\x12\x03E\x02\x08\n\x0c\n\x05\x04\0\x02\x1c\x01\
    \x12\x03E\t\x11\n\x0c\n\x05\x04\0\x02\x1c\x03\x12\x03E\x14\x16\n\x0b\n\
    \x04\x04\0\x02\x1d\x12\x03F\x02\x17\n\x0c\n\x05\x04\0\x02\x1d\x05\x12\
    \x03F\x02\x08\n\x0c\n\x05\x04\0\x02\x1d\x01\x12\x03F\t\x11\n\x0c\n\x05\
    \x04\0\x02\x1d\x03\x12\x03F\x14\x16\n\x0b\n\x04\x04\0\x02\x1e\x12\x03G\
    \x02\x17\n\x0c\n\x05\x04\0\x02\x1e\x05\x12\x03G\x02\x08\n\x0c\n\x05\x04\
    \0\x02\x1e\x01\x12\x03G\t\x11\n\x0c\n\x05\x04\0\x02\x1e\x03\x12\x03G\x14\
    \x16\n\x0b\n\x04\x04\0\x02\x1f\x12\x03H\x02\x1c\n\x0c\n\x05\x04\0\x02\
    \x1f\x05\x12\x03H\x02\x08\n\x0c\n\x05\x04\0\x02\x1f\x01\x12\x03H\t\x16\n\
    \x0c\n\x05\x04\0\x02\x1f\x03\x12\x03H\x19\x1b\n$\n\x04\x04\0\x02\x20\x12\
    \x03J\x02\x19\x1a\x17\x20Fragments\x20(IPv4/IPv6)\n\n\x0c\n\x05\x04\0\
    \x02\x20\x05\x12\x03J\x02\x08\n\x0c\n\x05\x04\0\x02\x20\x01\x12\x03J\t\
    \x13\n\x0c\n\x05\x04\0\x02\x20\x03\x12\x03J\x16\x18\n\x0b\n\x04\x04\0\
    \x02!\x12\x03K\x02\x1d\n\x0c\n\x05\x04\0\x02!\x05\x12\x03K\x02\x08\n\x0c\
    \n\x05\x04\0\x02!\x01\x12\x03K\t\x17\n\x0c\n\x05\x04\0\x02!\x03\x12\x03K\
    \x1a\x1c\n\x0b\n\x04\x04\0\x02\"\x12\x03L\x02\x1e\n\x0c\n\x05\x04\0\x02\
    \"\x05\x12\x03L\x02\x08\n\x0c\n\x05\x04\0\x02\"\x01\x12\x03L\t\x18\n\x0c\
    \n\x05\x04\0\x02\"\x03\x12\x03L\x1b\x1d\n,\n\x04\x04\0\x02#\x12\x03O\x02\
    \x14\x1a\x1f\x20Autonomous\x20system\x20information\n\n\x0c\n\x05\x04\0\
    \x02#\x05\x12\x03O\x02\x08\n\x0c\n\x05\x04\0\x02#\x01\x12\x03O\t\x0e\n\
    \x0c\n\x05\x04\0\x02#\x03\x12\x03O\x11\x13\n\x0b\n\x04\x04\0\x02$\x12\
    \x03P\x02\x14\n\x0c\n\x05\x04\0\x02$\x05\x12\x03P\x02\x08\n\x0c\n\x05\
    \x04\0\x02$\x01\x12\x03P\t\x0e\n\x0c\n\x05\x04\0\x02$\x03\x12\x03P\x11\
    \x13\n\x0b\n\x04\x04\0\x02%\x12\x03R\x02\x15\n\x0c\n\x05\x04\0\x02%\x05\
    \x12\x03R\x02\x07\n\x0c\n\x05\x04\0\x02%\x01\x12\x03R\x08\x0f\n\x0c\n\
    \x05\x04\0\x02%\x03\x12\x03R\x12\x14\n\x0b\n\x04\x04\0\x02&\x12\x03S\x02\
    \x18\n\x0c\n\x05\x04\0\x02&\x05\x12\x03S\x02\x08\n\x0c\n\x05\x04\0\x02&\
    \x01\x12\x03S\t\x12\n\x0c\n\x05\x04\0\x02&\x03\x12\x03S\x15\x17\n\x1a\n\
    \x04\x04\0\x02'\x12\x03V\x02\x15\x1a\r\x20Prefix\x20size\n\n\x0c\n\x05\
    \x04\0\x02'\x05\x12\x03V\x02\x08\n\x0c\n\x05\x04\0\x02'\x01\x12\x03V\t\
    \x0f\n\x0c\n\x05\x04\0\x02'\x03\x12\x03V\x12\x14\n\x0b\n\x04\x04\0\x02(\
    \x12\x03W\x02\x15\n\x0c\n\x05\x04\0\x02(\x05\x12\x03W\x02\x08\n\x0c\n\
    \x05\x04\0\x02(\x01\x12\x03W\t\x0f\n\x0c\n\x05\x04\0\x02(\x03\x12\x03W\
    \x12\x14\n\x1f\n\x04\x04\0\x02)\x12\x03Z\x02\x14\x1a\x12\x20MPLS\x20info\
    rmation\n\n\x0c\n\x05\x04\0\x02)\x05\x12\x03Z\x02\x06\n\x0c\n\x05\x04\0\
    \x02)\x01\x12\x03Z\x07\x0e\n\x0c\n\x05\x04\0\x02)\x03\x12\x03Z\x11\x13\n\
    \x0b\n\x04\x04\0\x02*\x12\x03[\x02\x18\n\x0c\n\x05\x04\0\x02*\x05\x12\
    \x03[\x02\x08\n\x0c\n\x05\x04\0\x02*\x01\x12\x03[\t\x12\n\x0c\n\x05\x04\
    \0\x02*\x03\x12\x03[\x15\x17\n\x18\n\x04\x04\0\x02+\x12\x03\\\x02\x17\"\
    \x0b\x20First\x20TTL\n\n\x0c\n\x05\x04\0\x02+\x05\x12\x03\\\x02\x08\n\
    \x0c\n\x05\x04\0\x02+\x01\x12\x03\\\t\x11\n\x0c\n\x05\x04\0\x02+\x03\x12\
    \x03\\\x14\x16\n\x1a\n\x04\x04\0\x02,\x12\x03]\x02\x19\"\r\x20First\x20L\
    abel\n\n\x0c\n\x05\x04\0\x02,\x05\x12\x03]\x02\x08\n\x0c\n\x05\x04\0\x02\
    ,\x01\x12\x03]\t\x13\n\x0c\n\x05\x04\0\x02,\x03\x12\x03]\x16\x18\n\x19\n\
    \x04\x04\0\x02-\x12\x03^\x02\x17\"\x0c\x20Second\x20TTL\n\n\x0c\n\x05\
    \x04\0\x02-\x05\x12\x03^\x02\x08\n\x0c\n\x05\x04\0\x02-\x01\x12\x03^\t\
    \x11\n\x0c\n\x05\x04\0\x02-\x03\x12\x03^\x14\x16\n\x1b\n\x04\x04\0\x02.\
    \x12\x03_\x02\x19\"\x0e\x20Second\x20Label\n\n\x0c\n\x05\x04\0\x02.\x05\
    \x12\x03_\x02\x08\n\x0c\n\x05\x04\0\x02.\x01\x12\x03_\t\x13\n\x0c\n\x05\
    \x04\0\x02.\x03\x12\x03_\x16\x18\n\x18\n\x04\x04\0\x02/\x12\x03`\x02\x17\
    \"\x0b\x20Third\x20TTL\n\n\x0c\n\x05\x04\0\x02/\x05\x12\x03`\x02\x08\n\
    \x0c\n\x05\x04\0\x02/\x01\x12\x03`\t\x11\n\x0c\n\x05\x04\0\x02/\x03\x12\
    \x03`\x14\x16\n\x1a\n\x04\x04\0\x020\x12\x03a\x02\x19\"\r\x20Third\x20La\
    bel\n\n\x0c\n\x05\x04\0\x020\x05\x12\x03a\x02\x08\n\x0c\n\x05\x04\0\x020\
    \x01\x12\x03a\t\x13\n\x0c\n\x05\x04\0\x020\x03\x12\x03a\x16\x18\n\x17\n\
    \x04\x04\0\x021\x12\x03b\x02\x1a\"\n\x20Last\x20TTL\n\n\x0c\n\x05\x04\0\
    \x021\x05\x12\x03b\x02\x08\n\x0c\n\x05\x04\0\x021\x01\x12\x03b\t\x14\n\
    \x0c\n\x05\x04\0\x021\x03\x12\x03b\x17\x19\n\x19\n\x04\x04\0\x022\x12\
    \x03c\x02\x1c\"\x0c\x20Last\x20Label\n\n\x0c\n\x05\x04\0\x022\x05\x12\
    \x03c\x02\x08\n\x0c\n\x05\x04\0\x022\x01\x12\x03c\t\x16\n\x0c\n\x05\x04\
    \0\x022\x03\x12\x03c\x19\x1b\n\xf0\x01\n\x04\x04\0\x023\x12\x03i\x02\x14\
    \x1a\x1b\x20bwNetFlow\x20enricher\x20fields\n\"\x80\x01\x20Customer\x20I\
    D\x20-\x20numerical\x20ID,\x20usually\x20assigned\x20by\x20prefix,\x20us\
    ed\x20in\x20cases\x20where\x20any\x20flow\x20is\x20directly\x20mappable\
    \x20to\x20a\x20single\x20customer\n2C\x20Custom\x20fields:\x20start\x20a\
    fter\x20ID\x201000:\n\x20uint32\x20MyCustomField\x20=\x201000;\n\n\x0c\n\
    \x05\x04\0\x023\x05\x12\x03i\x02\x08\n\x0c\n\x05\x04\0\x023\x01\x12\x03i\
    \t\x0c\n\x0c\n\x05\x04\0\x023\x03\x12\x03i\x0f\x13\n\x19\n\x04\x04\0\x02\
    4\x12\x03j\x02\x1a\"\x0c\x20deprecated\n\n\x0c\n\x05\x04\0\x024\x05\x12\
    \x03j\x02\x08\n\x0c\n\x05\x04\0\x024\x01\x12\x03j\t\x12\n\x0c\n\x05\x04\
    \0\x024\x03\x12\x03j\x15\x19\nI\n\x04\x04\0\x025\x12\x03k\x02\x17\"<\x20\
    Src\x20Customer\x20ID\x20-\x20numerical\x20ID,\x20usually\x20assigned\
    \x20by\x20prefix\n\n\x0c\n\x05\x04\0\x025\x05\x12\x03k\x02\x08\n\x0c\n\
    \x05\x04\0\x025\x01\x12\x03k\t\x0f\n\x0c\n\x05\x04\0\x025\x03\x12\x03k\
    \x12\x16\nI\n\x04\x04\0\x026\x12\x03l\x02\x17\"<\x20Dst\x20Customer\x20I\
    D\x20-\x20numerical\x20ID,\x20usually\x20assigned\x20by\x20prefix\n\n\
    \x0c\n\x05\x04\0\x026\x05\x12\x03l\x02\x08\n\x0c\n\x05\x04\0\x026\x01\
    \x12\x03l\t\x0f\n\x0c\n\x05\x04\0\x026\x03\x12\x03l\x12\x16\n\x0c\n\x04\
    \x04\0\x04\x01\x12\x04o\x02r\x03\n\x0c\n\x05\x04\0\x04\x01\x01\x12\x03o\
    \x07\x15\n\r\n\x06\x04\0\x04\x01\x02\0\x12\x03p\x04\x0b\n\x0e\n\x07\x04\
    \0\x04\x01\x02\0\x01\x12\x03p\x04\x06\n\x0e\n\x07\x04\0\x04\x01\x02\0\
    \x02\x12\x03p\t\n\n\r\n\x06\x04\0\x04\x01\x02\x01\x12\x03q\x04\x0c\n\x0e\
    \n\x07\x04\0\x04\x01\x02\x01\x01\x12\x03q\x04\x07\n\x0e\n\x07\x04\0\x04\
    \x01\x02\x01\x02\x12\x03q\n\x0b\nI\n\x04\x04\0\x027\x12\x03s\x02#\"<\x20\
    Normalization\x20-\x20whether\x20the\x20sampling\x20rate\x20is\x20accoun\
    ted\x20for\n\n\x0c\n\x05\x04\0\x027\x06\x12\x03s\x02\x10\n\x0c\n\x05\x04\
    \0\x027\x01\x12\x03s\x11\x1b\n\x0c\n\x05\x04\0\x027\x03\x12\x03s\x1e\"\n\
    i\n\x04\x04\0\x028\x12\x03v\x02\x1a\x1a7\x20Fields\x20for\x20Interface\
    \x20Usability\x20--\x20enriched\x20using\x20SNMP\n\"#\x20set\x20to\x20th\
    e\x20name,\x20unset\x20by\x20default\n\n\x0c\n\x05\x04\0\x028\x05\x12\
    \x03v\x02\x08\n\x0c\n\x05\x04\0\x028\x01\x12\x03v\t\x12\n\x0c\n\x05\x04\
    \0\x028\x03\x12\x03v\x15\x19\nI\n\x04\x04\0\x029\x12\x03w\x02\x1a\"<\x20\
    set\x20to\x20the\x20descrition,\x20filtered\x20by\x20a\x20regex\x20in\
    \x20the\x20enricher\n\n\x0c\n\x05\x04\0\x029\x05\x12\x03w\x02\x08\n\x0c\
    \n\x05\x04\0\x029\x01\x12\x03w\t\x12\n\x0c\n\x05\x04\0\x029\x03\x12\x03w\
    \x15\x19\n\x1a\n\x04\x04\0\x02:\x12\x03x\x02\x1b\"\r\x20iface\x20speed\n\
    \n\x0c\n\x05\x04\0\x02:\x05\x12\x03x\x02\x08\n\x0c\n\x05\x04\0\x02:\x01\
    \x12\x03x\t\x13\n\x0c\n\x05\x04\0\x02:\x03\x12\x03x\x16\x1a\n\x0b\n\x04\
    \x04\0\x02;\x12\x03y\x02\x1a\n\x0c\n\x05\x04\0\x02;\x05\x12\x03y\x02\x08\
    \n\x0c\n\x05\x04\0\x02;\x01\x12\x03y\t\x12\n\x0c\n\x05\x04\0\x02;\x03\
    \x12\x03y\x15\x19\n\x0b\n\x04\x04\0\x02<\x12\x03z\x02\x1a\n\x0c\n\x05\
    \x04\0\x02<\x05\x12\x03z\x02\x08\n\x0c\n\x05\x04\0\x02<\x01\x12\x03z\t\
    \x12\n\x0c\n\x05\x04\0\x02<\x03\x12\x03z\x15\x19\n\x0b\n\x04\x04\0\x02=\
    \x12\x03{\x02\x1b\n\x0c\n\x05\x04\0\x02=\x05\x12\x03{\x02\x08\n\x0c\n\
    \x05\x04\0\x02=\x01\x12\x03{\t\x13\n\x0c\n\x05\x04\0\x02=\x03\x12\x03{\
    \x16\x1a\nQ\n\x04\x04\0\x02>\x12\x03}\x02\x1a\"D\x20Protocol\x20Name\x20\
    --\x20set\x20for\x20some\x20well\x20known\x20protocols,\x20based\x20on\
    \x20Proto\n\n\x0c\n\x05\x04\0\x02>\x05\x12\x03}\x02\x08\n\x0c\n\x05\x04\
    \0\x02>\x01\x12\x03}\t\x12\n\x0c\n\x05\x04\0\x02>\x03\x12\x03}\x15\x19\n\
    =\n\x04\x04\0\x02?\x12\x03~\x02\x1e\"0\x20Geolocation\x20--\x20set\x20us\
    ing\x20the\x20provided\x20database\n\n\x0c\n\x05\x04\0\x02?\x05\x12\x03~\
    \x02\x08\n\x0c\n\x05\x04\0\x02?\x01\x12\x03~\t\x16\n\x0c\n\x05\x04\0\x02\
    ?\x03\x12\x03~\x19\x1d\n\x1e\n\x04\x04\0\x02@\x12\x03\x7f\x02\x1b\"\x11\
    \x20Src\x20Geolocation\n\n\x0c\n\x05\x04\0\x02@\x05\x12\x03\x7f\x02\x08\
    \n\x0c\n\x05\x04\0\x02@\x01\x12\x03\x7f\t\x13\n\x0c\n\x05\x04\0\x02@\x03\
    \x12\x03\x7f\x16\x1a\n\x1f\n\x04\x04\0\x02A\x12\x04\x80\x01\x02\x1b\"\
    \x11\x20Dst\x20Geolocation\n\n\r\n\x05\x04\0\x02A\x05\x12\x04\x80\x01\
    \x02\x08\n\r\n\x05\x04\0\x02A\x01\x12\x04\x80\x01\t\x13\n\r\n\x05\x04\0\
    \x02A\x03\x12\x04\x80\x01\x16\x1a\n\x0e\n\x04\x04\0\x04\x02\x12\x06\x82\
    \x01\x02\x86\x01\x03\n\r\n\x05\x04\0\x04\x02\x01\x12\x04\x82\x01\x07\x15\
    \n\x0e\n\x06\x04\0\x04\x02\x02\0\x12\x04\x83\x01\x04\x10\n\x0f\n\x07\x04\
    \0\x04\x02\x02\0\x01\x12\x04\x83\x01\x04\x0b\n\x0f\n\x07\x04\0\x04\x02\
    \x02\0\x02\x12\x04\x83\x01\x0e\x0f\n\x0e\n\x06\x04\0\x04\x02\x02\x01\x12\
    \x04\x84\x01\x04\x0c\n\x0f\n\x07\x04\0\x04\x02\x02\x01\x01\x12\x04\x84\
    \x01\x04\x07\n\x0f\n\x07\x04\0\x04\x02\x02\x01\x02\x12\x04\x84\x01\n\x0b\
    \n\x0e\n\x06\x04\0\x04\x02\x02\x02\x12\x04\x85\x01\x04\x0c\n\x0f\n\x07\
    \x04\0\x04\x02\x02\x02\x01\x12\x04\x85\x01\x04\x07\n\x0f\n\x07\x04\0\x04\
    \x02\x02\x02\x02\x12\x04\x85\x01\n\x0b\nO\n\x04\x04\0\x02B\x12\x04\x87\
    \x01\x02#\"A\x20RemoteAddr\x20-\x20which\x20Addr\x20field\x20contains\
    \x20the\x20remote/local\x20address\n\n\r\n\x05\x04\0\x02B\x06\x12\x04\
    \x87\x01\x02\x10\n\r\n\x05\x04\0\x02B\x01\x12\x04\x87\x01\x11\x1b\n\r\n\
    \x05\x04\0\x02B\x03\x12\x04\x87\x01\x1e\"\n5\n\x04\x04\0\x02C\x12\x04\
    \x89\x01\x02\x15\"'\x20free-form\x20field\x20to\x20implement\x20anything\
    \n\n\r\n\x05\x04\0\x02C\x05\x12\x04\x89\x01\x02\x08\n\r\n\x05\x04\0\x02C\
    \x01\x12\x04\x89\x01\t\r\n\r\n\x05\x04\0\x02C\x03\x12\x04\x89\x01\x10\
    \x14b\x06proto3\
";

/// `FileDescriptorProto` object which was a source for this generated file
pub fn file_descriptor_proto() -> &'static ::protobuf::descriptor::FileDescriptorProto {
    static file_descriptor_proto_lazy: ::protobuf::rt::LazyV2<::protobuf::descriptor::FileDescriptorProto> = ::protobuf::rt::LazyV2::INIT;
    file_descriptor_proto_lazy.get(|| {
        ::protobuf::Message::parse_from_bytes(file_descriptor_proto_data).unwrap()
    })
}

/// `FileDescriptor` object which allows dynamic access to files
pub fn file_descriptor() -> ::protobuf::reflect::FileDescriptor {
    static file_descriptor_lazy: ::protobuf::rt::LazyV2<::protobuf::reflect::GeneratedFileDescriptor> = ::protobuf::rt::LazyV2::INIT;
    let file_descriptor = file_descriptor_lazy.get(|| {
        let mut deps = ::std::vec::Vec::new();
        let mut messages = ::std::vec::Vec::new();
        messages.push(FlowMessage::generated_message_descriptor_data());
        let mut enums = ::std::vec::Vec::new();
        enums.push(flow_message::FlowType::generated_enum_descriptor_data());
        enums.push(flow_message::NormalizedType::generated_enum_descriptor_data());
        enums.push(flow_message::RemoteAddrType::generated_enum_descriptor_data());
        ::protobuf::reflect::GeneratedFileDescriptor::new_generated(
            file_descriptor_proto(),
            deps,
            messages,
            enums,
        )
    });
    ::protobuf::reflect::FileDescriptor::new_generated_2(file_descriptor)
}
